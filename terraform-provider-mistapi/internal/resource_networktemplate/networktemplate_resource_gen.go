// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_networktemplate

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func NetworktemplateResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"additional_config_cmds": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"dhcp_snooping": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"all_networks": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"enable_arp_spoof_check": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enable for dynamic ARP inspection check",
						MarkdownDescription: "Enable for dynamic ARP inspection check",
					},
					"enable_ip_source_guard": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enable for check for forging source IP address",
						MarkdownDescription: "Enable for check for forging source IP address",
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"networks": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "if `all_networks`==`false`, list of network with DHCP snooping enabled",
						MarkdownDescription: "if `all_networks`==`false`, list of network with DHCP snooping enabled",
					},
				},
				CustomType: DhcpSnoopingType{
					ObjectType: types.ObjectType{
						AttrTypes: DhcpSnoopingValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"dns_servers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"dns_suffix": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"mist_nac": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"network": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: MistNacType{
					ObjectType: types.ObjectType{
						AttrTypes: MistNacValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "enable mist_nac to use radsec",
				MarkdownDescription: "enable mist_nac to use radsec",
			},
			"name": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"networks": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"subnet": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"vlan_id": schema.Int64Attribute{
							Optional: true,
							Computed: true,
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is network name",
				MarkdownDescription: "Property key is network name",
			},
			"ntp_servers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"org_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"port_usages": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"all_networks": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `mode`==`trunk`, whether to trunk all network/vlans",
							MarkdownDescription: "if `mode`==`trunk`, whether to trunk all network/vlans",
							Default:             booldefault.StaticBool(false),
						},
						"allow_dhcpd": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri-state.\n\nWhen it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.",
							MarkdownDescription: "if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri-state.\n\nWhen it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.",
						},
						"allow_multiple_supplicants": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"bypass_auth_when_server_down": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`==`dot1x`, bypass auth for known clients if set to true when RADIUS server is down",
							MarkdownDescription: "if `port_auth`==`dot1x`, bypass auth for known clients if set to true when RADIUS server is down",
							Default:             booldefault.StaticBool(false),
						},
						"bypass_auth_when_server_down_for_unkonwn_client": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`=`dot1x`, bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							MarkdownDescription: "if `port_auth`=`dot1x`, bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							Default:             booldefault.StaticBool(false),
						},
						"description": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "description",
							MarkdownDescription: "description",
						},
						"disable_autoneg": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if speed and duplex are specified, whether to disable autonegotiation",
							MarkdownDescription: "if speed and duplex are specified, whether to disable autonegotiation",
							Default:             booldefault.StaticBool(false),
						},
						"disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether the port is disabled",
							MarkdownDescription: "whether the port is disabled",
							Default:             booldefault.StaticBool(false),
						},
						"duplex": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "link connection mode, choices are auto (default), full, and half",
							MarkdownDescription: "link connection mode, choices are auto (default), full, and half",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"half",
									"full",
									"auto",
								),
							},
							Default: stringdefault.StaticString("auto"),
						},
						"dynamic_vlan_networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
							MarkdownDescription: "if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
						},
						"enable_mac_auth": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`==`dot1x`, whether to enable MAC Auth",
							MarkdownDescription: "if `port_auth`==`dot1x`, whether to enable MAC Auth",
							Default:             booldefault.StaticBool(false),
						},
						"enable_qos": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"guest_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`==`dot1x`, which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
							MarkdownDescription: "if `port_auth`==`dot1x`, which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
						},
						"mac_auth_only": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "only effect once `enable_mac_auth`==`true`",
							MarkdownDescription: "only effect once `enable_mac_auth`==`true`",
						},
						"mac_auth_protocol": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled.",
							MarkdownDescription: "if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"pap",
									"eap-peap",
									"eap-md5",
								),
							},
							Default: stringdefault.StaticString("eap-md5"),
						},
						"mac_limit": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform",
							MarkdownDescription: "max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform",
							Validators: []validator.Int64{
								int64validator.AtLeast(0),
							},
							Default: int64default.StaticInt64(0),
						},
						"mode": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "access (default) / trunk",
							MarkdownDescription: "access (default) / trunk",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"access",
									"trunk",
									"inet",
									"wan",
								),
							},
						},
						"mtu": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.",
							MarkdownDescription: "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.",
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "if `mode`==`trunk`, the list of network/vlans",
							MarkdownDescription: "if `mode`==`trunk`, the list of network/vlans",
						},
						"persist_mac": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `mode`==`access` and `port_auth`!=`dot1x`, whether the port should retain dynamically learned MAC addresses",
							MarkdownDescription: "if `mode`==`access` and `port_auth`!=`dot1x`, whether the port should retain dynamically learned MAC addresses",
							Default:             booldefault.StaticBool(false),
						},
						"poe_disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether PoE capabilities are disabled for a port",
							MarkdownDescription: "whether PoE capabilities are disabled for a port",
							Default:             booldefault.StaticBool(false),
						},
						"port_auth": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if dot1x is desired, set to dot1x",
							MarkdownDescription: "if dot1x is desired, set to dot1x",
						},
						"port_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "native network/vlan for untagged traffic",
							MarkdownDescription: "native network/vlan for untagged traffic",
						},
						"reauth_interval": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`=`dot1x`, reauthentication interval range",
							MarkdownDescription: "if `port_auth`=`dot1x`, reauthentication interval range",
							Validators: []validator.Int64{
								int64validator.Between(10, 65535),
							},
							Default: int64default.StaticInt64(3600),
						},
						"rejected_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`==`dot1x`, when radius server reject / fails",
							MarkdownDescription: "if `port_auth`==`dot1x`, when radius server reject / fails",
						},
						"speed": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "speed, default is auto to automatically negotiate speed",
							MarkdownDescription: "speed, default is auto to automatically negotiate speed",
						},
						"storm_control": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"no_broadcast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on broadcast traffic",
									MarkdownDescription: "whether to disable storm control on broadcast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"no_multicast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on multicast traffic",
									MarkdownDescription: "whether to disable storm control on multicast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"no_registered_multicast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on registered multicast traffic",
									MarkdownDescription: "whether to disable storm control on registered multicast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"no_unknown_unicast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on unknown unicast traffic",
									MarkdownDescription: "whether to disable storm control on unknown unicast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"percentage": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									MarkdownDescription: "bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									Validators: []validator.Int64{
										int64validator.Between(0, 100),
									},
									Default: int64default.StaticInt64(80),
								},
							},
							CustomType: StormControlType{
								ObjectType: types.ObjectType{
									AttrTypes: StormControlValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Switch storm control",
							MarkdownDescription: "Switch storm control",
						},
						"stp_edge": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "when enabled, the port is not expected to receive BPDU frames",
							MarkdownDescription: "when enabled, the port is not expected to receive BPDU frames",
							Default:             booldefault.StaticBool(false),
						},
						"voip_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
							MarkdownDescription: "network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
						},
					},
					CustomType: PortUsagesType{
						ObjectType: types.ObjectType{
							AttrTypes: PortUsagesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is the port profile name",
				MarkdownDescription: "Property key is the port profile name",
			},
			"radius_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"acct_interim_interval": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						MarkdownDescription: "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						Validators: []validator.Int64{
							int64validator.Between(0, 65535),
						},
						Default: int64default.StaticInt64(0),
					},
					"acct_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "ip / hostname of RADIUS server",
									MarkdownDescription: "ip / hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"hex",
											"ascii",
										),
									},
									Default: stringdefault.StaticString("ascii"),
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"port": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Acct port of RADIUS server",
									MarkdownDescription: "Acct port of RADIUS server",
									Default:             int64default.StaticInt64(1813),
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Description:         "secret of RADIUS server",
									MarkdownDescription: "secret of RADIUS server",
								},
							},
							CustomType: AcctServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							listvalidator.UniqueValues(),
						},
					},
					"auth_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "ip / hostname of RADIUS server",
									MarkdownDescription: "ip / hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"hex",
											"ascii",
										),
									},
									Default: stringdefault.StaticString("ascii"),
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"port": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Auth port of RADIUS server",
									MarkdownDescription: "Auth port of RADIUS server",
									Default:             int64default.StaticInt64(1812),
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Description:         "secret of RADIUS server",
									MarkdownDescription: "secret of RADIUS server",
								},
							},
							CustomType: AuthServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							listvalidator.UniqueValues(),
						},
					},
					"auth_servers_retries": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "radius auth session retries",
						MarkdownDescription: "radius auth session retries",
						Default:             int64default.StaticInt64(3),
					},
					"auth_servers_timeout": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "radius auth session timeout",
						MarkdownDescription: "radius auth session timeout",
						Default:             int64default.StaticInt64(5),
					},
					"coa_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"coa_port": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(3799),
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "use `network`or `source_ip`\nwhich network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
						MarkdownDescription: "use `network`or `source_ip`\nwhich network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
					},
					"source_ip": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "use `network`or `source_ip`",
						MarkdownDescription: "use `network`or `source_ip`",
					},
				},
				CustomType: RadiusConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Junos Radius config",
				MarkdownDescription: "Junos Radius config",
			},
			"remote_syslog": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"archive": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"files": schema.Int64Attribute{
								Optional: true,
								Computed: true,
							},
							"size": schema.StringAttribute{
								Optional: true,
								Computed: true,
							},
						},
						CustomType: ArchiveType{
							ObjectType: types.ObjectType{
								AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"console": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"contents": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"facility": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"any",
													"authorization",
													"conflict-log",
													"change-log",
													"config",
													"daemon",
													"dfc",
													"kernel",
													"interactive-commands",
													"ftp",
													"firewall",
													"external",
													"pfe",
													"ntp",
													"security",
													"user",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
										"severity": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"any",
													"alert",
													"emergency",
													"critical",
													"warning",
													"info",
													"notice",
													"error",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
									},
									CustomType: ContentsType{
										ObjectType: types.ObjectType{
											AttrTypes: ContentsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
							},
						},
						CustomType: ConsoleType{
							ObjectType: types.ObjectType{
								AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"files": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"archive": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"files": schema.Int64Attribute{
											Optional: true,
											Computed: true,
										},
										"size": schema.StringAttribute{
											Optional: true,
											Computed: true,
										},
									},
									CustomType: ArchiveType{
										ObjectType: types.ObjectType{
											AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
									Computed: true,
								},
								"contents": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"facility": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"any",
														"authorization",
														"conflict-log",
														"change-log",
														"config",
														"daemon",
														"dfc",
														"kernel",
														"interactive-commands",
														"ftp",
														"firewall",
														"external",
														"pfe",
														"ntp",
														"security",
														"user",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
											"severity": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"any",
														"alert",
														"emergency",
														"critical",
														"warning",
														"info",
														"notice",
														"error",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
										},
										CustomType: ContentsType{
											ObjectType: types.ObjectType{
												AttrTypes: ContentsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
									Computed: true,
								},
								"explicit_priority": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"file": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"match": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"structured_data": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
							},
							CustomType: FilesType{
								ObjectType: types.ObjectType{
									AttrTypes: FilesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "if source_address is configured, will use the vlan firstly otherwise use source_ip",
						MarkdownDescription: "if source_address is configured, will use the vlan firstly otherwise use source_ip",
					},
					"send_to_all_servers": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"contents": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"facility": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"any",
														"authorization",
														"conflict-log",
														"change-log",
														"config",
														"daemon",
														"dfc",
														"kernel",
														"interactive-commands",
														"ftp",
														"firewall",
														"external",
														"pfe",
														"ntp",
														"security",
														"user",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
											"severity": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"any",
														"alert",
														"emergency",
														"critical",
														"warning",
														"info",
														"notice",
														"error",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
										},
										CustomType: ContentsType{
											ObjectType: types.ObjectType{
												AttrTypes: ContentsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
									Computed: true,
								},
								"explicit_priority": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"facility": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"any",
											"authorization",
											"conflict-log",
											"change-log",
											"config",
											"daemon",
											"dfc",
											"kernel",
											"interactive-commands",
											"ftp",
											"firewall",
											"external",
											"pfe",
											"ntp",
											"security",
											"user",
										),
									},
									Default: stringdefault.StaticString("any"),
								},
								"host": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"match": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"port": schema.Int64Attribute{
									Optional: true,
									Computed: true,
									Default:  int64default.StaticInt64(514),
								},
								"protocol": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"udp",
											"tcp",
										),
									},
									Default: stringdefault.StaticString("udp"),
								},
								"routing_instance": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"severity": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"any",
											"alert",
											"emergency",
											"critical",
											"warning",
											"info",
											"notice",
											"error",
										),
									},
									Default: stringdefault.StaticString("any"),
								},
								"source_address": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if source_address is configured, will use the vlan firstly otherwise use source_ip",
									MarkdownDescription: "if source_address is configured, will use the vlan firstly otherwise use source_ip",
								},
								"structured_data": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"tag": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
							},
							CustomType: ServersType{
								ObjectType: types.ObjectType{
									AttrTypes: ServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
					"time_format": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"millisecond",
								"year",
								"year millisecond",
							),
						},
						Default: stringdefault.StaticString("millisecond"),
					},
					"users": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"contents": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"facility": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"any",
														"authorization",
														"conflict-log",
														"change-log",
														"config",
														"daemon",
														"dfc",
														"kernel",
														"interactive-commands",
														"ftp",
														"firewall",
														"external",
														"pfe",
														"ntp",
														"security",
														"user",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
											"severity": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"any",
														"alert",
														"emergency",
														"critical",
														"warning",
														"info",
														"notice",
														"error",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
										},
										CustomType: ContentsType{
											ObjectType: types.ObjectType{
												AttrTypes: ContentsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
									Computed: true,
								},
								"match": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"user": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
							},
							CustomType: UsersType{
								ObjectType: types.ObjectType{
									AttrTypes: UsersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
				},
				CustomType: RemoteSyslogType{
					ObjectType: types.ObjectType{
						AttrTypes: RemoteSyslogValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"switch_matching": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enable": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"rules": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"additional_config_cmds": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Computed:    true,
								},
								"match_role": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "role to match",
									MarkdownDescription: "role to match",
								},
								"name": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"port_config": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ae_disable_lacp": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "To disable LACP support for the AE interface",
												MarkdownDescription: "To disable LACP support for the AE interface",
											},
											"ae_idx": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "Users could force to use the designated AE name",
												MarkdownDescription: "Users could force to use the designated AE name",
											},
											"ae_lacp_slow": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "to use fast timeout",
												MarkdownDescription: "to use fast timeout",
												Default:             booldefault.StaticBool(true),
											},
											"aggregated": schema.BoolAttribute{
												Optional: true,
												Computed: true,
												Default:  booldefault.StaticBool(false),
											},
											"critical": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "if want to generate port up/down alarm",
												MarkdownDescription: "if want to generate port up/down alarm",
											},
											"description": schema.StringAttribute{
												Optional: true,
												Computed: true,
											},
											"disable_autoneg": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "if `speed` and `duplex` are specified, whether to disable autonegotiation",
												MarkdownDescription: "if `speed` and `duplex` are specified, whether to disable autonegotiation",
												Default:             booldefault.StaticBool(false),
											},
											"duplex": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"auto",
														"full",
														"half",
													),
												},
												Default: stringdefault.StaticString("auto"),
											},
											"dynamic_usage": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Enable dynamic usage for this port. Set to `dynamic` to enable.",
												MarkdownDescription: "Enable dynamic usage for this port. Set to `dynamic` to enable.",
											},
											"esilag": schema.BoolAttribute{
												Optional: true,
												Computed: true,
											},
											"inter_switch_link": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "inter_switch_link is used together with \"isolation\" under networks\nNOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together",
												MarkdownDescription: "inter_switch_link is used together with \"isolation\" under networks\nNOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together",
												Default:             booldefault.StaticBool(false),
											},
											"mtu": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation",
												MarkdownDescription: "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation",
												Default:             int64default.StaticInt64(1514),
											},
											"no_local_overwrite": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "prevent helpdesk to override the port config",
												MarkdownDescription: "prevent helpdesk to override the port config",
											},
											"poe_disabled": schema.BoolAttribute{
												Optional: true,
												Computed: true,
												Default:  booldefault.StaticBool(false),
											},
											"speed": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"auto",
														"10m",
														"100m",
														"1g",
														"2.5g",
														"5g",
													),
												},
												Default: stringdefault.StaticString("auto"),
											},
											"usage": schema.StringAttribute{
												Required:            true,
												Description:         "port usage name. \n\nIf EVPN is used, use `evpn_uplink`or `evpn_downlink`",
												MarkdownDescription: "port usage name. \n\nIf EVPN is used, use `evpn_uplink`or `evpn_downlink`",
											},
										},
										CustomType: PortConfigType{
											ObjectType: types.ObjectType{
												AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Propery key is the interface name or interface range",
									MarkdownDescription: "Propery key is the interface name or interface range",
								},
								"port_mirroring": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"input_networks_ingress": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
												Computed:    true,
											},
											"input_port_ids_egress": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
												Computed:    true,
											},
											"input_port_ids_ingress": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
												Computed:    true,
											},
											"output_port_id": schema.StringAttribute{
												Optional: true,
												Computed: true,
											},
										},
										CustomType: PortMirroringType{
											ObjectType: types.ObjectType{
												AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
									Computed: true,
								},
							},
							CustomType: RulesType{
								ObjectType: types.ObjectType{
									AttrTypes: RulesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
				},
				CustomType: SwitchMatchingType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchMatchingValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Switch template",
				MarkdownDescription: "Switch template",
			},
			"switch_mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"config_revert": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(10),
					},
					"protect_re": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allowed_services": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "optionally, services we'll allow",
								MarkdownDescription: "optionally, services we'll allow",
							},
							"custom": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"port_range": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "matched dst port, \"0\" means any",
											MarkdownDescription: "matched dst port, \"0\" means any",
											Default:             stringdefault.StaticString("0"),
										},
										"protocol": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"tcp",
													"udp",
													"icmp",
													"any",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
										"subnet": schema.ListAttribute{
											ElementType: types.StringType,
											Optional:    true,
											Computed:    true,
										},
									},
									CustomType: CustomType{
										ObjectType: types.ObjectType{
											AttrTypes: CustomValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "when enabled, all traffic that is not essential to our operation will be dropped\ne.g. ntp / dns / traffic to mist will be allowed by default\n     if dhcpd is enabled, we'll make sure it works",
								MarkdownDescription: "when enabled, all traffic that is not essential to our operation will be dropped\ne.g. ntp / dns / traffic to mist will be allowed by default\n     if dhcpd is enabled, we'll make sure it works",
								Default:             booldefault.StaticBool(false),
							},
							"trusted_hosts": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "host/subnets we'll allow traffic to/from",
								MarkdownDescription: "host/subnets we'll allow traffic to/from",
							},
						},
						CustomType: ProtectReType{
							ObjectType: types.ObjectType{
								AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "restrict inbound-traffic to host\nwhen enabled, all traffic that is not essential to our operation will be dropped \ne.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works",
						MarkdownDescription: "restrict inbound-traffic to host\nwhen enabled, all traffic that is not essential to our operation will be dropped \ne.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works",
					},
					"root_password": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"tacacs": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"acct_servers": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"host": schema.StringAttribute{
											Optional: true,
											Computed: true,
										},
										"port": schema.StringAttribute{
											Optional: true,
											Computed: true,
										},
										"secret": schema.StringAttribute{
											Optional: true,
											Computed: true,
										},
										"timeout": schema.Int64Attribute{
											Optional: true,
											Computed: true,
											Default:  int64default.StaticInt64(10),
										},
									},
									CustomType: AcctServersType{
										ObjectType: types.ObjectType{
											AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
							},
							"enabled": schema.BoolAttribute{
								Optional: true,
								Computed: true,
							},
							"network": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "which network the TACACS server resides",
								MarkdownDescription: "which network the TACACS server resides",
							},
							"tacplus_servers": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"host": schema.StringAttribute{
											Optional: true,
											Computed: true,
										},
										"port": schema.StringAttribute{
											Optional: true,
											Computed: true,
										},
										"secret": schema.StringAttribute{
											Optional: true,
											Computed: true,
										},
										"timeout": schema.Int64Attribute{
											Optional: true,
											Computed: true,
											Default:  int64default.StaticInt64(10),
										},
									},
									CustomType: TacplusServersType{
										ObjectType: types.ObjectType{
											AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
							},
						},
						CustomType: TacacsType{
							ObjectType: types.ObjectType{
								AttrTypes: TacacsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
				},
				CustomType: SwitchMgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchMgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"vrf_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to enable VRF (when supported on the device)",
						MarkdownDescription: "whether to enable VRF (when supported on the device)",
					},
				},
				CustomType: VrfConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: VrfConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"vrf_instances": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"extra_routes": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"via": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Next-hop address",
										MarkdownDescription: "Next-hop address",
									},
								},
								CustomType: ExtraRoutesType{
									ObjectType: types.ObjectType{
										AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Property key is the destination CIDR (e.g. \"10.0.0.0/8\")",
							MarkdownDescription: "Property key is the destination CIDR (e.g. \"10.0.0.0/8\")",
						},
						"networks": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
							Computed:    true,
							Validators: []validator.List{
								listvalidator.UniqueValues(),
							},
						},
					},
					CustomType: VrfInstancesType{
						ObjectType: types.ObjectType{
							AttrTypes: VrfInstancesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is the VRF name",
				MarkdownDescription: "Property key is the VRF name",
			},
		},
	}
}

type NetworktemplateModel struct {
	AdditionalConfigCmds types.List          `tfsdk:"additional_config_cmds"`
	DhcpSnooping         DhcpSnoopingValue   `tfsdk:"dhcp_snooping"`
	DnsServers           types.List          `tfsdk:"dns_servers"`
	DnsSuffix            types.List          `tfsdk:"dns_suffix"`
	Id                   types.String        `tfsdk:"id"`
	MistNac              MistNacValue        `tfsdk:"mist_nac"`
	Name                 types.String        `tfsdk:"name"`
	Networks             types.Map           `tfsdk:"networks"`
	NtpServers           types.List          `tfsdk:"ntp_servers"`
	OrgId                types.String        `tfsdk:"org_id"`
	PortUsages           types.Map           `tfsdk:"port_usages"`
	RadiusConfig         RadiusConfigValue   `tfsdk:"radius_config"`
	RemoteSyslog         RemoteSyslogValue   `tfsdk:"remote_syslog"`
	SwitchMatching       SwitchMatchingValue `tfsdk:"switch_matching"`
	SwitchMgmt           SwitchMgmtValue     `tfsdk:"switch_mgmt"`
	VrfConfig            VrfConfigValue      `tfsdk:"vrf_config"`
	VrfInstances         types.Map           `tfsdk:"vrf_instances"`
}

var _ basetypes.ObjectTypable = DhcpSnoopingType{}

type DhcpSnoopingType struct {
	basetypes.ObjectType
}

func (t DhcpSnoopingType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpSnoopingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpSnoopingType) String() string {
	return "DhcpSnoopingType"
}

func (t DhcpSnoopingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return nil, diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return nil, diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableIpSourceGuardAttribute, ok := attributes["enable_ip_source_guard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ip_source_guard is missing from object`)

		return nil, diags
	}

	enableIpSourceGuardVal, ok := enableIpSourceGuardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ip_source_guard expected to be basetypes.BoolValue, was: %T`, enableIpSourceGuardAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpSnoopingValue{
		AllNetworks:         allNetworksVal,
		EnableArpSpoofCheck: enableArpSpoofCheckVal,
		EnableIpSourceGuard: enableIpSourceGuardVal,
		Enabled:             enabledVal,
		Networks:            networksVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDhcpSnoopingValueNull() DhcpSnoopingValue {
	return DhcpSnoopingValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpSnoopingValueUnknown() DhcpSnoopingValue {
	return DhcpSnoopingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpSnoopingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpSnoopingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpSnoopingValue Attribute Value",
				"While creating a DhcpSnoopingValue value, a missing attribute value was detected. "+
					"A DhcpSnoopingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpSnoopingValue Attribute Type",
				"While creating a DhcpSnoopingValue value, an invalid attribute value was detected. "+
					"A DhcpSnoopingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpSnoopingValue Attribute Value",
				"While creating a DhcpSnoopingValue value, an extra attribute value was detected. "+
					"A DhcpSnoopingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpSnoopingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpSnoopingValueUnknown(), diags
	}

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableIpSourceGuardAttribute, ok := attributes["enable_ip_source_guard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ip_source_guard is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enableIpSourceGuardVal, ok := enableIpSourceGuardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ip_source_guard expected to be basetypes.BoolValue, was: %T`, enableIpSourceGuardAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewDhcpSnoopingValueUnknown(), diags
	}

	return DhcpSnoopingValue{
		AllNetworks:         allNetworksVal,
		EnableArpSpoofCheck: enableArpSpoofCheckVal,
		EnableIpSourceGuard: enableIpSourceGuardVal,
		Enabled:             enabledVal,
		Networks:            networksVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDhcpSnoopingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpSnoopingValue {
	object, diags := NewDhcpSnoopingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpSnoopingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpSnoopingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpSnoopingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpSnoopingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpSnoopingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpSnoopingValueMust(DhcpSnoopingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpSnoopingType) ValueType(ctx context.Context) attr.Value {
	return DhcpSnoopingValue{}
}

var _ basetypes.ObjectValuable = DhcpSnoopingValue{}

type DhcpSnoopingValue struct {
	AllNetworks         basetypes.BoolValue `tfsdk:"all_networks"`
	EnableArpSpoofCheck basetypes.BoolValue `tfsdk:"enable_arp_spoof_check"`
	EnableIpSourceGuard basetypes.BoolValue `tfsdk:"enable_ip_source_guard"`
	Enabled             basetypes.BoolValue `tfsdk:"enabled"`
	Networks            basetypes.ListValue `tfsdk:"networks"`
	state               attr.ValueState
}

func (v DhcpSnoopingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["all_networks"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_arp_spoof_check"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_ip_source_guard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AllNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["all_networks"] = val

		val, err = v.EnableArpSpoofCheck.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_arp_spoof_check"] = val

		val, err = v.EnableIpSourceGuard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_ip_source_guard"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpSnoopingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpSnoopingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpSnoopingValue) String() string {
	return "DhcpSnoopingValue"
}

func (v DhcpSnoopingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":           basetypes.BoolType{},
			"enable_arp_spoof_check": basetypes.BoolType{},
			"enable_ip_source_guard": basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"all_networks":           basetypes.BoolType{},
		"enable_arp_spoof_check": basetypes.BoolType{},
		"enable_ip_source_guard": basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"all_networks":           v.AllNetworks,
			"enable_arp_spoof_check": v.EnableArpSpoofCheck,
			"enable_ip_source_guard": v.EnableIpSourceGuard,
			"enabled":                v.Enabled,
			"networks":               networksVal,
		})

	return objVal, diags
}

func (v DhcpSnoopingValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpSnoopingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllNetworks.Equal(other.AllNetworks) {
		return false
	}

	if !v.EnableArpSpoofCheck.Equal(other.EnableArpSpoofCheck) {
		return false
	}

	if !v.EnableIpSourceGuard.Equal(other.EnableIpSourceGuard) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v DhcpSnoopingValue) Type(ctx context.Context) attr.Type {
	return DhcpSnoopingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpSnoopingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"all_networks":           basetypes.BoolType{},
		"enable_arp_spoof_check": basetypes.BoolType{},
		"enable_ip_source_guard": basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = MistNacType{}

type MistNacType struct {
	basetypes.ObjectType
}

func (t MistNacType) Equal(o attr.Type) bool {
	other, ok := o.(MistNacType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MistNacType) String() string {
	return "MistNacType"
}

func (t MistNacType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueNull() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateNull,
	}
}

func NewMistNacValueUnknown() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMistNacValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MistNacValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MistNacValue Attribute Value",
				"While creating a MistNacValue value, a missing attribute value was detected. "+
					"A MistNacValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MistNacValue Attribute Type",
				"While creating a MistNacValue value, an invalid attribute value was detected. "+
					"A MistNacValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MistNacValue Attribute Value",
				"While creating a MistNacValue value, an extra attribute value was detected. "+
					"A MistNacValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MistNacValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MistNacValue {
	object, diags := NewMistNacValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMistNacValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MistNacType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMistNacValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMistNacValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMistNacValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMistNacValueMust(MistNacValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MistNacType) ValueType(ctx context.Context) attr.Value {
	return MistNacValue{}
}

var _ basetypes.ObjectValuable = MistNacValue{}

type MistNacValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Network basetypes.StringValue `tfsdk:"network"`
	state   attr.ValueState
}

func (v MistNacValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MistNacValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MistNacValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MistNacValue) String() string {
	return "MistNacValue"
}

func (v MistNacValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"network": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"network": v.Network,
		})

	return objVal, diags
}

func (v MistNacValue) Equal(o attr.Value) bool {
	other, ok := o.(MistNacValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	return true
}

func (v MistNacValue) Type(ctx context.Context) attr.Type {
	return MistNacType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MistNacValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"network": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		Subnet: subnetVal,
		VlanId: vlanIdVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		Subnet: subnetVal,
		VlanId: vlanIdVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	Subnet basetypes.StringValue `tfsdk:"subnet"`
	VlanId basetypes.Int64Value  `tfsdk:"vlan_id"`
	state  attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"subnet":  basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"subnet":  v.Subnet,
			"vlan_id": v.VlanId,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"subnet":  basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PortUsagesType{}

type PortUsagesType struct {
	basetypes.ObjectType
}

func (t PortUsagesType) Equal(o attr.Type) bool {
	other, ok := o.(PortUsagesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortUsagesType) String() string {
	return "PortUsagesType"
}

func (t PortUsagesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return nil, diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return nil, diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return nil, diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnkonwnClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unkonwn_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unkonwn_client is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownForUnkonwnClientVal, ok := bypassAuthWhenServerDownForUnkonwnClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unkonwn_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnkonwnClientAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return nil, diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return nil, diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return nil, diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return nil, diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return nil, diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return nil, diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return nil, diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return nil, diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return nil, diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return nil, diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return nil, diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.Int64Value, was: %T`, reauthIntervalAttribute))
	}

	rejectedNetworkAttribute, ok := attributes["rejected_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejected_network is missing from object`)

		return nil, diags
	}

	rejectedNetworkVal, ok := rejectedNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejected_network expected to be basetypes.StringValue, was: %T`, rejectedNetworkAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return nil, diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return nil, diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return nil, diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnkonwnClient: bypassAuthWhenServerDownForUnkonwnClientVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		RejectedNetwork:                          rejectedNetworkVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpEdge:                                  stpEdgeVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueNull() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateNull,
	}
}

func NewPortUsagesValueUnknown() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortUsagesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortUsagesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, a missing attribute value was detected. "+
					"A PortUsagesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortUsagesValue Attribute Type",
				"While creating a PortUsagesValue value, an invalid attribute value was detected. "+
					"A PortUsagesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, an extra attribute value was detected. "+
					"A PortUsagesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortUsagesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnkonwnClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unkonwn_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unkonwn_client is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownForUnkonwnClientVal, ok := bypassAuthWhenServerDownForUnkonwnClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unkonwn_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnkonwnClientAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.Int64Value, was: %T`, reauthIntervalAttribute))
	}

	rejectedNetworkAttribute, ok := attributes["rejected_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejected_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	rejectedNetworkVal, ok := rejectedNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejected_network expected to be basetypes.StringValue, was: %T`, rejectedNetworkAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnkonwnClient: bypassAuthWhenServerDownForUnkonwnClientVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		RejectedNetwork:                          rejectedNetworkVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpEdge:                                  stpEdgeVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortUsagesValue {
	object, diags := NewPortUsagesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortUsagesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortUsagesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortUsagesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortUsagesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortUsagesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortUsagesValueMust(PortUsagesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortUsagesType) ValueType(ctx context.Context) attr.Value {
	return PortUsagesValue{}
}

var _ basetypes.ObjectValuable = PortUsagesValue{}

type PortUsagesValue struct {
	AllNetworks                              basetypes.BoolValue   `tfsdk:"all_networks"`
	AllowDhcpd                               basetypes.BoolValue   `tfsdk:"allow_dhcpd"`
	AllowMultipleSupplicants                 basetypes.BoolValue   `tfsdk:"allow_multiple_supplicants"`
	BypassAuthWhenServerDown                 basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down"`
	BypassAuthWhenServerDownForUnkonwnClient basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down_for_unkonwn_client"`
	Description                              basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg                           basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Disabled                                 basetypes.BoolValue   `tfsdk:"disabled"`
	Duplex                                   basetypes.StringValue `tfsdk:"duplex"`
	DynamicVlanNetworks                      basetypes.ListValue   `tfsdk:"dynamic_vlan_networks"`
	EnableMacAuth                            basetypes.BoolValue   `tfsdk:"enable_mac_auth"`
	EnableQos                                basetypes.BoolValue   `tfsdk:"enable_qos"`
	GuestNetwork                             basetypes.StringValue `tfsdk:"guest_network"`
	MacAuthOnly                              basetypes.BoolValue   `tfsdk:"mac_auth_only"`
	MacAuthProtocol                          basetypes.StringValue `tfsdk:"mac_auth_protocol"`
	MacLimit                                 basetypes.Int64Value  `tfsdk:"mac_limit"`
	Mode                                     basetypes.StringValue `tfsdk:"mode"`
	Mtu                                      basetypes.Int64Value  `tfsdk:"mtu"`
	Networks                                 basetypes.ListValue   `tfsdk:"networks"`
	PersistMac                               basetypes.BoolValue   `tfsdk:"persist_mac"`
	PoeDisabled                              basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PortAuth                                 basetypes.StringValue `tfsdk:"port_auth"`
	PortNetwork                              basetypes.StringValue `tfsdk:"port_network"`
	ReauthInterval                           basetypes.Int64Value  `tfsdk:"reauth_interval"`
	RejectedNetwork                          basetypes.StringValue `tfsdk:"rejected_network"`
	Speed                                    basetypes.StringValue `tfsdk:"speed"`
	StormControl                             basetypes.ObjectValue `tfsdk:"storm_control"`
	StpEdge                                  basetypes.BoolValue   `tfsdk:"stp_edge"`
	VoipNetwork                              basetypes.StringValue `tfsdk:"voip_network"`
	state                                    attr.ValueState
}

func (v PortUsagesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 29)

	var val tftypes.Value
	var err error

	attrTypes["all_networks"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_dhcpd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_multiple_supplicants"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down_for_unkonwn_client"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_vlan_networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enable_mac_auth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_qos"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["guest_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_auth_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["persist_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reauth_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rejected_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storm_control"] = basetypes.ObjectType{
		AttrTypes: StormControlValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["stp_edge"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["voip_network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 29)

		val, err = v.AllNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["all_networks"] = val

		val, err = v.AllowDhcpd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_dhcpd"] = val

		val, err = v.AllowMultipleSupplicants.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_multiple_supplicants"] = val

		val, err = v.BypassAuthWhenServerDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down"] = val

		val, err = v.BypassAuthWhenServerDownForUnkonwnClient.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down_for_unkonwn_client"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.DynamicVlanNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_vlan_networks"] = val

		val, err = v.EnableMacAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_mac_auth"] = val

		val, err = v.EnableQos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_qos"] = val

		val, err = v.GuestNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["guest_network"] = val

		val, err = v.MacAuthOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_only"] = val

		val, err = v.MacAuthProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_protocol"] = val

		val, err = v.MacLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_limit"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.PersistMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["persist_mac"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PortAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_auth"] = val

		val, err = v.PortNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_network"] = val

		val, err = v.ReauthInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reauth_interval"] = val

		val, err = v.RejectedNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rejected_network"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.StormControl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storm_control"] = val

		val, err = v.StpEdge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_edge"] = val

		val, err = v.VoipNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["voip_network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortUsagesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortUsagesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortUsagesValue) String() string {
	return "PortUsagesValue"
}

func (v PortUsagesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var stormControl basetypes.ObjectValue

	if v.StormControl.IsNull() {
		stormControl = types.ObjectNull(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if v.StormControl.IsUnknown() {
		stormControl = types.ObjectUnknown(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StormControl.IsNull() && !v.StormControl.IsUnknown() {
		stormControl = types.ObjectValueMust(
			StormControlValue{}.AttributeTypes(ctx),
			v.StormControl.Attributes(),
		)
	}

	dynamicVlanNetworksVal, d := types.ListValue(types.StringType, v.DynamicVlanNetworks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":   basetypes.BoolType{},
			"enable_qos":        basetypes.BoolType{},
			"guest_network":     basetypes.StringType{},
			"mac_auth_only":     basetypes.BoolType{},
			"mac_auth_protocol": basetypes.StringType{},
			"mac_limit":         basetypes.Int64Type{},
			"mode":              basetypes.StringType{},
			"mtu":               basetypes.Int64Type{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":      basetypes.BoolType{},
			"poe_disabled":     basetypes.BoolType{},
			"port_auth":        basetypes.StringType{},
			"port_network":     basetypes.StringType{},
			"reauth_interval":  basetypes.Int64Type{},
			"rejected_network": basetypes.StringType{},
			"speed":            basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_edge":     basetypes.BoolType{},
			"voip_network": basetypes.StringType{},
		}), diags
	}

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":   basetypes.BoolType{},
			"enable_qos":        basetypes.BoolType{},
			"guest_network":     basetypes.StringType{},
			"mac_auth_only":     basetypes.BoolType{},
			"mac_auth_protocol": basetypes.StringType{},
			"mac_limit":         basetypes.Int64Type{},
			"mode":              basetypes.StringType{},
			"mtu":               basetypes.Int64Type{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":      basetypes.BoolType{},
			"poe_disabled":     basetypes.BoolType{},
			"port_auth":        basetypes.StringType{},
			"port_network":     basetypes.StringType{},
			"reauth_interval":  basetypes.Int64Type{},
			"rejected_network": basetypes.StringType{},
			"speed":            basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_edge":     basetypes.BoolType{},
			"voip_network": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":   basetypes.BoolType{},
		"enable_qos":        basetypes.BoolType{},
		"guest_network":     basetypes.StringType{},
		"mac_auth_only":     basetypes.BoolType{},
		"mac_auth_protocol": basetypes.StringType{},
		"mac_limit":         basetypes.Int64Type{},
		"mode":              basetypes.StringType{},
		"mtu":               basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":      basetypes.BoolType{},
		"poe_disabled":     basetypes.BoolType{},
		"port_auth":        basetypes.StringType{},
		"port_network":     basetypes.StringType{},
		"reauth_interval":  basetypes.Int64Type{},
		"rejected_network": basetypes.StringType{},
		"speed":            basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_edge":     basetypes.BoolType{},
		"voip_network": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"all_networks":                                    v.AllNetworks,
			"allow_dhcpd":                                     v.AllowDhcpd,
			"allow_multiple_supplicants":                      v.AllowMultipleSupplicants,
			"bypass_auth_when_server_down":                    v.BypassAuthWhenServerDown,
			"bypass_auth_when_server_down_for_unkonwn_client": v.BypassAuthWhenServerDownForUnkonwnClient,
			"description":                                     v.Description,
			"disable_autoneg":                                 v.DisableAutoneg,
			"disabled":                                        v.Disabled,
			"duplex":                                          v.Duplex,
			"dynamic_vlan_networks":                           dynamicVlanNetworksVal,
			"enable_mac_auth":                                 v.EnableMacAuth,
			"enable_qos":                                      v.EnableQos,
			"guest_network":                                   v.GuestNetwork,
			"mac_auth_only":                                   v.MacAuthOnly,
			"mac_auth_protocol":                               v.MacAuthProtocol,
			"mac_limit":                                       v.MacLimit,
			"mode":                                            v.Mode,
			"mtu":                                             v.Mtu,
			"networks":                                        networksVal,
			"persist_mac":                                     v.PersistMac,
			"poe_disabled":                                    v.PoeDisabled,
			"port_auth":                                       v.PortAuth,
			"port_network":                                    v.PortNetwork,
			"reauth_interval":                                 v.ReauthInterval,
			"rejected_network":                                v.RejectedNetwork,
			"speed":                                           v.Speed,
			"storm_control":                                   stormControl,
			"stp_edge":                                        v.StpEdge,
			"voip_network":                                    v.VoipNetwork,
		})

	return objVal, diags
}

func (v PortUsagesValue) Equal(o attr.Value) bool {
	other, ok := o.(PortUsagesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllNetworks.Equal(other.AllNetworks) {
		return false
	}

	if !v.AllowDhcpd.Equal(other.AllowDhcpd) {
		return false
	}

	if !v.AllowMultipleSupplicants.Equal(other.AllowMultipleSupplicants) {
		return false
	}

	if !v.BypassAuthWhenServerDown.Equal(other.BypassAuthWhenServerDown) {
		return false
	}

	if !v.BypassAuthWhenServerDownForUnkonwnClient.Equal(other.BypassAuthWhenServerDownForUnkonwnClient) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.DynamicVlanNetworks.Equal(other.DynamicVlanNetworks) {
		return false
	}

	if !v.EnableMacAuth.Equal(other.EnableMacAuth) {
		return false
	}

	if !v.EnableQos.Equal(other.EnableQos) {
		return false
	}

	if !v.GuestNetwork.Equal(other.GuestNetwork) {
		return false
	}

	if !v.MacAuthOnly.Equal(other.MacAuthOnly) {
		return false
	}

	if !v.MacAuthProtocol.Equal(other.MacAuthProtocol) {
		return false
	}

	if !v.MacLimit.Equal(other.MacLimit) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.PersistMac.Equal(other.PersistMac) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PortAuth.Equal(other.PortAuth) {
		return false
	}

	if !v.PortNetwork.Equal(other.PortNetwork) {
		return false
	}

	if !v.ReauthInterval.Equal(other.ReauthInterval) {
		return false
	}

	if !v.RejectedNetwork.Equal(other.RejectedNetwork) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.StormControl.Equal(other.StormControl) {
		return false
	}

	if !v.StpEdge.Equal(other.StpEdge) {
		return false
	}

	if !v.VoipNetwork.Equal(other.VoipNetwork) {
		return false
	}

	return true
}

func (v PortUsagesValue) Type(ctx context.Context) attr.Type {
	return PortUsagesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortUsagesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":   basetypes.BoolType{},
		"enable_qos":        basetypes.BoolType{},
		"guest_network":     basetypes.StringType{},
		"mac_auth_only":     basetypes.BoolType{},
		"mac_auth_protocol": basetypes.StringType{},
		"mac_limit":         basetypes.Int64Type{},
		"mode":              basetypes.StringType{},
		"mtu":               basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":      basetypes.BoolType{},
		"poe_disabled":     basetypes.BoolType{},
		"port_auth":        basetypes.StringType{},
		"port_network":     basetypes.StringType{},
		"reauth_interval":  basetypes.Int64Type{},
		"rejected_network": basetypes.StringType{},
		"speed":            basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_edge":     basetypes.BoolType{},
		"voip_network": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StormControlType{}

type StormControlType struct {
	basetypes.ObjectType
}

func (t StormControlType) Equal(o attr.Type) bool {
	other, ok := o.(StormControlType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StormControlType) String() string {
	return "StormControlType"
}

func (t StormControlType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return nil, diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return nil, diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return nil, diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return nil, diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return nil, diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StormControlValue{
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueNull() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateNull,
	}
}

func NewStormControlValueUnknown() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStormControlValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StormControlValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StormControlValue Attribute Value",
				"While creating a StormControlValue value, a missing attribute value was detected. "+
					"A StormControlValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StormControlValue Attribute Type",
				"While creating a StormControlValue value, an invalid attribute value was detected. "+
					"A StormControlValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StormControlValue Attribute Value",
				"While creating a StormControlValue value, an extra attribute value was detected. "+
					"A StormControlValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StormControlValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	return StormControlValue{
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StormControlValue {
	object, diags := NewStormControlValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStormControlValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StormControlType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStormControlValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStormControlValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStormControlValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStormControlValueMust(StormControlValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StormControlType) ValueType(ctx context.Context) attr.Value {
	return StormControlValue{}
}

var _ basetypes.ObjectValuable = StormControlValue{}

type StormControlValue struct {
	NoBroadcast           basetypes.BoolValue  `tfsdk:"no_broadcast"`
	NoMulticast           basetypes.BoolValue  `tfsdk:"no_multicast"`
	NoRegisteredMulticast basetypes.BoolValue  `tfsdk:"no_registered_multicast"`
	NoUnknownUnicast      basetypes.BoolValue  `tfsdk:"no_unknown_unicast"`
	Percentage            basetypes.Int64Value `tfsdk:"percentage"`
	state                 attr.ValueState
}

func (v StormControlValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["no_broadcast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_registered_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_unknown_unicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["percentage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.NoBroadcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_broadcast"] = val

		val, err = v.NoMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_multicast"] = val

		val, err = v.NoRegisteredMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_registered_multicast"] = val

		val, err = v.NoUnknownUnicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_unknown_unicast"] = val

		val, err = v.Percentage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["percentage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StormControlValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StormControlValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StormControlValue) String() string {
	return "StormControlValue"
}

func (v StormControlValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"no_broadcast":            v.NoBroadcast,
			"no_multicast":            v.NoMulticast,
			"no_registered_multicast": v.NoRegisteredMulticast,
			"no_unknown_unicast":      v.NoUnknownUnicast,
			"percentage":              v.Percentage,
		})

	return objVal, diags
}

func (v StormControlValue) Equal(o attr.Value) bool {
	other, ok := o.(StormControlValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NoBroadcast.Equal(other.NoBroadcast) {
		return false
	}

	if !v.NoMulticast.Equal(other.NoMulticast) {
		return false
	}

	if !v.NoRegisteredMulticast.Equal(other.NoRegisteredMulticast) {
		return false
	}

	if !v.NoUnknownUnicast.Equal(other.NoUnknownUnicast) {
		return false
	}

	if !v.Percentage.Equal(other.Percentage) {
		return false
	}

	return true
}

func (v StormControlValue) Type(ctx context.Context) attr.Type {
	return StormControlType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StormControlValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RadiusConfigType{}

type RadiusConfigType struct {
	basetypes.ObjectType
}

func (t RadiusConfigType) Equal(o attr.Type) bool {
	other, ok := o.(RadiusConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadiusConfigType) String() string {
	return "RadiusConfigType"
}

func (t RadiusConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return nil, diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return nil, diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return nil, diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return nil, diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return nil, diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return nil, diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return nil, diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueNull() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewRadiusConfigValueUnknown() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadiusConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadiusConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, a missing attribute value was detected. "+
					"A RadiusConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadiusConfigValue Attribute Type",
				"While creating a RadiusConfigValue value, an invalid attribute value was detected. "+
					"A RadiusConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, an extra attribute value was detected. "+
					"A RadiusConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadiusConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadiusConfigValue {
	object, diags := NewRadiusConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadiusConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadiusConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadiusConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadiusConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadiusConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadiusConfigValueMust(RadiusConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadiusConfigType) ValueType(ctx context.Context) attr.Value {
	return RadiusConfigValue{}
}

var _ basetypes.ObjectValuable = RadiusConfigValue{}

type RadiusConfigValue struct {
	AcctInterimInterval basetypes.Int64Value  `tfsdk:"acct_interim_interval"`
	AcctServers         basetypes.ListValue   `tfsdk:"acct_servers"`
	AuthServers         basetypes.ListValue   `tfsdk:"auth_servers"`
	AuthServersRetries  basetypes.Int64Value  `tfsdk:"auth_servers_retries"`
	AuthServersTimeout  basetypes.Int64Value  `tfsdk:"auth_servers_timeout"`
	CoaEnabled          basetypes.BoolValue   `tfsdk:"coa_enabled"`
	CoaPort             basetypes.Int64Value  `tfsdk:"coa_port"`
	Network             basetypes.StringValue `tfsdk:"network"`
	SourceIp            basetypes.StringValue `tfsdk:"source_ip"`
	state               attr.ValueState
}

func (v RadiusConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["acct_interim_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: AcctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers"] = basetypes.ListType{
		ElemType: AuthServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth_servers_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["coa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["coa_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AcctInterimInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_interim_interval"] = val

		val, err = v.AcctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.AuthServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers"] = val

		val, err = v.AuthServersRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_retries"] = val

		val, err = v.AuthServersTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_timeout"] = val

		val, err = v.CoaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_enabled"] = val

		val, err = v.CoaPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_port"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.SourceIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadiusConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadiusConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadiusConfigValue) String() string {
	return "RadiusConfigValue"
}

func (v RadiusConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acctServers := types.ListValueMust(
		AcctServersType{
			basetypes.ObjectType{
				AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AcctServers.Elements(),
	)

	if v.AcctServers.IsNull() {
		acctServers = types.ListNull(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AcctServers.IsUnknown() {
		acctServers = types.ListUnknown(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	authServers := types.ListValueMust(
		AuthServersType{
			basetypes.ObjectType{
				AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AuthServers.Elements(),
	)

	if v.AuthServers.IsNull() {
		authServers = types.ListNull(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AuthServers.IsUnknown() {
		authServers = types.ListUnknown(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acct_interim_interval": v.AcctInterimInterval,
			"acct_servers":          acctServers,
			"auth_servers":          authServers,
			"auth_servers_retries":  v.AuthServersRetries,
			"auth_servers_timeout":  v.AuthServersTimeout,
			"coa_enabled":           v.CoaEnabled,
			"coa_port":              v.CoaPort,
			"network":               v.Network,
			"source_ip":             v.SourceIp,
		})

	return objVal, diags
}

func (v RadiusConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(RadiusConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AcctInterimInterval.Equal(other.AcctInterimInterval) {
		return false
	}

	if !v.AcctServers.Equal(other.AcctServers) {
		return false
	}

	if !v.AuthServers.Equal(other.AuthServers) {
		return false
	}

	if !v.AuthServersRetries.Equal(other.AuthServersRetries) {
		return false
	}

	if !v.AuthServersTimeout.Equal(other.AuthServersTimeout) {
		return false
	}

	if !v.CoaEnabled.Equal(other.CoaEnabled) {
		return false
	}

	if !v.CoaPort.Equal(other.CoaPort) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.SourceIp.Equal(other.SourceIp) {
		return false
	}

	return true
}

func (v RadiusConfigValue) Type(ctx context.Context) attr.Type {
	return RadiusConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadiusConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AcctServersType{}

type AcctServersType struct {
	basetypes.ObjectType
}

func (t AcctServersType) Equal(o attr.Type) bool {
	other, ok := o.(AcctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AcctServersType) String() string {
	return "AcctServersType"
}

func (t AcctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueNull() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAcctServersValueUnknown() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAcctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AcctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, a missing attribute value was detected. "+
					"A AcctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AcctServersValue Attribute Type",
				"While creating a AcctServersValue value, an invalid attribute value was detected. "+
					"A AcctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, an extra attribute value was detected. "+
					"A AcctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AcctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AcctServersValue {
	object, diags := NewAcctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAcctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AcctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAcctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAcctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAcctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAcctServersValueMust(AcctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AcctServersType) ValueType(ctx context.Context) attr.Value {
	return AcctServersValue{}
}

var _ basetypes.ObjectValuable = AcctServersValue{}

type AcctServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AcctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AcctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AcctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AcctServersValue) String() string {
	return "AcctServersValue"
}

func (v AcctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AcctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AcctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AcctServersValue) Type(ctx context.Context) attr.Type {
	return AcctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AcctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthServersType{}

type AuthServersType struct {
	basetypes.ObjectType
}

func (t AuthServersType) Equal(o attr.Type) bool {
	other, ok := o.(AuthServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthServersType) String() string {
	return "AuthServersType"
}

func (t AuthServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueNull() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthServersValueUnknown() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, a missing attribute value was detected. "+
					"A AuthServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthServersValue Attribute Type",
				"While creating a AuthServersValue value, an invalid attribute value was detected. "+
					"A AuthServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, an extra attribute value was detected. "+
					"A AuthServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthServersValue {
	object, diags := NewAuthServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthServersValueMust(AuthServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthServersType) ValueType(ctx context.Context) attr.Value {
	return AuthServersValue{}
}

var _ basetypes.ObjectValuable = AuthServersValue{}

type AuthServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AuthServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthServersValue) String() string {
	return "AuthServersValue"
}

func (v AuthServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AuthServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AuthServersValue) Type(ctx context.Context) attr.Type {
	return AuthServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteSyslogType{}

type RemoteSyslogType struct {
	basetypes.ObjectType
}

func (t RemoteSyslogType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteSyslogType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteSyslogType) String() string {
	return "RemoteSyslogType"
}

func (t RemoteSyslogType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	consoleAttribute, ok := attributes["console"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console is missing from object`)

		return nil, diags
	}

	consoleVal, ok := consoleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console expected to be basetypes.ObjectValue, was: %T`, consoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return nil, diags
	}

	filesVal, ok := filesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.ListValue, was: %T`, filesAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sendToAllServersAttribute, ok := attributes["send_to_all_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_to_all_servers is missing from object`)

		return nil, diags
	}

	sendToAllServersVal, ok := sendToAllServersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_to_all_servers expected to be basetypes.BoolValue, was: %T`, sendToAllServersAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	timeFormatAttribute, ok := attributes["time_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_format is missing from object`)

		return nil, diags
	}

	timeFormatVal, ok := timeFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_format expected to be basetypes.StringValue, was: %T`, timeFormatAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return nil, diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteSyslogValue{
		Archive:          archiveVal,
		Console:          consoleVal,
		Enabled:          enabledVal,
		Files:            filesVal,
		Network:          networkVal,
		SendToAllServers: sendToAllServersVal,
		Servers:          serversVal,
		TimeFormat:       timeFormatVal,
		Users:            usersVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteSyslogValueNull() RemoteSyslogValue {
	return RemoteSyslogValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteSyslogValueUnknown() RemoteSyslogValue {
	return RemoteSyslogValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteSyslogValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteSyslogValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteSyslogValue Attribute Value",
				"While creating a RemoteSyslogValue value, a missing attribute value was detected. "+
					"A RemoteSyslogValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteSyslogValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteSyslogValue Attribute Type",
				"While creating a RemoteSyslogValue value, an invalid attribute value was detected. "+
					"A RemoteSyslogValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteSyslogValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteSyslogValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteSyslogValue Attribute Value",
				"While creating a RemoteSyslogValue value, an extra attribute value was detected. "+
					"A RemoteSyslogValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteSyslogValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteSyslogValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	consoleAttribute, ok := attributes["console"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	consoleVal, ok := consoleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console expected to be basetypes.ObjectValue, was: %T`, consoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	filesVal, ok := filesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.ListValue, was: %T`, filesAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sendToAllServersAttribute, ok := attributes["send_to_all_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_to_all_servers is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	sendToAllServersVal, ok := sendToAllServersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_to_all_servers expected to be basetypes.BoolValue, was: %T`, sendToAllServersAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	timeFormatAttribute, ok := attributes["time_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_format is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	timeFormatVal, ok := timeFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_format expected to be basetypes.StringValue, was: %T`, timeFormatAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	if diags.HasError() {
		return NewRemoteSyslogValueUnknown(), diags
	}

	return RemoteSyslogValue{
		Archive:          archiveVal,
		Console:          consoleVal,
		Enabled:          enabledVal,
		Files:            filesVal,
		Network:          networkVal,
		SendToAllServers: sendToAllServersVal,
		Servers:          serversVal,
		TimeFormat:       timeFormatVal,
		Users:            usersVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteSyslogValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteSyslogValue {
	object, diags := NewRemoteSyslogValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteSyslogValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteSyslogType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteSyslogValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteSyslogValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteSyslogValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteSyslogValueMust(RemoteSyslogValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteSyslogType) ValueType(ctx context.Context) attr.Value {
	return RemoteSyslogValue{}
}

var _ basetypes.ObjectValuable = RemoteSyslogValue{}

type RemoteSyslogValue struct {
	Archive          basetypes.ObjectValue `tfsdk:"archive"`
	Console          basetypes.ObjectValue `tfsdk:"console"`
	Enabled          basetypes.BoolValue   `tfsdk:"enabled"`
	Files            basetypes.ListValue   `tfsdk:"files"`
	Network          basetypes.StringValue `tfsdk:"network"`
	SendToAllServers basetypes.BoolValue   `tfsdk:"send_to_all_servers"`
	Servers          basetypes.ListValue   `tfsdk:"servers"`
	TimeFormat       basetypes.StringValue `tfsdk:"time_format"`
	Users            basetypes.ListValue   `tfsdk:"users"`
	state            attr.ValueState
}

func (v RemoteSyslogValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.ObjectType{
		AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["console"] = basetypes.ObjectType{
		AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["files"] = basetypes.ListType{
		ElemType: FilesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["send_to_all_servers"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: ServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["time_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["users"] = basetypes.ListType{
		ElemType: UsersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Console.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["console"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Files.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["files"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.SendToAllServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_to_all_servers"] = val

		val, err = v.Servers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.TimeFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["time_format"] = val

		val, err = v.Users.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["users"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteSyslogValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteSyslogValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteSyslogValue) String() string {
	return "RemoteSyslogValue"
}

func (v RemoteSyslogValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var archive basetypes.ObjectValue

	if v.Archive.IsNull() {
		archive = types.ObjectNull(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if v.Archive.IsUnknown() {
		archive = types.ObjectUnknown(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		archive = types.ObjectValueMust(
			ArchiveValue{}.AttributeTypes(ctx),
			v.Archive.Attributes(),
		)
	}

	var console basetypes.ObjectValue

	if v.Console.IsNull() {
		console = types.ObjectNull(
			ConsoleValue{}.AttributeTypes(ctx),
		)
	}

	if v.Console.IsUnknown() {
		console = types.ObjectUnknown(
			ConsoleValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Console.IsNull() && !v.Console.IsUnknown() {
		console = types.ObjectValueMust(
			ConsoleValue{}.AttributeTypes(ctx),
			v.Console.Attributes(),
		)
	}

	files := types.ListValueMust(
		FilesType{
			basetypes.ObjectType{
				AttrTypes: FilesValue{}.AttributeTypes(ctx),
			},
		},
		v.Files.Elements(),
	)

	if v.Files.IsNull() {
		files = types.ListNull(
			FilesType{
				basetypes.ObjectType{
					AttrTypes: FilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Files.IsUnknown() {
		files = types.ListUnknown(
			FilesType{
				basetypes.ObjectType{
					AttrTypes: FilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	servers := types.ListValueMust(
		ServersType{
			basetypes.ObjectType{
				AttrTypes: ServersValue{}.AttributeTypes(ctx),
			},
		},
		v.Servers.Elements(),
	)

	if v.Servers.IsNull() {
		servers = types.ListNull(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Servers.IsUnknown() {
		servers = types.ListUnknown(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	users := types.ListValueMust(
		UsersType{
			basetypes.ObjectType{
				AttrTypes: UsersValue{}.AttributeTypes(ctx),
			},
		},
		v.Users.Elements(),
	)

	if v.Users.IsNull() {
		users = types.ListNull(
			UsersType{
				basetypes.ObjectType{
					AttrTypes: UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Users.IsUnknown() {
		users = types.ListUnknown(
			UsersType{
				basetypes.ObjectType{
					AttrTypes: UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"console": basetypes.ObjectType{
			AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"files": basetypes.ListType{
			ElemType: FilesValue{}.Type(ctx),
		},
		"network":             basetypes.StringType{},
		"send_to_all_servers": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"time_format": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: UsersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"archive":             archive,
			"console":             console,
			"enabled":             v.Enabled,
			"files":               files,
			"network":             v.Network,
			"send_to_all_servers": v.SendToAllServers,
			"servers":             servers,
			"time_format":         v.TimeFormat,
			"users":               users,
		})

	return objVal, diags
}

func (v RemoteSyslogValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteSyslogValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Console.Equal(other.Console) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Files.Equal(other.Files) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.SendToAllServers.Equal(other.SendToAllServers) {
		return false
	}

	if !v.Servers.Equal(other.Servers) {
		return false
	}

	if !v.TimeFormat.Equal(other.TimeFormat) {
		return false
	}

	if !v.Users.Equal(other.Users) {
		return false
	}

	return true
}

func (v RemoteSyslogValue) Type(ctx context.Context) attr.Type {
	return RemoteSyslogType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteSyslogValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"console": basetypes.ObjectType{
			AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"files": basetypes.ListType{
			ElemType: FilesValue{}.Type(ctx),
		},
		"network":             basetypes.StringType{},
		"send_to_all_servers": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"time_format": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: UsersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ArchiveType{}

type ArchiveType struct {
	basetypes.ObjectType
}

func (t ArchiveType) Equal(o attr.Type) bool {
	other, ok := o.(ArchiveType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ArchiveType) String() string {
	return "ArchiveType"
}

func (t ArchiveType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return nil, diags
	}

	filesVal, ok := filesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.Int64Value, was: %T`, filesAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.StringValue, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ArchiveValue{
		Files: filesVal,
		Size:  sizeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewArchiveValueNull() ArchiveValue {
	return ArchiveValue{
		state: attr.ValueStateNull,
	}
}

func NewArchiveValueUnknown() ArchiveValue {
	return ArchiveValue{
		state: attr.ValueStateUnknown,
	}
}

func NewArchiveValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ArchiveValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ArchiveValue Attribute Value",
				"While creating a ArchiveValue value, a missing attribute value was detected. "+
					"A ArchiveValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArchiveValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ArchiveValue Attribute Type",
				"While creating a ArchiveValue value, an invalid attribute value was detected. "+
					"A ArchiveValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArchiveValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ArchiveValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ArchiveValue Attribute Value",
				"While creating a ArchiveValue value, an extra attribute value was detected. "+
					"A ArchiveValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ArchiveValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewArchiveValueUnknown(), diags
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return NewArchiveValueUnknown(), diags
	}

	filesVal, ok := filesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.Int64Value, was: %T`, filesAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewArchiveValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.StringValue, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return NewArchiveValueUnknown(), diags
	}

	return ArchiveValue{
		Files: filesVal,
		Size:  sizeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewArchiveValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ArchiveValue {
	object, diags := NewArchiveValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewArchiveValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ArchiveType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewArchiveValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewArchiveValueUnknown(), nil
	}

	if in.IsNull() {
		return NewArchiveValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewArchiveValueMust(ArchiveValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ArchiveType) ValueType(ctx context.Context) attr.Value {
	return ArchiveValue{}
}

var _ basetypes.ObjectValuable = ArchiveValue{}

type ArchiveValue struct {
	Files basetypes.Int64Value  `tfsdk:"files"`
	Size  basetypes.StringValue `tfsdk:"size"`
	state attr.ValueState
}

func (v ArchiveValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["files"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Files.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["files"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ArchiveValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ArchiveValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ArchiveValue) String() string {
	return "ArchiveValue"
}

func (v ArchiveValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"files": basetypes.Int64Type{},
		"size":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"files": v.Files,
			"size":  v.Size,
		})

	return objVal, diags
}

func (v ArchiveValue) Equal(o attr.Value) bool {
	other, ok := o.(ArchiveValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Files.Equal(other.Files) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	return true
}

func (v ArchiveValue) Type(ctx context.Context) attr.Type {
	return ArchiveType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ArchiveValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"files": basetypes.Int64Type{},
		"size":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConsoleType{}

type ConsoleType struct {
	basetypes.ObjectType
}

func (t ConsoleType) Equal(o attr.Type) bool {
	other, ok := o.(ConsoleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConsoleType) String() string {
	return "ConsoleType"
}

func (t ConsoleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConsoleValue{
		Contents: contentsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConsoleValueNull() ConsoleValue {
	return ConsoleValue{
		state: attr.ValueStateNull,
	}
}

func NewConsoleValueUnknown() ConsoleValue {
	return ConsoleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConsoleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConsoleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConsoleValue Attribute Value",
				"While creating a ConsoleValue value, a missing attribute value was detected. "+
					"A ConsoleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConsoleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConsoleValue Attribute Type",
				"While creating a ConsoleValue value, an invalid attribute value was detected. "+
					"A ConsoleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConsoleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConsoleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConsoleValue Attribute Value",
				"While creating a ConsoleValue value, an extra attribute value was detected. "+
					"A ConsoleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConsoleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConsoleValueUnknown(), diags
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewConsoleValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	if diags.HasError() {
		return NewConsoleValueUnknown(), diags
	}

	return ConsoleValue{
		Contents: contentsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConsoleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConsoleValue {
	object, diags := NewConsoleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConsoleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConsoleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConsoleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConsoleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConsoleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConsoleValueMust(ConsoleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConsoleType) ValueType(ctx context.Context) attr.Value {
	return ConsoleValue{}
}

var _ basetypes.ObjectValuable = ConsoleValue{}

type ConsoleValue struct {
	Contents basetypes.ListValue `tfsdk:"contents"`
	state    attr.ValueState
}

func (v ConsoleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConsoleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConsoleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConsoleValue) String() string {
	return "ConsoleValue"
}

func (v ConsoleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"contents": contents,
		})

	return objVal, diags
}

func (v ConsoleValue) Equal(o attr.Value) bool {
	other, ok := o.(ConsoleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	return true
}

func (v ConsoleValue) Type(ctx context.Context) attr.Type {
	return ConsoleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConsoleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ContentsType{}

type ContentsType struct {
	basetypes.ObjectType
}

func (t ContentsType) Equal(o attr.Type) bool {
	other, ok := o.(ContentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ContentsType) String() string {
	return "ContentsType"
}

func (t ContentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return nil, diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return nil, diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ContentsValue{
		Facility: facilityVal,
		Severity: severityVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewContentsValueNull() ContentsValue {
	return ContentsValue{
		state: attr.ValueStateNull,
	}
}

func NewContentsValueUnknown() ContentsValue {
	return ContentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewContentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ContentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ContentsValue Attribute Value",
				"While creating a ContentsValue value, a missing attribute value was detected. "+
					"A ContentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ContentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ContentsValue Attribute Type",
				"While creating a ContentsValue value, an invalid attribute value was detected. "+
					"A ContentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ContentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ContentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ContentsValue Attribute Value",
				"While creating a ContentsValue value, an extra attribute value was detected. "+
					"A ContentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ContentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewContentsValueUnknown(), diags
	}

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return NewContentsValueUnknown(), diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return NewContentsValueUnknown(), diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return NewContentsValueUnknown(), diags
	}

	return ContentsValue{
		Facility: facilityVal,
		Severity: severityVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewContentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ContentsValue {
	object, diags := NewContentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewContentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ContentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewContentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewContentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewContentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewContentsValueMust(ContentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ContentsType) ValueType(ctx context.Context) attr.Value {
	return ContentsValue{}
}

var _ basetypes.ObjectValuable = ContentsValue{}

type ContentsValue struct {
	Facility basetypes.StringValue `tfsdk:"facility"`
	Severity basetypes.StringValue `tfsdk:"severity"`
	state    attr.ValueState
}

func (v ContentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["facility"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["severity"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Facility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facility"] = val

		val, err = v.Severity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["severity"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ContentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ContentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ContentsValue) String() string {
	return "ContentsValue"
}

func (v ContentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"facility": basetypes.StringType{},
		"severity": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"facility": v.Facility,
			"severity": v.Severity,
		})

	return objVal, diags
}

func (v ContentsValue) Equal(o attr.Value) bool {
	other, ok := o.(ContentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Facility.Equal(other.Facility) {
		return false
	}

	if !v.Severity.Equal(other.Severity) {
		return false
	}

	return true
}

func (v ContentsValue) Type(ctx context.Context) attr.Type {
	return ContentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ContentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"facility": basetypes.StringType{},
		"severity": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FilesType{}

type FilesType struct {
	basetypes.ObjectType
}

func (t FilesType) Equal(o attr.Type) bool {
	other, ok := o.(FilesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FilesType) String() string {
	return "FilesType"
}

func (t FilesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return nil, diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return nil, diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return nil, diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FilesValue{
		Archive:          archiveVal,
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		File:             fileVal,
		Match:            matchVal,
		StructuredData:   structuredDataVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFilesValueNull() FilesValue {
	return FilesValue{
		state: attr.ValueStateNull,
	}
}

func NewFilesValueUnknown() FilesValue {
	return FilesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFilesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FilesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FilesValue Attribute Value",
				"While creating a FilesValue value, a missing attribute value was detected. "+
					"A FilesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FilesValue Attribute Type",
				"While creating a FilesValue value, an invalid attribute value was detected. "+
					"A FilesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FilesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FilesValue Attribute Value",
				"While creating a FilesValue value, an extra attribute value was detected. "+
					"A FilesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FilesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	return FilesValue{
		Archive:          archiveVal,
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		File:             fileVal,
		Match:            matchVal,
		StructuredData:   structuredDataVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFilesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FilesValue {
	object, diags := NewFilesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFilesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FilesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFilesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFilesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFilesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFilesValueMust(FilesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FilesType) ValueType(ctx context.Context) attr.Value {
	return FilesValue{}
}

var _ basetypes.ObjectValuable = FilesValue{}

type FilesValue struct {
	Archive          basetypes.ObjectValue `tfsdk:"archive"`
	Contents         basetypes.ListValue   `tfsdk:"contents"`
	ExplicitPriority basetypes.BoolValue   `tfsdk:"explicit_priority"`
	File             basetypes.StringValue `tfsdk:"file"`
	Match            basetypes.StringValue `tfsdk:"match"`
	StructuredData   basetypes.BoolValue   `tfsdk:"structured_data"`
	state            attr.ValueState
}

func (v FilesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.ObjectType{
		AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["explicit_priority"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["structured_data"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		val, err = v.ExplicitPriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["explicit_priority"] = val

		val, err = v.File.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["file"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.StructuredData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["structured_data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FilesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FilesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FilesValue) String() string {
	return "FilesValue"
}

func (v FilesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var archive basetypes.ObjectValue

	if v.Archive.IsNull() {
		archive = types.ObjectNull(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if v.Archive.IsUnknown() {
		archive = types.ObjectUnknown(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		archive = types.ObjectValueMust(
			ArchiveValue{}.AttributeTypes(ctx),
			v.Archive.Attributes(),
		)
	}

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"file":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"archive":           archive,
			"contents":          contents,
			"explicit_priority": v.ExplicitPriority,
			"file":              v.File,
			"match":             v.Match,
			"structured_data":   v.StructuredData,
		})

	return objVal, diags
}

func (v FilesValue) Equal(o attr.Value) bool {
	other, ok := o.(FilesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	if !v.ExplicitPriority.Equal(other.ExplicitPriority) {
		return false
	}

	if !v.File.Equal(other.File) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.StructuredData.Equal(other.StructuredData) {
		return false
	}

	return true
}

func (v FilesValue) Type(ctx context.Context) attr.Type {
	return FilesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FilesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"file":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
	}
}







































var _ basetypes.ObjectTypable = ServersType{}

type ServersType struct {
	basetypes.ObjectType
}

func (t ServersType) Equal(o attr.Type) bool {
	other, ok := o.(ServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServersType) String() string {
	return "ServersType"
}

func (t ServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return nil, diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return nil, diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	routingInstanceAttribute, ok := attributes["routing_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_instance is missing from object`)

		return nil, diags
	}

	routingInstanceVal, ok := routingInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_instance expected to be basetypes.StringValue, was: %T`, routingInstanceAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return nil, diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	sourceAddressAttribute, ok := attributes["source_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_address is missing from object`)

		return nil, diags
	}

	sourceAddressVal, ok := sourceAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_address expected to be basetypes.StringValue, was: %T`, sourceAddressAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return nil, diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return nil, diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServersValue{
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		Facility:         facilityVal,
		Host:             hostVal,
		Match:            matchVal,
		Port:             portVal,
		Protocol:         protocolVal,
		RoutingInstance:  routingInstanceVal,
		Severity:         severityVal,
		SourceAddress:    sourceAddressVal,
		StructuredData:   structuredDataVal,
		Tag:              tagVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewServersValueNull() ServersValue {
	return ServersValue{
		state: attr.ValueStateNull,
	}
}

func NewServersValueUnknown() ServersValue {
	return ServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServersValue Attribute Value",
				"While creating a ServersValue value, a missing attribute value was detected. "+
					"A ServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServersValue Attribute Type",
				"While creating a ServersValue value, an invalid attribute value was detected. "+
					"A ServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServersValue Attribute Value",
				"While creating a ServersValue value, an extra attribute value was detected. "+
					"A ServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewServersValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return NewServersValueUnknown(), diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return NewServersValueUnknown(), diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewServersValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewServersValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	routingInstanceAttribute, ok := attributes["routing_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_instance is missing from object`)

		return NewServersValueUnknown(), diags
	}

	routingInstanceVal, ok := routingInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_instance expected to be basetypes.StringValue, was: %T`, routingInstanceAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return NewServersValueUnknown(), diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	sourceAddressAttribute, ok := attributes["source_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_address is missing from object`)

		return NewServersValueUnknown(), diags
	}

	sourceAddressVal, ok := sourceAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_address expected to be basetypes.StringValue, was: %T`, sourceAddressAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return NewServersValueUnknown(), diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return NewServersValueUnknown(), diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	return ServersValue{
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		Facility:         facilityVal,
		Host:             hostVal,
		Match:            matchVal,
		Port:             portVal,
		Protocol:         protocolVal,
		RoutingInstance:  routingInstanceVal,
		Severity:         severityVal,
		SourceAddress:    sourceAddressVal,
		StructuredData:   structuredDataVal,
		Tag:              tagVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServersValue {
	object, diags := NewServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServersValueMust(ServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServersType) ValueType(ctx context.Context) attr.Value {
	return ServersValue{}
}

var _ basetypes.ObjectValuable = ServersValue{}

type ServersValue struct {
	Contents         basetypes.ListValue   `tfsdk:"contents"`
	ExplicitPriority basetypes.BoolValue   `tfsdk:"explicit_priority"`
	Facility         basetypes.StringValue `tfsdk:"facility"`
	Host             basetypes.StringValue `tfsdk:"host"`
	Match            basetypes.StringValue `tfsdk:"match"`
	Port             basetypes.Int64Value  `tfsdk:"port"`
	Protocol         basetypes.StringValue `tfsdk:"protocol"`
	RoutingInstance  basetypes.StringValue `tfsdk:"routing_instance"`
	Severity         basetypes.StringValue `tfsdk:"severity"`
	SourceAddress    basetypes.StringValue `tfsdk:"source_address"`
	StructuredData   basetypes.BoolValue   `tfsdk:"structured_data"`
	Tag              basetypes.StringValue `tfsdk:"tag"`
	state            attr.ValueState
}

func (v ServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["explicit_priority"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["facility"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["routing_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["severity"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["structured_data"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tag"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		val, err = v.ExplicitPriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["explicit_priority"] = val

		val, err = v.Facility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facility"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.RoutingInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routing_instance"] = val

		val, err = v.Severity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["severity"] = val

		val, err = v.SourceAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_address"] = val

		val, err = v.StructuredData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["structured_data"] = val

		val, err = v.Tag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServersValue) String() string {
	return "ServersValue"
}

func (v ServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"facility":          basetypes.StringType{},
		"host":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"port":              basetypes.Int64Type{},
		"protocol":          basetypes.StringType{},
		"routing_instance":  basetypes.StringType{},
		"severity":          basetypes.StringType{},
		"source_address":    basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
		"tag":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"contents":          contents,
			"explicit_priority": v.ExplicitPriority,
			"facility":          v.Facility,
			"host":              v.Host,
			"match":             v.Match,
			"port":              v.Port,
			"protocol":          v.Protocol,
			"routing_instance":  v.RoutingInstance,
			"severity":          v.Severity,
			"source_address":    v.SourceAddress,
			"structured_data":   v.StructuredData,
			"tag":               v.Tag,
		})

	return objVal, diags
}

func (v ServersValue) Equal(o attr.Value) bool {
	other, ok := o.(ServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	if !v.ExplicitPriority.Equal(other.ExplicitPriority) {
		return false
	}

	if !v.Facility.Equal(other.Facility) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.RoutingInstance.Equal(other.RoutingInstance) {
		return false
	}

	if !v.Severity.Equal(other.Severity) {
		return false
	}

	if !v.SourceAddress.Equal(other.SourceAddress) {
		return false
	}

	if !v.StructuredData.Equal(other.StructuredData) {
		return false
	}

	if !v.Tag.Equal(other.Tag) {
		return false
	}

	return true
}

func (v ServersValue) Type(ctx context.Context) attr.Type {
	return ServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"facility":          basetypes.StringType{},
		"host":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"port":              basetypes.Int64Type{},
		"protocol":          basetypes.StringType{},
		"routing_instance":  basetypes.StringType{},
		"severity":          basetypes.StringType{},
		"source_address":    basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
		"tag":               basetypes.StringType{},
	}
}




















var _ basetypes.ObjectTypable = UsersType{}

type UsersType struct {
	basetypes.ObjectType
}

func (t UsersType) Equal(o attr.Type) bool {
	other, ok := o.(UsersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsersType) String() string {
	return "UsersType"
}

func (t UsersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsersValue{
		Contents: contentsVal,
		Match:    matchVal,
		User:     userVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewUsersValueNull() UsersValue {
	return UsersValue{
		state: attr.ValueStateNull,
	}
}

func NewUsersValueUnknown() UsersValue {
	return UsersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsersValue Attribute Value",
				"While creating a UsersValue value, a missing attribute value was detected. "+
					"A UsersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsersValue Attribute Type",
				"While creating a UsersValue value, an invalid attribute value was detected. "+
					"A UsersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsersValue Attribute Value",
				"While creating a UsersValue value, an extra attribute value was detected. "+
					"A UsersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsersValueUnknown(), diags
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewUsersValueUnknown(), diags
	}

	return UsersValue{
		Contents: contentsVal,
		Match:    matchVal,
		User:     userVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewUsersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsersValue {
	object, diags := NewUsersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsersValueMust(UsersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsersType) ValueType(ctx context.Context) attr.Value {
	return UsersValue{}
}

var _ basetypes.ObjectValuable = UsersValue{}

type UsersValue struct {
	Contents basetypes.ListValue   `tfsdk:"contents"`
	Match    basetypes.StringValue `tfsdk:"match"`
	User     basetypes.StringValue `tfsdk:"user"`
	state    attr.ValueState
}

func (v UsersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsersValue) String() string {
	return "UsersValue"
}

func (v UsersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"match": basetypes.StringType{},
		"user":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"contents": contents,
			"match":    v.Match,
			"user":     v.User,
		})

	return objVal, diags
}

func (v UsersValue) Equal(o attr.Value) bool {
	other, ok := o.(UsersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v UsersValue) Type(ctx context.Context) attr.Type {
	return UsersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"match": basetypes.StringType{},
		"user":  basetypes.StringType{},
	}
}




















var _ basetypes.ObjectTypable = SwitchMatchingType{}

type SwitchMatchingType struct {
	basetypes.ObjectType
}

func (t SwitchMatchingType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchMatchingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchMatchingType) String() string {
	return "SwitchMatchingType"
}

func (t SwitchMatchingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return nil, diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchMatchingValue{
		Enable: enableVal,
		Rules:  rulesVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewSwitchMatchingValueNull() SwitchMatchingValue {
	return SwitchMatchingValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchMatchingValueUnknown() SwitchMatchingValue {
	return SwitchMatchingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchMatchingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchMatchingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchMatchingValue Attribute Value",
				"While creating a SwitchMatchingValue value, a missing attribute value was detected. "+
					"A SwitchMatchingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMatchingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchMatchingValue Attribute Type",
				"While creating a SwitchMatchingValue value, an invalid attribute value was detected. "+
					"A SwitchMatchingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMatchingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchMatchingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchMatchingValue Attribute Value",
				"While creating a SwitchMatchingValue value, an extra attribute value was detected. "+
					"A SwitchMatchingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchMatchingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchMatchingValueUnknown(), diags
	}

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return NewSwitchMatchingValueUnknown(), diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewSwitchMatchingValueUnknown(), diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	if diags.HasError() {
		return NewSwitchMatchingValueUnknown(), diags
	}

	return SwitchMatchingValue{
		Enable: enableVal,
		Rules:  rulesVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewSwitchMatchingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchMatchingValue {
	object, diags := NewSwitchMatchingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchMatchingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchMatchingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchMatchingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchMatchingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchMatchingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchMatchingValueMust(SwitchMatchingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchMatchingType) ValueType(ctx context.Context) attr.Value {
	return SwitchMatchingValue{}
}

var _ basetypes.ObjectValuable = SwitchMatchingValue{}

type SwitchMatchingValue struct {
	Enable basetypes.BoolValue `tfsdk:"enable"`
	Rules  basetypes.ListValue `tfsdk:"rules"`
	state  attr.ValueState
}

func (v SwitchMatchingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: RulesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable"] = val

		val, err = v.Rules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchMatchingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchMatchingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchMatchingValue) String() string {
	return "SwitchMatchingValue"
}

func (v SwitchMatchingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	rules := types.ListValueMust(
		RulesType{
			basetypes.ObjectType{
				AttrTypes: RulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Rules.Elements(),
	)

	if v.Rules.IsNull() {
		rules = types.ListNull(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Rules.IsUnknown() {
		rules = types.ListUnknown(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enable": basetypes.BoolType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable": v.Enable,
			"rules":  rules,
		})

	return objVal, diags
}

func (v SwitchMatchingValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchMatchingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enable.Equal(other.Enable) {
		return false
	}

	if !v.Rules.Equal(other.Rules) {
		return false
	}

	return true
}

func (v SwitchMatchingValue) Type(ctx context.Context) attr.Type {
	return SwitchMatchingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchMatchingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable": basetypes.BoolType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RulesType{}

type RulesType struct {
	basetypes.ObjectType
}

func (t RulesType) Equal(o attr.Type) bool {
	other, ok := o.(RulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RulesType) String() string {
	return "RulesType"
}

func (t RulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalConfigCmdsAttribute, ok := attributes["additional_config_cmds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_config_cmds is missing from object`)

		return nil, diags
	}

	additionalConfigCmdsVal, ok := additionalConfigCmdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_config_cmds expected to be basetypes.ListValue, was: %T`, additionalConfigCmdsAttribute))
	}

	matchRoleAttribute, ok := attributes["match_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_role is missing from object`)

		return nil, diags
	}

	matchRoleVal, ok := matchRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_role expected to be basetypes.StringValue, was: %T`, matchRoleAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portConfigAttribute, ok := attributes["port_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_config is missing from object`)

		return nil, diags
	}

	portConfigVal, ok := portConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_config expected to be basetypes.MapValue, was: %T`, portConfigAttribute))
	}

	portMirroringAttribute, ok := attributes["port_mirroring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirroring is missing from object`)

		return nil, diags
	}

	portMirroringVal, ok := portMirroringAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirroring expected to be basetypes.MapValue, was: %T`, portMirroringAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RulesValue{
		AdditionalConfigCmds: additionalConfigCmdsVal,
		MatchRole:            matchRoleVal,
		Name:                 nameVal,
		PortConfig:           portConfigVal,
		PortMirroring:        portMirroringVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewRulesValueNull() RulesValue {
	return RulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRulesValueUnknown() RulesValue {
	return RulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RulesValue Attribute Value",
				"While creating a RulesValue value, a missing attribute value was detected. "+
					"A RulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RulesValue Attribute Type",
				"While creating a RulesValue value, an invalid attribute value was detected. "+
					"A RulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RulesValue Attribute Value",
				"While creating a RulesValue value, an extra attribute value was detected. "+
					"A RulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	additionalConfigCmdsAttribute, ok := attributes["additional_config_cmds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_config_cmds is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	additionalConfigCmdsVal, ok := additionalConfigCmdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_config_cmds expected to be basetypes.ListValue, was: %T`, additionalConfigCmdsAttribute))
	}

	matchRoleAttribute, ok := attributes["match_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_role is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	matchRoleVal, ok := matchRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_role expected to be basetypes.StringValue, was: %T`, matchRoleAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portConfigAttribute, ok := attributes["port_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_config is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	portConfigVal, ok := portConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_config expected to be basetypes.MapValue, was: %T`, portConfigAttribute))
	}

	portMirroringAttribute, ok := attributes["port_mirroring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirroring is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	portMirroringVal, ok := portMirroringAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirroring expected to be basetypes.MapValue, was: %T`, portMirroringAttribute))
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	return RulesValue{
		AdditionalConfigCmds: additionalConfigCmdsVal,
		MatchRole:            matchRoleVal,
		Name:                 nameVal,
		PortConfig:           portConfigVal,
		PortMirroring:        portMirroringVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RulesValue {
	object, diags := NewRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRulesValueMust(RulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RulesType) ValueType(ctx context.Context) attr.Value {
	return RulesValue{}
}

var _ basetypes.ObjectValuable = RulesValue{}

type RulesValue struct {
	AdditionalConfigCmds basetypes.ListValue   `tfsdk:"additional_config_cmds"`
	MatchRole            basetypes.StringValue `tfsdk:"match_role"`
	Name                 basetypes.StringValue `tfsdk:"name"`
	PortConfig           basetypes.MapValue    `tfsdk:"port_config"`
	PortMirroring        basetypes.MapValue    `tfsdk:"port_mirroring"`
	state                attr.ValueState
}

func (v RulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["additional_config_cmds"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["match_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_config"] = basetypes.MapType{
		ElemType: PortConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["port_mirroring"] = basetypes.MapType{
		ElemType: PortMirroringValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AdditionalConfigCmds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_config_cmds"] = val

		val, err = v.MatchRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_role"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PortConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_config"] = val

		val, err = v.PortMirroring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mirroring"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RulesValue) String() string {
	return "RulesValue"
}

func (v RulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	portConfig := types.MapValueMust(
		PortConfigType{
			basetypes.ObjectType{
				AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.PortConfig.Elements(),
	)

	if v.PortConfig.IsNull() {
		portConfig = types.MapNull(
			PortConfigType{
				basetypes.ObjectType{
					AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortConfig.IsUnknown() {
		portConfig = types.MapUnknown(
			PortConfigType{
				basetypes.ObjectType{
					AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	portMirroring := types.MapValueMust(
		PortMirroringType{
			basetypes.ObjectType{
				AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
			},
		},
		v.PortMirroring.Elements(),
	)

	if v.PortMirroring.IsNull() {
		portMirroring = types.MapNull(
			PortMirroringType{
				basetypes.ObjectType{
					AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortMirroring.IsUnknown() {
		portMirroring = types.MapUnknown(
			PortMirroringType{
				basetypes.ObjectType{
					AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	additionalConfigCmdsVal, d := types.ListValue(types.StringType, v.AdditionalConfigCmds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_config_cmds": basetypes.ListType{
				ElemType: types.StringType,
			},
			"match_role": basetypes.StringType{},
			"name":       basetypes.StringType{},
			"port_config": basetypes.MapType{
				ElemType: PortConfigValue{}.Type(ctx),
			},
			"port_mirroring": basetypes.MapType{
				ElemType: PortMirroringValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_config_cmds": basetypes.ListType{
			ElemType: types.StringType,
		},
		"match_role": basetypes.StringType{},
		"name":       basetypes.StringType{},
		"port_config": basetypes.MapType{
			ElemType: PortConfigValue{}.Type(ctx),
		},
		"port_mirroring": basetypes.MapType{
			ElemType: PortMirroringValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_config_cmds": additionalConfigCmdsVal,
			"match_role":             v.MatchRole,
			"name":                   v.Name,
			"port_config":            portConfig,
			"port_mirroring":         portMirroring,
		})

	return objVal, diags
}

func (v RulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalConfigCmds.Equal(other.AdditionalConfigCmds) {
		return false
	}

	if !v.MatchRole.Equal(other.MatchRole) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PortConfig.Equal(other.PortConfig) {
		return false
	}

	if !v.PortMirroring.Equal(other.PortMirroring) {
		return false
	}

	return true
}

func (v RulesValue) Type(ctx context.Context) attr.Type {
	return RulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_config_cmds": basetypes.ListType{
			ElemType: types.StringType,
		},
		"match_role": basetypes.StringType{},
		"name":       basetypes.StringType{},
		"port_config": basetypes.MapType{
			ElemType: PortConfigValue{}.Type(ctx),
		},
		"port_mirroring": basetypes.MapType{
			ElemType: PortMirroringValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PortConfigType{}

type PortConfigType struct {
	basetypes.ObjectType
}

func (t PortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortConfigType) String() string {
	return "PortConfigType"
}

func (t PortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return nil, diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return nil, diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.Int64Value, was: %T`, aeIdxAttribute))
	}

	aeLacpSlowAttribute, ok := attributes["ae_lacp_slow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_slow is missing from object`)

		return nil, diags
	}

	aeLacpSlowVal, ok := aeLacpSlowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_slow expected to be basetypes.BoolValue, was: %T`, aeLacpSlowAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return nil, diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicUsageAttribute, ok := attributes["dynamic_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_usage is missing from object`)

		return nil, diags
	}

	dynamicUsageVal, ok := dynamicUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_usage expected to be basetypes.StringValue, was: %T`, dynamicUsageAttribute))
	}

	esilagAttribute, ok := attributes["esilag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esilag is missing from object`)

		return nil, diags
	}

	esilagVal, ok := esilagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esilag expected to be basetypes.BoolValue, was: %T`, esilagAttribute))
	}

	interSwitchLinkAttribute, ok := attributes["inter_switch_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_link is missing from object`)

		return nil, diags
	}

	interSwitchLinkVal, ok := interSwitchLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_link expected to be basetypes.BoolValue, was: %T`, interSwitchLinkAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	noLocalOverwriteAttribute, ok := attributes["no_local_overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_local_overwrite is missing from object`)

		return nil, diags
	}

	noLocalOverwriteVal, ok := noLocalOverwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_local_overwrite expected to be basetypes.BoolValue, was: %T`, noLocalOverwriteAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpSlow:       aeLacpSlowVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Duplex:           duplexVal,
		DynamicUsage:     dynamicUsageVal,
		Esilag:           esilagVal,
		InterSwitchLink:  interSwitchLinkVal,
		Mtu:              mtuVal,
		NoLocalOverwrite: noLocalOverwriteVal,
		PoeDisabled:      poeDisabledVal,
		Speed:            speedVal,
		Usage:            usageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueNull() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortConfigValueUnknown() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, a missing attribute value was detected. "+
					"A PortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortConfigValue Attribute Type",
				"While creating a PortConfigValue value, an invalid attribute value was detected. "+
					"A PortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, an extra attribute value was detected. "+
					"A PortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.Int64Value, was: %T`, aeIdxAttribute))
	}

	aeLacpSlowAttribute, ok := attributes["ae_lacp_slow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_slow is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeLacpSlowVal, ok := aeLacpSlowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_slow expected to be basetypes.BoolValue, was: %T`, aeLacpSlowAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicUsageAttribute, ok := attributes["dynamic_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dynamicUsageVal, ok := dynamicUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_usage expected to be basetypes.StringValue, was: %T`, dynamicUsageAttribute))
	}

	esilagAttribute, ok := attributes["esilag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esilag is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	esilagVal, ok := esilagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esilag expected to be basetypes.BoolValue, was: %T`, esilagAttribute))
	}

	interSwitchLinkAttribute, ok := attributes["inter_switch_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_link is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	interSwitchLinkVal, ok := interSwitchLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_link expected to be basetypes.BoolValue, was: %T`, interSwitchLinkAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	noLocalOverwriteAttribute, ok := attributes["no_local_overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_local_overwrite is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	noLocalOverwriteVal, ok := noLocalOverwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_local_overwrite expected to be basetypes.BoolValue, was: %T`, noLocalOverwriteAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpSlow:       aeLacpSlowVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Duplex:           duplexVal,
		DynamicUsage:     dynamicUsageVal,
		Esilag:           esilagVal,
		InterSwitchLink:  interSwitchLinkVal,
		Mtu:              mtuVal,
		NoLocalOverwrite: noLocalOverwriteVal,
		PoeDisabled:      poeDisabledVal,
		Speed:            speedVal,
		Usage:            usageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortConfigValue {
	object, diags := NewPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortConfigValueMust(PortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortConfigType) ValueType(ctx context.Context) attr.Value {
	return PortConfigValue{}
}

var _ basetypes.ObjectValuable = PortConfigValue{}

type PortConfigValue struct {
	AeDisableLacp    basetypes.BoolValue   `tfsdk:"ae_disable_lacp"`
	AeIdx            basetypes.Int64Value  `tfsdk:"ae_idx"`
	AeLacpSlow       basetypes.BoolValue   `tfsdk:"ae_lacp_slow"`
	Aggregated       basetypes.BoolValue   `tfsdk:"aggregated"`
	Critical         basetypes.BoolValue   `tfsdk:"critical"`
	Description      basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg   basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Duplex           basetypes.StringValue `tfsdk:"duplex"`
	DynamicUsage     basetypes.StringValue `tfsdk:"dynamic_usage"`
	Esilag           basetypes.BoolValue   `tfsdk:"esilag"`
	InterSwitchLink  basetypes.BoolValue   `tfsdk:"inter_switch_link"`
	Mtu              basetypes.Int64Value  `tfsdk:"mtu"`
	NoLocalOverwrite basetypes.BoolValue   `tfsdk:"no_local_overwrite"`
	PoeDisabled      basetypes.BoolValue   `tfsdk:"poe_disabled"`
	Speed            basetypes.StringValue `tfsdk:"speed"`
	Usage            basetypes.StringValue `tfsdk:"usage"`
	state            attr.ValueState
}

func (v PortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["ae_disable_lacp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ae_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ae_lacp_slow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aggregated"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["critical"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["esilag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["inter_switch_link"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["no_local_overwrite"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.AeDisableLacp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_disable_lacp"] = val

		val, err = v.AeIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_idx"] = val

		val, err = v.AeLacpSlow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_lacp_slow"] = val

		val, err = v.Aggregated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregated"] = val

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.DynamicUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_usage"] = val

		val, err = v.Esilag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["esilag"] = val

		val, err = v.InterSwitchLink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inter_switch_link"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.NoLocalOverwrite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_local_overwrite"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortConfigValue) String() string {
	return "PortConfigValue"
}

func (v PortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ae_disable_lacp":    basetypes.BoolType{},
		"ae_idx":             basetypes.Int64Type{},
		"ae_lacp_slow":       basetypes.BoolType{},
		"aggregated":         basetypes.BoolType{},
		"critical":           basetypes.BoolType{},
		"description":        basetypes.StringType{},
		"disable_autoneg":    basetypes.BoolType{},
		"duplex":             basetypes.StringType{},
		"dynamic_usage":      basetypes.StringType{},
		"esilag":             basetypes.BoolType{},
		"inter_switch_link":  basetypes.BoolType{},
		"mtu":                basetypes.Int64Type{},
		"no_local_overwrite": basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"speed":              basetypes.StringType{},
		"usage":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ae_disable_lacp":    v.AeDisableLacp,
			"ae_idx":             v.AeIdx,
			"ae_lacp_slow":       v.AeLacpSlow,
			"aggregated":         v.Aggregated,
			"critical":           v.Critical,
			"description":        v.Description,
			"disable_autoneg":    v.DisableAutoneg,
			"duplex":             v.Duplex,
			"dynamic_usage":      v.DynamicUsage,
			"esilag":             v.Esilag,
			"inter_switch_link":  v.InterSwitchLink,
			"mtu":                v.Mtu,
			"no_local_overwrite": v.NoLocalOverwrite,
			"poe_disabled":       v.PoeDisabled,
			"speed":              v.Speed,
			"usage":              v.Usage,
		})

	return objVal, diags
}

func (v PortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AeDisableLacp.Equal(other.AeDisableLacp) {
		return false
	}

	if !v.AeIdx.Equal(other.AeIdx) {
		return false
	}

	if !v.AeLacpSlow.Equal(other.AeLacpSlow) {
		return false
	}

	if !v.Aggregated.Equal(other.Aggregated) {
		return false
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.DynamicUsage.Equal(other.DynamicUsage) {
		return false
	}

	if !v.Esilag.Equal(other.Esilag) {
		return false
	}

	if !v.InterSwitchLink.Equal(other.InterSwitchLink) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.NoLocalOverwrite.Equal(other.NoLocalOverwrite) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v PortConfigValue) Type(ctx context.Context) attr.Type {
	return PortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ae_disable_lacp":    basetypes.BoolType{},
		"ae_idx":             basetypes.Int64Type{},
		"ae_lacp_slow":       basetypes.BoolType{},
		"aggregated":         basetypes.BoolType{},
		"critical":           basetypes.BoolType{},
		"description":        basetypes.StringType{},
		"disable_autoneg":    basetypes.BoolType{},
		"duplex":             basetypes.StringType{},
		"dynamic_usage":      basetypes.StringType{},
		"esilag":             basetypes.BoolType{},
		"inter_switch_link":  basetypes.BoolType{},
		"mtu":                basetypes.Int64Type{},
		"no_local_overwrite": basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"speed":              basetypes.StringType{},
		"usage":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortMirroringType{}

type PortMirroringType struct {
	basetypes.ObjectType
}

func (t PortMirroringType) Equal(o attr.Type) bool {
	other, ok := o.(PortMirroringType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMirroringType) String() string {
	return "PortMirroringType"
}

func (t PortMirroringType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	inputNetworksIngressAttribute, ok := attributes["input_networks_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_networks_ingress is missing from object`)

		return nil, diags
	}

	inputNetworksIngressVal, ok := inputNetworksIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_networks_ingress expected to be basetypes.ListValue, was: %T`, inputNetworksIngressAttribute))
	}

	inputPortIdsEgressAttribute, ok := attributes["input_port_ids_egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_egress is missing from object`)

		return nil, diags
	}

	inputPortIdsEgressVal, ok := inputPortIdsEgressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_egress expected to be basetypes.ListValue, was: %T`, inputPortIdsEgressAttribute))
	}

	inputPortIdsIngressAttribute, ok := attributes["input_port_ids_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_ingress is missing from object`)

		return nil, diags
	}

	inputPortIdsIngressVal, ok := inputPortIdsIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_ingress expected to be basetypes.ListValue, was: %T`, inputPortIdsIngressAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return nil, diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortMirroringValue{
		InputNetworksIngress: inputNetworksIngressVal,
		InputPortIdsEgress:   inputPortIdsEgressVal,
		InputPortIdsIngress:  inputPortIdsIngressVal,
		OutputPortId:         outputPortIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueNull() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMirroringValueUnknown() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMirroringValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMirroringValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, a missing attribute value was detected. "+
					"A PortMirroringValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMirroringValue Attribute Type",
				"While creating a PortMirroringValue value, an invalid attribute value was detected. "+
					"A PortMirroringValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, an extra attribute value was detected. "+
					"A PortMirroringValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMirroringValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	inputNetworksIngressAttribute, ok := attributes["input_networks_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_networks_ingress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputNetworksIngressVal, ok := inputNetworksIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_networks_ingress expected to be basetypes.ListValue, was: %T`, inputNetworksIngressAttribute))
	}

	inputPortIdsEgressAttribute, ok := attributes["input_port_ids_egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_egress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputPortIdsEgressVal, ok := inputPortIdsEgressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_egress expected to be basetypes.ListValue, was: %T`, inputPortIdsEgressAttribute))
	}

	inputPortIdsIngressAttribute, ok := attributes["input_port_ids_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_ingress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputPortIdsIngressVal, ok := inputPortIdsIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_ingress expected to be basetypes.ListValue, was: %T`, inputPortIdsIngressAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	return PortMirroringValue{
		InputNetworksIngress: inputNetworksIngressVal,
		InputPortIdsEgress:   inputPortIdsEgressVal,
		InputPortIdsIngress:  inputPortIdsIngressVal,
		OutputPortId:         outputPortIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMirroringValue {
	object, diags := NewPortMirroringValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMirroringValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMirroringType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMirroringValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMirroringValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMirroringValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMirroringValueMust(PortMirroringValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMirroringType) ValueType(ctx context.Context) attr.Value {
	return PortMirroringValue{}
}

var _ basetypes.ObjectValuable = PortMirroringValue{}

type PortMirroringValue struct {
	InputNetworksIngress basetypes.ListValue   `tfsdk:"input_networks_ingress"`
	InputPortIdsEgress   basetypes.ListValue   `tfsdk:"input_port_ids_egress"`
	InputPortIdsIngress  basetypes.ListValue   `tfsdk:"input_port_ids_ingress"`
	OutputPortId         basetypes.StringValue `tfsdk:"output_port_id"`
	state                attr.ValueState
}

func (v PortMirroringValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["input_networks_ingress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["input_port_ids_egress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["input_port_ids_ingress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["output_port_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.InputNetworksIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_networks_ingress"] = val

		val, err = v.InputPortIdsEgress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_port_ids_egress"] = val

		val, err = v.InputPortIdsIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_port_ids_ingress"] = val

		val, err = v.OutputPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_port_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMirroringValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMirroringValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMirroringValue) String() string {
	return "PortMirroringValue"
}

func (v PortMirroringValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	inputNetworksIngressVal, d := types.ListValue(types.StringType, v.InputNetworksIngress.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_port_id": basetypes.StringType{},
		}), diags
	}

	inputPortIdsEgressVal, d := types.ListValue(types.StringType, v.InputPortIdsEgress.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_port_id": basetypes.StringType{},
		}), diags
	}

	inputPortIdsIngressVal, d := types.ListValue(types.StringType, v.InputPortIdsIngress.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_port_id": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"input_networks_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_egress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_port_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"input_networks_ingress": inputNetworksIngressVal,
			"input_port_ids_egress":  inputPortIdsEgressVal,
			"input_port_ids_ingress": inputPortIdsIngressVal,
			"output_port_id":         v.OutputPortId,
		})

	return objVal, diags
}

func (v PortMirroringValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMirroringValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InputNetworksIngress.Equal(other.InputNetworksIngress) {
		return false
	}

	if !v.InputPortIdsEgress.Equal(other.InputPortIdsEgress) {
		return false
	}

	if !v.InputPortIdsIngress.Equal(other.InputPortIdsIngress) {
		return false
	}

	if !v.OutputPortId.Equal(other.OutputPortId) {
		return false
	}

	return true
}

func (v PortMirroringValue) Type(ctx context.Context) attr.Type {
	return PortMirroringType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMirroringValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"input_networks_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_egress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_port_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SwitchMgmtType{}

type SwitchMgmtType struct {
	basetypes.ObjectType
}

func (t SwitchMgmtType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchMgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchMgmtType) String() string {
	return "SwitchMgmtType"
}

func (t SwitchMgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configRevertAttribute, ok := attributes["config_revert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_revert is missing from object`)

		return nil, diags
	}

	configRevertVal, ok := configRevertAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_revert expected to be basetypes.Int64Value, was: %T`, configRevertAttribute))
	}

	protectReAttribute, ok := attributes["protect_re"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protect_re is missing from object`)

		return nil, diags
	}

	protectReVal, ok := protectReAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protect_re expected to be basetypes.ObjectValue, was: %T`, protectReAttribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return nil, diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	tacacsAttribute, ok := attributes["tacacs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacacs is missing from object`)

		return nil, diags
	}

	tacacsVal, ok := tacacsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacacs expected to be basetypes.ObjectValue, was: %T`, tacacsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchMgmtValue{
		ConfigRevert: configRevertVal,
		ProtectRe:    protectReVal,
		RootPassword: rootPasswordVal,
		Tacacs:       tacacsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueNull() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchMgmtValueUnknown() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchMgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, a missing attribute value was detected. "+
					"A SwitchMgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchMgmtValue Attribute Type",
				"While creating a SwitchMgmtValue value, an invalid attribute value was detected. "+
					"A SwitchMgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, an extra attribute value was detected. "+
					"A SwitchMgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchMgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	configRevertAttribute, ok := attributes["config_revert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_revert is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	configRevertVal, ok := configRevertAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_revert expected to be basetypes.Int64Value, was: %T`, configRevertAttribute))
	}

	protectReAttribute, ok := attributes["protect_re"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protect_re is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	protectReVal, ok := protectReAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protect_re expected to be basetypes.ObjectValue, was: %T`, protectReAttribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	tacacsAttribute, ok := attributes["tacacs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacacs is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	tacacsVal, ok := tacacsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacacs expected to be basetypes.ObjectValue, was: %T`, tacacsAttribute))
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	return SwitchMgmtValue{
		ConfigRevert: configRevertVal,
		ProtectRe:    protectReVal,
		RootPassword: rootPasswordVal,
		Tacacs:       tacacsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchMgmtValue {
	object, diags := NewSwitchMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchMgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchMgmtValueMust(SwitchMgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchMgmtType) ValueType(ctx context.Context) attr.Value {
	return SwitchMgmtValue{}
}

var _ basetypes.ObjectValuable = SwitchMgmtValue{}

type SwitchMgmtValue struct {
	ConfigRevert basetypes.Int64Value  `tfsdk:"config_revert"`
	ProtectRe    basetypes.ObjectValue `tfsdk:"protect_re"`
	RootPassword basetypes.StringValue `tfsdk:"root_password"`
	Tacacs       basetypes.ObjectValue `tfsdk:"tacacs"`
	state        attr.ValueState
}

func (v SwitchMgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["config_revert"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protect_re"] = basetypes.ObjectType{
		AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["root_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tacacs"] = basetypes.ObjectType{
		AttrTypes: TacacsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConfigRevert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_revert"] = val

		val, err = v.ProtectRe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protect_re"] = val

		val, err = v.RootPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_password"] = val

		val, err = v.Tacacs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tacacs"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchMgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchMgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchMgmtValue) String() string {
	return "SwitchMgmtValue"
}

func (v SwitchMgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var protectRe basetypes.ObjectValue

	if v.ProtectRe.IsNull() {
		protectRe = types.ObjectNull(
			ProtectReValue{}.AttributeTypes(ctx),
		)
	}

	if v.ProtectRe.IsUnknown() {
		protectRe = types.ObjectUnknown(
			ProtectReValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ProtectRe.IsNull() && !v.ProtectRe.IsUnknown() {
		protectRe = types.ObjectValueMust(
			ProtectReValue{}.AttributeTypes(ctx),
			v.ProtectRe.Attributes(),
		)
	}

	var tacacs basetypes.ObjectValue

	if v.Tacacs.IsNull() {
		tacacs = types.ObjectNull(
			TacacsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tacacs.IsUnknown() {
		tacacs = types.ObjectUnknown(
			TacacsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tacacs.IsNull() && !v.Tacacs.IsUnknown() {
		tacacs = types.ObjectValueMust(
			TacacsValue{}.AttributeTypes(ctx),
			v.Tacacs.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"config_revert": basetypes.Int64Type{},
		"protect_re": basetypes.ObjectType{
			AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
		},
		"root_password": basetypes.StringType{},
		"tacacs": basetypes.ObjectType{
			AttrTypes: TacacsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"config_revert": v.ConfigRevert,
			"protect_re":    protectRe,
			"root_password": v.RootPassword,
			"tacacs":        tacacs,
		})

	return objVal, diags
}

func (v SwitchMgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchMgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfigRevert.Equal(other.ConfigRevert) {
		return false
	}

	if !v.ProtectRe.Equal(other.ProtectRe) {
		return false
	}

	if !v.RootPassword.Equal(other.RootPassword) {
		return false
	}

	if !v.Tacacs.Equal(other.Tacacs) {
		return false
	}

	return true
}

func (v SwitchMgmtValue) Type(ctx context.Context) attr.Type {
	return SwitchMgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchMgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config_revert": basetypes.Int64Type{},
		"protect_re": basetypes.ObjectType{
			AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
		},
		"root_password": basetypes.StringType{},
		"tacacs": basetypes.ObjectType{
			AttrTypes: TacacsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ProtectReType{}

type ProtectReType struct {
	basetypes.ObjectType
}

func (t ProtectReType) Equal(o attr.Type) bool {
	other, ok := o.(ProtectReType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProtectReType) String() string {
	return "ProtectReType"
}

func (t ProtectReType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedServicesAttribute, ok := attributes["allowed_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_services is missing from object`)

		return nil, diags
	}

	allowedServicesVal, ok := allowedServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_services expected to be basetypes.ListValue, was: %T`, allowedServicesAttribute))
	}

	customAttribute, ok := attributes["custom"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom is missing from object`)

		return nil, diags
	}

	customVal, ok := customAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom expected to be basetypes.ListValue, was: %T`, customAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	trustedHostsAttribute, ok := attributes["trusted_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted_hosts is missing from object`)

		return nil, diags
	}

	trustedHostsVal, ok := trustedHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted_hosts expected to be basetypes.ListValue, was: %T`, trustedHostsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProtectReValue{
		AllowedServices: allowedServicesVal,
		Custom:          customVal,
		Enabled:         enabledVal,
		TrustedHosts:    trustedHostsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtectReValueNull() ProtectReValue {
	return ProtectReValue{
		state: attr.ValueStateNull,
	}
}

func NewProtectReValueUnknown() ProtectReValue {
	return ProtectReValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProtectReValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProtectReValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProtectReValue Attribute Value",
				"While creating a ProtectReValue value, a missing attribute value was detected. "+
					"A ProtectReValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProtectReValue Attribute Type",
				"While creating a ProtectReValue value, an invalid attribute value was detected. "+
					"A ProtectReValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProtectReValue Attribute Value",
				"While creating a ProtectReValue value, an extra attribute value was detected. "+
					"A ProtectReValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProtectReValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProtectReValueUnknown(), diags
	}

	allowedServicesAttribute, ok := attributes["allowed_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_services is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	allowedServicesVal, ok := allowedServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_services expected to be basetypes.ListValue, was: %T`, allowedServicesAttribute))
	}

	customAttribute, ok := attributes["custom"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	customVal, ok := customAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom expected to be basetypes.ListValue, was: %T`, customAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	trustedHostsAttribute, ok := attributes["trusted_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted_hosts is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	trustedHostsVal, ok := trustedHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted_hosts expected to be basetypes.ListValue, was: %T`, trustedHostsAttribute))
	}

	if diags.HasError() {
		return NewProtectReValueUnknown(), diags
	}

	return ProtectReValue{
		AllowedServices: allowedServicesVal,
		Custom:          customVal,
		Enabled:         enabledVal,
		TrustedHosts:    trustedHostsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtectReValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProtectReValue {
	object, diags := NewProtectReValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProtectReValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProtectReType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProtectReValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProtectReValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProtectReValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProtectReValueMust(ProtectReValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProtectReType) ValueType(ctx context.Context) attr.Value {
	return ProtectReValue{}
}

var _ basetypes.ObjectValuable = ProtectReValue{}

type ProtectReValue struct {
	AllowedServices basetypes.ListValue `tfsdk:"allowed_services"`
	Custom          basetypes.ListValue `tfsdk:"custom"`
	Enabled         basetypes.BoolValue `tfsdk:"enabled"`
	TrustedHosts    basetypes.ListValue `tfsdk:"trusted_hosts"`
	state           attr.ValueState
}

func (v ProtectReValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["allowed_services"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["custom"] = basetypes.ListType{
		ElemType: CustomValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["trusted_hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AllowedServices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_services"] = val

		val, err = v.Custom.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.TrustedHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trusted_hosts"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProtectReValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProtectReValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProtectReValue) String() string {
	return "ProtectReValue"
}

func (v ProtectReValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	custom := types.ListValueMust(
		CustomType{
			basetypes.ObjectType{
				AttrTypes: CustomValue{}.AttributeTypes(ctx),
			},
		},
		v.Custom.Elements(),
	)

	if v.Custom.IsNull() {
		custom = types.ListNull(
			CustomType{
				basetypes.ObjectType{
					AttrTypes: CustomValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Custom.IsUnknown() {
		custom = types.ListUnknown(
			CustomType{
				basetypes.ObjectType{
					AttrTypes: CustomValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	allowedServicesVal, d := types.ListValue(types.StringType, v.AllowedServices.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom": basetypes.ListType{
				ElemType: CustomValue{}.Type(ctx),
			},
			"enabled": basetypes.BoolType{},
			"trusted_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	trustedHostsVal, d := types.ListValue(types.StringType, v.TrustedHosts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom": basetypes.ListType{
				ElemType: CustomValue{}.Type(ctx),
			},
			"enabled": basetypes.BoolType{},
			"trusted_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allowed_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"custom": basetypes.ListType{
			ElemType: CustomValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"trusted_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_services": allowedServicesVal,
			"custom":           custom,
			"enabled":          v.Enabled,
			"trusted_hosts":    trustedHostsVal,
		})

	return objVal, diags
}

func (v ProtectReValue) Equal(o attr.Value) bool {
	other, ok := o.(ProtectReValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedServices.Equal(other.AllowedServices) {
		return false
	}

	if !v.Custom.Equal(other.Custom) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.TrustedHosts.Equal(other.TrustedHosts) {
		return false
	}

	return true
}

func (v ProtectReValue) Type(ctx context.Context) attr.Type {
	return ProtectReType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProtectReValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"custom": basetypes.ListType{
			ElemType: CustomValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"trusted_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = CustomType{}

type CustomType struct {
	basetypes.ObjectType
}

func (t CustomType) Equal(o attr.Type) bool {
	other, ok := o.(CustomType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomType) String() string {
	return "CustomType"
}

func (t CustomType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return nil, diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.ListValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		Subnet:    subnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCustomValueNull() CustomValue {
	return CustomValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomValueUnknown() CustomValue {
	return CustomValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomValue Attribute Value",
				"While creating a CustomValue value, a missing attribute value was detected. "+
					"A CustomValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomValue Attribute Type",
				"While creating a CustomValue value, an invalid attribute value was detected. "+
					"A CustomValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomValue Attribute Value",
				"While creating a CustomValue value, an extra attribute value was detected. "+
					"A CustomValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.ListValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	return CustomValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		Subnet:    subnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCustomValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomValue {
	object, diags := NewCustomValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomValueMust(CustomValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomType) ValueType(ctx context.Context) attr.Value {
	return CustomValue{}
}

var _ basetypes.ObjectValuable = CustomValue{}

type CustomValue struct {
	PortRange basetypes.StringValue `tfsdk:"port_range"`
	Protocol  basetypes.StringValue `tfsdk:"protocol"`
	Subnet    basetypes.ListValue   `tfsdk:"subnet"`
	state     attr.ValueState
}

func (v CustomValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.PortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomValue) String() string {
	return "CustomValue"
}

func (v CustomValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subnetVal, d := types.ListValue(types.StringType, v.Subnet.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"port_range": basetypes.StringType{},
			"protocol":   basetypes.StringType{},
			"subnet": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_range": v.PortRange,
			"protocol":   v.Protocol,
			"subnet":     subnetVal,
		})

	return objVal, diags
}

func (v CustomValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortRange.Equal(other.PortRange) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	return true
}

func (v CustomValue) Type(ctx context.Context) attr.Type {
	return CustomType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TacacsType{}

type TacacsType struct {
	basetypes.ObjectType
}

func (t TacacsType) Equal(o attr.Type) bool {
	other, ok := o.(TacacsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TacacsType) String() string {
	return "TacacsType"
}

func (t TacacsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	tacplusServersAttribute, ok := attributes["tacplus_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacplus_servers is missing from object`)

		return nil, diags
	}

	tacplusServersVal, ok := tacplusServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacplus_servers expected to be basetypes.ListValue, was: %T`, tacplusServersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TacacsValue{
		TacacsAcctServers:    acctServersVal,
		Enabled:        enabledVal,
		Network:        networkVal,
		TacplusServers: tacplusServersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTacacsValueNull() TacacsValue {
	return TacacsValue{
		state: attr.ValueStateNull,
	}
}

func NewTacacsValueUnknown() TacacsValue {
	return TacacsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTacacsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TacacsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TacacsValue Attribute Value",
				"While creating a TacacsValue value, a missing attribute value was detected. "+
					"A TacacsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TacacsValue Attribute Type",
				"While creating a TacacsValue value, an invalid attribute value was detected. "+
					"A TacacsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TacacsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TacacsValue Attribute Value",
				"While creating a TacacsValue value, an extra attribute value was detected. "+
					"A TacacsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TacacsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTacacsValueUnknown(), diags
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	tacplusServersAttribute, ok := attributes["tacplus_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacplus_servers is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	tacplusServersVal, ok := tacplusServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacplus_servers expected to be basetypes.ListValue, was: %T`, tacplusServersAttribute))
	}

	if diags.HasError() {
		return NewTacacsValueUnknown(), diags
	}

	return TacacsValue{
		TacacsAcctServers:    acctServersVal,
		Enabled:        enabledVal,
		Network:        networkVal,
		TacplusServers: tacplusServersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTacacsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TacacsValue {
	object, diags := NewTacacsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTacacsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TacacsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTacacsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTacacsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTacacsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTacacsValueMust(TacacsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TacacsType) ValueType(ctx context.Context) attr.Value {
	return TacacsValue{}
}

var _ basetypes.ObjectValuable = TacacsValue{}

type TacacsValue struct {
	TacacsAcctServers    basetypes.ListValue   `tfsdk:"acct_servers"`
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	Network        basetypes.StringValue `tfsdk:"network"`
	TacplusServers basetypes.ListValue   `tfsdk:"tacplus_servers"`
	state          attr.ValueState
}

func (v TacacsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: TacacsAcctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tacplus_servers"] = basetypes.ListType{
		ElemType: TacplusServersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.TacacsAcctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.TacplusServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tacplus_servers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TacacsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TacacsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TacacsValue) String() string {
	return "TacacsValue"
}

func (v TacacsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acctServers := types.ListValueMust(
		TacacsAcctServersType{
			basetypes.ObjectType{
				AttrTypes: TacacsAcctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.TacacsAcctServers.Elements(),
	)

	if v.TacacsAcctServers.IsNull() {
		acctServers = types.ListNull(
			TacacsAcctServersType{
				basetypes.ObjectType{
					AttrTypes: TacacsAcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TacacsAcctServers.IsUnknown() {
		acctServers = types.ListUnknown(
			TacacsAcctServersType{
				basetypes.ObjectType{
					AttrTypes: TacacsAcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	tacplusServers := types.ListValueMust(
		TacplusServersType{
			basetypes.ObjectType{
				AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
			},
		},
		v.TacplusServers.Elements(),
	)

	if v.TacplusServers.IsNull() {
		tacplusServers = types.ListNull(
			TacplusServersType{
				basetypes.ObjectType{
					AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TacplusServers.IsUnknown() {
		tacplusServers = types.ListUnknown(
			TacplusServersType{
				basetypes.ObjectType{
					AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"acct_servers": basetypes.ListType{
			ElemType: TacacsAcctServersValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"network": basetypes.StringType{},
		"tacplus_servers": basetypes.ListType{
			ElemType: TacplusServersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acct_servers":    acctServers,
			"enabled":         v.Enabled,
			"network":         v.Network,
			"tacplus_servers": tacplusServers,
		})

	return objVal, diags
}

func (v TacacsValue) Equal(o attr.Value) bool {
	other, ok := o.(TacacsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.TacacsAcctServers.Equal(other.TacacsAcctServers) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.TacplusServers.Equal(other.TacplusServers) {
		return false
	}

	return true
}

func (v TacacsValue) Type(ctx context.Context) attr.Type {
	return TacacsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TacacsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acct_servers": basetypes.ListType{
			ElemType: TacacsAcctServersValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"network": basetypes.StringType{},
		"tacplus_servers": basetypes.ListType{
			ElemType: TacplusServersValue{}.Type(ctx),
		},
	}
}




















var _ basetypes.ObjectTypable = TacplusServersType{}

type TacplusServersType struct {
	basetypes.ObjectType
}

func (t TacplusServersType) Equal(o attr.Type) bool {
	other, ok := o.(TacplusServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TacplusServersType) String() string {
	return "TacplusServersType"
}

func (t TacplusServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TacplusServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacplusServersValueNull() TacplusServersValue {
	return TacplusServersValue{
		state: attr.ValueStateNull,
	}
}

func NewTacplusServersValueUnknown() TacplusServersValue {
	return TacplusServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTacplusServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TacplusServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TacplusServersValue Attribute Value",
				"While creating a TacplusServersValue value, a missing attribute value was detected. "+
					"A TacplusServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacplusServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TacplusServersValue Attribute Type",
				"While creating a TacplusServersValue value, an invalid attribute value was detected. "+
					"A TacplusServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacplusServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TacplusServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TacplusServersValue Attribute Value",
				"While creating a TacplusServersValue value, an extra attribute value was detected. "+
					"A TacplusServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TacplusServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTacplusServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewTacplusServersValueUnknown(), diags
	}

	return TacplusServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacplusServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TacplusServersValue {
	object, diags := NewTacplusServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTacplusServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TacplusServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTacplusServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTacplusServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTacplusServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTacplusServersValueMust(TacplusServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TacplusServersType) ValueType(ctx context.Context) attr.Value {
	return TacplusServersValue{}
}

var _ basetypes.ObjectValuable = TacplusServersValue{}

type TacplusServersValue struct {
	Host    basetypes.StringValue `tfsdk:"host"`
	Port    basetypes.StringValue `tfsdk:"port"`
	Secret  basetypes.StringValue `tfsdk:"secret"`
	Timeout basetypes.Int64Value  `tfsdk:"timeout"`
	state   attr.ValueState
}

func (v TacplusServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TacplusServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TacplusServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TacplusServersValue) String() string {
	return "TacplusServersValue"
}

func (v TacplusServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":    v.Host,
			"port":    v.Port,
			"secret":  v.Secret,
			"timeout": v.Timeout,
		})

	return objVal, diags
}

func (v TacplusServersValue) Equal(o attr.Value) bool {
	other, ok := o.(TacplusServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v TacplusServersValue) Type(ctx context.Context) attr.Type {
	return TacplusServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TacplusServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VrfConfigType{}

type VrfConfigType struct {
	basetypes.ObjectType
}

func (t VrfConfigType) Equal(o attr.Type) bool {
	other, ok := o.(VrfConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfConfigType) String() string {
	return "VrfConfigType"
}

func (t VrfConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueNull() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfConfigValueUnknown() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, a missing attribute value was detected. "+
					"A VrfConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfConfigValue Attribute Type",
				"While creating a VrfConfigValue value, an invalid attribute value was detected. "+
					"A VrfConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, an extra attribute value was detected. "+
					"A VrfConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewVrfConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfConfigValue {
	object, diags := NewVrfConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfConfigValueMust(VrfConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfConfigType) ValueType(ctx context.Context) attr.Value {
	return VrfConfigValue{}
}

var _ basetypes.ObjectValuable = VrfConfigValue{}

type VrfConfigValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v VrfConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfConfigValue) String() string {
	return "VrfConfigValue"
}

func (v VrfConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v VrfConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v VrfConfigValue) Type(ctx context.Context) attr.Type {
	return VrfConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VrfInstancesType{}

type VrfInstancesType struct {
	basetypes.ObjectType
}

func (t VrfInstancesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfInstancesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfInstancesType) String() string {
	return "VrfInstancesType"
}

func (t VrfInstancesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	extraRoutesAttribute, ok := attributes["extra_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_routes is missing from object`)

		return nil, diags
	}

	extraRoutesVal, ok := extraRoutesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_routes expected to be basetypes.MapValue, was: %T`, extraRoutesAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfInstancesValue{
		ExtraRoutes: extraRoutesVal,
		Networks:    networksVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVrfInstancesValueNull() VrfInstancesValue {
	return VrfInstancesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfInstancesValueUnknown() VrfInstancesValue {
	return VrfInstancesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfInstancesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfInstancesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfInstancesValue Attribute Value",
				"While creating a VrfInstancesValue value, a missing attribute value was detected. "+
					"A VrfInstancesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfInstancesValue Attribute Type",
				"While creating a VrfInstancesValue value, an invalid attribute value was detected. "+
					"A VrfInstancesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfInstancesValue Attribute Value",
				"While creating a VrfInstancesValue value, an extra attribute value was detected. "+
					"A VrfInstancesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfInstancesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfInstancesValueUnknown(), diags
	}

	extraRoutesAttribute, ok := attributes["extra_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_routes is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	extraRoutesVal, ok := extraRoutesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_routes expected to be basetypes.MapValue, was: %T`, extraRoutesAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewVrfInstancesValueUnknown(), diags
	}

	return VrfInstancesValue{
		ExtraRoutes: extraRoutesVal,
		Networks:    networksVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVrfInstancesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfInstancesValue {
	object, diags := NewVrfInstancesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfInstancesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfInstancesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfInstancesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfInstancesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfInstancesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfInstancesValueMust(VrfInstancesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfInstancesType) ValueType(ctx context.Context) attr.Value {
	return VrfInstancesValue{}
}

var _ basetypes.ObjectValuable = VrfInstancesValue{}

type VrfInstancesValue struct {
	ExtraRoutes basetypes.MapValue  `tfsdk:"extra_routes"`
	Networks    basetypes.ListValue `tfsdk:"networks"`
	state       attr.ValueState
}

func (v VrfInstancesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["extra_routes"] = basetypes.MapType{
		ElemType: ExtraRoutesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ExtraRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extra_routes"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfInstancesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfInstancesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfInstancesValue) String() string {
	return "VrfInstancesValue"
}

func (v VrfInstancesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	extraRoutes := types.MapValueMust(
		ExtraRoutesType{
			basetypes.ObjectType{
				AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
			},
		},
		v.ExtraRoutes.Elements(),
	)

	if v.ExtraRoutes.IsNull() {
		extraRoutes = types.MapNull(
			ExtraRoutesType{
				basetypes.ObjectType{
					AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ExtraRoutes.IsUnknown() {
		extraRoutes = types.MapUnknown(
			ExtraRoutesType{
				basetypes.ObjectType{
					AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"extra_routes": basetypes.MapType{
				ElemType: ExtraRoutesValue{}.Type(ctx),
			},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"extra_routes": basetypes.MapType{
			ElemType: ExtraRoutesValue{}.Type(ctx),
		},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"extra_routes": extraRoutes,
			"networks":     networksVal,
		})

	return objVal, diags
}

func (v VrfInstancesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfInstancesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExtraRoutes.Equal(other.ExtraRoutes) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v VrfInstancesValue) Type(ctx context.Context) attr.Type {
	return VrfInstancesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfInstancesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"extra_routes": basetypes.MapType{
			ElemType: ExtraRoutesValue{}.Type(ctx),
		},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutesType{}

type ExtraRoutesType struct {
	basetypes.ObjectType
}

func (t ExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutesType) String() string {
	return "ExtraRoutesType"
}

func (t ExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueNull() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutesValueUnknown() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, a missing attribute value was detected. "+
					"A ExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutesValue Attribute Type",
				"While creating a ExtraRoutesValue value, an invalid attribute value was detected. "+
					"A ExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, an extra attribute value was detected. "+
					"A ExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	return ExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutesValue {
	object, diags := NewExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutesValueMust(ExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = ExtraRoutesValue{}

type ExtraRoutesValue struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v ExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutesValue) String() string {
	return "ExtraRoutesValue"
}

func (v ExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return ExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TacacsAcctServersType{}

type TacacsAcctServersType struct {
	basetypes.ObjectType
}

func (t TacacsAcctServersType) Equal(o attr.Type) bool {
	other, ok := o.(TacacsAcctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TacacsAcctServersType) String() string {
	return "TacacsAcctServersType"
}

func (t TacacsAcctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TacacsAcctServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacacsAcctServersValueNull() TacacsAcctServersValue {
	return TacacsAcctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewTacacsAcctServersValueUnknown() TacacsAcctServersValue {
	return TacacsAcctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTacacsAcctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TacacsAcctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TacacsAcctServersValue Attribute Value",
				"While creating a TacacsAcctServersValue value, a missing attribute value was detected. "+
					"A TacacsAcctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacsAcctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TacacsAcctServersValue Attribute Type",
				"While creating a TacacsAcctServersValue value, an invalid attribute value was detected. "+
					"A TacacsAcctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacsAcctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TacacsAcctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TacacsAcctServersValue Attribute Value",
				"While creating a TacacsAcctServersValue value, an extra attribute value was detected. "+
					"A TacacsAcctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TacacsAcctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTacacsAcctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewTacacsAcctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewTacacsAcctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewTacacsAcctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewTacacsAcctServersValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewTacacsAcctServersValueUnknown(), diags
	}

	return TacacsAcctServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacacsAcctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TacacsAcctServersValue {
	object, diags := NewTacacsAcctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTacacsAcctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TacacsAcctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTacacsAcctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTacacsAcctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTacacsAcctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTacacsAcctServersValueMust(TacacsAcctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TacacsAcctServersType) ValueType(ctx context.Context) attr.Value {
	return TacacsAcctServersValue{}
}

var _ basetypes.ObjectValuable = TacacsAcctServersValue{}

type TacacsAcctServersValue struct {
	Host    basetypes.StringValue `tfsdk:"host"`
	Port    basetypes.StringValue `tfsdk:"port"`
	Secret  basetypes.StringValue `tfsdk:"secret"`
	Timeout basetypes.Int64Value  `tfsdk:"timeout"`
	state   attr.ValueState
}

func (v TacacsAcctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TacacsAcctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TacacsAcctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TacacsAcctServersValue) String() string {
	return "TacacsAcctServersValue"
}

func (v TacacsAcctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":    v.Host,
			"port":    v.Port,
			"secret":  v.Secret,
			"timeout": v.Timeout,
		})

	return objVal, diags
}

func (v TacacsAcctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(TacacsAcctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v TacacsAcctServersValue) Type(ctx context.Context) attr.Type {
	return TacacsAcctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TacacsAcctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}
}
