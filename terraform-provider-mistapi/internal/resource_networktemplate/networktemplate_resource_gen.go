// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_networktemplate

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func NetworktemplateResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"additional_config_cmds": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"dns_servers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"dns_suffix": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"networks": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"subnet": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"vlan_id": schema.Int64Attribute{
							Optional: true,
							Computed: true,
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is network name",
				MarkdownDescription: "Property key is network name",
			},
			"ntp_servers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"org_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"port_usages": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"all_networks": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `mode`==`trunk`, whether to trunk all network/vlans",
							MarkdownDescription: "if `mode`==`trunk`, whether to trunk all network/vlans",
							Default:             booldefault.StaticBool(false),
						},
						"allow_dhcpd": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri-state.\n\nWhen it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.",
							MarkdownDescription: "if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri-state.\n\nWhen it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.",
						},
						"allow_multiple_supplicants": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"bypass_auth_when_server_down": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`==`dot1x`, bypass auth for known clients if set to true when RADIUS server is down",
							MarkdownDescription: "if `port_auth`==`dot1x`, bypass auth for known clients if set to true when RADIUS server is down",
							Default:             booldefault.StaticBool(false),
						},
						"bypass_auth_when_server_down_for_unkonwn_client": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`=`dot1x`, bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							MarkdownDescription: "if `port_auth`=`dot1x`, bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							Default:             booldefault.StaticBool(false),
						},
						"description": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "description",
							MarkdownDescription: "description",
						},
						"disable_autoneg": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if speed and duplex are specified, whether to disable autonegotiation",
							MarkdownDescription: "if speed and duplex are specified, whether to disable autonegotiation",
							Default:             booldefault.StaticBool(false),
						},
						"disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether the port is disabled",
							MarkdownDescription: "whether the port is disabled",
							Default:             booldefault.StaticBool(false),
						},
						"duplex": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "link connection mode, choices are auto (default), full, and half",
							MarkdownDescription: "link connection mode, choices are auto (default), full, and half",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"half",
									"full",
									"auto",
								),
							},
							Default: stringdefault.StaticString("auto"),
						},
						"dynamic_vlan_networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
							MarkdownDescription: "if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
						},
						"enable_mac_auth": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`==`dot1x`, whether to enable MAC Auth",
							MarkdownDescription: "if `port_auth`==`dot1x`, whether to enable MAC Auth",
							Default:             booldefault.StaticBool(false),
						},
						"enable_qos": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"guest_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`==`dot1x`, which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
							MarkdownDescription: "if `port_auth`==`dot1x`, which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
						},
						"mac_auth_only": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "only effect once `enable_mac_auth`==`true`",
							MarkdownDescription: "only effect once `enable_mac_auth`==`true`",
						},
						"mac_auth_protocol": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled.",
							MarkdownDescription: "if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"pap",
									"eap-peap",
									"eap-md5",
								),
							},
							Default: stringdefault.StaticString("eap-md5"),
						},
						"mac_limit": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform",
							MarkdownDescription: "max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform",
							Validators: []validator.Int64{
								int64validator.AtLeast(0),
							},
							Default: int64default.StaticInt64(0),
						},
						"mode": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "access (default) / trunk",
							MarkdownDescription: "access (default) / trunk",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"access",
									"trunk",
									"inet",
									"wan",
								),
							},
						},
						"mtu": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.",
							MarkdownDescription: "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.",
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "if `mode`==`trunk`, the list of network/vlans",
							MarkdownDescription: "if `mode`==`trunk`, the list of network/vlans",
						},
						"persist_mac": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `mode`==`access` and `port_auth`!=`dot1x`, whether the port should retain dynamically learned MAC addresses",
							MarkdownDescription: "if `mode`==`access` and `port_auth`!=`dot1x`, whether the port should retain dynamically learned MAC addresses",
							Default:             booldefault.StaticBool(false),
						},
						"poe_disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether PoE capabilities are disabled for a port",
							MarkdownDescription: "whether PoE capabilities are disabled for a port",
							Default:             booldefault.StaticBool(false),
						},
						"port_auth": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if dot1x is desired, set to dot1x",
							MarkdownDescription: "if dot1x is desired, set to dot1x",
						},
						"port_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "native network/vlan for untagged traffic",
							MarkdownDescription: "native network/vlan for untagged traffic",
						},
						"reauth_interval": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`=`dot1x`, reauthentication interval range",
							MarkdownDescription: "if `port_auth`=`dot1x`, reauthentication interval range",
							Validators: []validator.Int64{
								int64validator.Between(10, 65535),
							},
							Default: int64default.StaticInt64(3600),
						},
						"rejected_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `port_auth`==`dot1x`, when radius server reject / fails",
							MarkdownDescription: "if `port_auth`==`dot1x`, when radius server reject / fails",
						},
						"speed": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "speed, default is auto to automatically negotiate speed",
							MarkdownDescription: "speed, default is auto to automatically negotiate speed",
						},
						"storm_control": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"no_broadcast": schema.BoolAttribute{
									Optional:            true,
									Description:         "whether to disable storm control on broadcast traffic",
									MarkdownDescription: "whether to disable storm control on broadcast traffic",
								},
								"no_multicast": schema.BoolAttribute{
									Optional:            true,
									Description:         "whether to disable storm control on multicast traffic",
									MarkdownDescription: "whether to disable storm control on multicast traffic",
								},
								"no_registered_multicast": schema.BoolAttribute{
									Optional:            true,
									Description:         "whether to disable storm control on registered multicast traffic",
									MarkdownDescription: "whether to disable storm control on registered multicast traffic",
								},
								"no_unknown_unicast": schema.BoolAttribute{
									Optional:            true,
									Description:         "whether to disable storm control on unknown unicast traffic",
									MarkdownDescription: "whether to disable storm control on unknown unicast traffic",
								},
								"percentage": schema.Int64Attribute{
									Optional:            true,
									Description:         "bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									MarkdownDescription: "bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									Validators: []validator.Int64{
										int64validator.Between(0, 100),
									},
								},
							},
							CustomType: StormControlType{
								ObjectType: types.ObjectType{
									AttrTypes: StormControlValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Switch storm control",
							MarkdownDescription: "Switch storm control",
						},
						"stp_edge": schema.BoolAttribute{
							Optional:            true,
							Description:         "when enabled, the port is not expected to receive BPDU frames",
							MarkdownDescription: "when enabled, the port is not expected to receive BPDU frames",
						},
						"voip_network": schema.StringAttribute{
							Optional:            true,
							Description:         "network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
							MarkdownDescription: "network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
						},
					},
					CustomType: PortUsagesType{
						ObjectType: types.ObjectType{
							AttrTypes: PortUsagesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is the port profile name",
				MarkdownDescription: "Property key is the port profile name",
			},
			"radius_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"acct_interim_interval": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						MarkdownDescription: "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						Validators: []validator.Int64{
							int64validator.Between(0, 65535),
						},
						Default: int64default.StaticInt64(0),
					},
					"acct_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "ip / hostname of RADIUS server",
									MarkdownDescription: "ip / hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"hex",
											"ascii",
										),
									},
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"port": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Acct port of RADIUS server",
									MarkdownDescription: "Acct port of RADIUS server",
									Default:             int64default.StaticInt64(1813),
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Description:         "secret of RADIUS server",
									MarkdownDescription: "secret of RADIUS server",
								},
							},
							CustomType: AcctServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							listvalidator.UniqueValues(),
						},
					},
					"auth_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "ip / hostname of RADIUS server",
									MarkdownDescription: "ip / hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"hex",
											"ascii",
										),
									},
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"port": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Auth port of RADIUS server",
									MarkdownDescription: "Auth port of RADIUS server",
									Default:             int64default.StaticInt64(1812),
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Description:         "secret of RADIUS server",
									MarkdownDescription: "secret of RADIUS server",
								},
							},
							CustomType: AuthServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							listvalidator.UniqueValues(),
						},
					},
					"auth_servers_retries": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "radius auth session retries",
						MarkdownDescription: "radius auth session retries",
						Default:             int64default.StaticInt64(3),
					},
					"auth_servers_timeout": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "radius auth session timeout",
						MarkdownDescription: "radius auth session timeout",
						Default:             int64default.StaticInt64(5),
					},
					"coa_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"coa_port": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(3799),
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "use `network`or `source_ip`\nwhich network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
						MarkdownDescription: "use `network`or `source_ip`\nwhich network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
					},
					"source_ip": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "use `network`or `source_ip`",
						MarkdownDescription: "use `network`or `source_ip`",
					},
				},
				CustomType: RadiusConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Junos Radius config",
				MarkdownDescription: "Junos Radius config",
			},
		},
	}
}

type NetworktemplateModel struct {
	AdditionalConfigCmds types.List        `tfsdk:"additional_config_cmds"`
	DnsServers           types.List        `tfsdk:"dns_servers"`
	DnsSuffix            types.List        `tfsdk:"dns_suffix"`
	Id                   types.String      `tfsdk:"id"`
	Name                 types.String      `tfsdk:"name"`
	Networks             types.Map         `tfsdk:"networks"`
	NtpServers           types.List        `tfsdk:"ntp_servers"`
	OrgId                types.String      `tfsdk:"org_id"`
	PortUsages           types.Map         `tfsdk:"port_usages"`
	RadiusConfig         RadiusConfigValue `tfsdk:"radius_config"`
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		Subnet: subnetVal,
		VlanId: vlanIdVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		Subnet: subnetVal,
		VlanId: vlanIdVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	Subnet basetypes.StringValue `tfsdk:"subnet"`
	VlanId basetypes.Int64Value  `tfsdk:"vlan_id"`
	state  attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"subnet":  basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"subnet":  v.Subnet,
			"vlan_id": v.VlanId,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"subnet":  basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PortUsagesType{}

type PortUsagesType struct {
	basetypes.ObjectType
}

func (t PortUsagesType) Equal(o attr.Type) bool {
	other, ok := o.(PortUsagesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortUsagesType) String() string {
	return "PortUsagesType"
}

func (t PortUsagesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return nil, diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return nil, diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return nil, diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnkonwnClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unkonwn_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unkonwn_client is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownForUnkonwnClientVal, ok := bypassAuthWhenServerDownForUnkonwnClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unkonwn_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnkonwnClientAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return nil, diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return nil, diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return nil, diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return nil, diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return nil, diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return nil, diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return nil, diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return nil, diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return nil, diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return nil, diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return nil, diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.Int64Value, was: %T`, reauthIntervalAttribute))
	}

	rejectedNetworkAttribute, ok := attributes["rejected_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejected_network is missing from object`)

		return nil, diags
	}

	rejectedNetworkVal, ok := rejectedNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejected_network expected to be basetypes.StringValue, was: %T`, rejectedNetworkAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return nil, diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return nil, diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return nil, diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnkonwnClient: bypassAuthWhenServerDownForUnkonwnClientVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		RejectedNetwork:                          rejectedNetworkVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpEdge:                                  stpEdgeVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueNull() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateNull,
	}
}

func NewPortUsagesValueUnknown() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortUsagesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortUsagesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, a missing attribute value was detected. "+
					"A PortUsagesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortUsagesValue Attribute Type",
				"While creating a PortUsagesValue value, an invalid attribute value was detected. "+
					"A PortUsagesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, an extra attribute value was detected. "+
					"A PortUsagesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortUsagesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnkonwnClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unkonwn_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unkonwn_client is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownForUnkonwnClientVal, ok := bypassAuthWhenServerDownForUnkonwnClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unkonwn_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnkonwnClientAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.Int64Value, was: %T`, reauthIntervalAttribute))
	}

	rejectedNetworkAttribute, ok := attributes["rejected_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejected_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	rejectedNetworkVal, ok := rejectedNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejected_network expected to be basetypes.StringValue, was: %T`, rejectedNetworkAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnkonwnClient: bypassAuthWhenServerDownForUnkonwnClientVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		RejectedNetwork:                          rejectedNetworkVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpEdge:                                  stpEdgeVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortUsagesValue {
	object, diags := NewPortUsagesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortUsagesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortUsagesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortUsagesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortUsagesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortUsagesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortUsagesValueMust(PortUsagesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortUsagesType) ValueType(ctx context.Context) attr.Value {
	return PortUsagesValue{}
}

var _ basetypes.ObjectValuable = PortUsagesValue{}

type PortUsagesValue struct {
	AllNetworks                              basetypes.BoolValue   `tfsdk:"all_networks"`
	AllowDhcpd                               basetypes.BoolValue   `tfsdk:"allow_dhcpd"`
	AllowMultipleSupplicants                 basetypes.BoolValue   `tfsdk:"allow_multiple_supplicants"`
	BypassAuthWhenServerDown                 basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down"`
	BypassAuthWhenServerDownForUnkonwnClient basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down_for_unkonwn_client"`
	Description                              basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg                           basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Disabled                                 basetypes.BoolValue   `tfsdk:"disabled"`
	Duplex                                   basetypes.StringValue `tfsdk:"duplex"`
	DynamicVlanNetworks                      basetypes.ListValue   `tfsdk:"dynamic_vlan_networks"`
	EnableMacAuth                            basetypes.BoolValue   `tfsdk:"enable_mac_auth"`
	EnableQos                                basetypes.BoolValue   `tfsdk:"enable_qos"`
	GuestNetwork                             basetypes.StringValue `tfsdk:"guest_network"`
	MacAuthOnly                              basetypes.BoolValue   `tfsdk:"mac_auth_only"`
	MacAuthProtocol                          basetypes.StringValue `tfsdk:"mac_auth_protocol"`
	MacLimit                                 basetypes.Int64Value  `tfsdk:"mac_limit"`
	Mode                                     basetypes.StringValue `tfsdk:"mode"`
	Mtu                                      basetypes.Int64Value  `tfsdk:"mtu"`
	Networks                                 basetypes.ListValue   `tfsdk:"networks"`
	PersistMac                               basetypes.BoolValue   `tfsdk:"persist_mac"`
	PoeDisabled                              basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PortAuth                                 basetypes.StringValue `tfsdk:"port_auth"`
	PortNetwork                              basetypes.StringValue `tfsdk:"port_network"`
	ReauthInterval                           basetypes.Int64Value  `tfsdk:"reauth_interval"`
	RejectedNetwork                          basetypes.StringValue `tfsdk:"rejected_network"`
	Speed                                    basetypes.StringValue `tfsdk:"speed"`
	StormControl                             basetypes.ObjectValue `tfsdk:"storm_control"`
	StpEdge                                  basetypes.BoolValue   `tfsdk:"stp_edge"`
	VoipNetwork                              basetypes.StringValue `tfsdk:"voip_network"`
	state                                    attr.ValueState
}

func (v PortUsagesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 29)

	var val tftypes.Value
	var err error

	attrTypes["all_networks"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_dhcpd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_multiple_supplicants"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down_for_unkonwn_client"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_vlan_networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enable_mac_auth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_qos"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["guest_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_auth_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["persist_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reauth_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rejected_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storm_control"] = basetypes.ObjectType{
		AttrTypes: StormControlValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["stp_edge"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["voip_network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 29)

		val, err = v.AllNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["all_networks"] = val

		val, err = v.AllowDhcpd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_dhcpd"] = val

		val, err = v.AllowMultipleSupplicants.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_multiple_supplicants"] = val

		val, err = v.BypassAuthWhenServerDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down"] = val

		val, err = v.BypassAuthWhenServerDownForUnkonwnClient.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down_for_unkonwn_client"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.DynamicVlanNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_vlan_networks"] = val

		val, err = v.EnableMacAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_mac_auth"] = val

		val, err = v.EnableQos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_qos"] = val

		val, err = v.GuestNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["guest_network"] = val

		val, err = v.MacAuthOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_only"] = val

		val, err = v.MacAuthProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_protocol"] = val

		val, err = v.MacLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_limit"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.PersistMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["persist_mac"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PortAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_auth"] = val

		val, err = v.PortNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_network"] = val

		val, err = v.ReauthInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reauth_interval"] = val

		val, err = v.RejectedNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rejected_network"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.StormControl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storm_control"] = val

		val, err = v.StpEdge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_edge"] = val

		val, err = v.VoipNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["voip_network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortUsagesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortUsagesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortUsagesValue) String() string {
	return "PortUsagesValue"
}

func (v PortUsagesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var stormControl basetypes.ObjectValue

	if v.StormControl.IsNull() {
		stormControl = types.ObjectNull(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if v.StormControl.IsUnknown() {
		stormControl = types.ObjectUnknown(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StormControl.IsNull() && !v.StormControl.IsUnknown() {
		stormControl = types.ObjectValueMust(
			StormControlValue{}.AttributeTypes(ctx),
			v.StormControl.Attributes(),
		)
	}

	dynamicVlanNetworksVal, d := types.ListValue(types.StringType, v.DynamicVlanNetworks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":   basetypes.BoolType{},
			"enable_qos":        basetypes.BoolType{},
			"guest_network":     basetypes.StringType{},
			"mac_auth_only":     basetypes.BoolType{},
			"mac_auth_protocol": basetypes.StringType{},
			"mac_limit":         basetypes.Int64Type{},
			"mode":              basetypes.StringType{},
			"mtu":               basetypes.Int64Type{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":      basetypes.BoolType{},
			"poe_disabled":     basetypes.BoolType{},
			"port_auth":        basetypes.StringType{},
			"port_network":     basetypes.StringType{},
			"reauth_interval":  basetypes.Int64Type{},
			"rejected_network": basetypes.StringType{},
			"speed":            basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_edge":     basetypes.BoolType{},
			"voip_network": basetypes.StringType{},
		}), diags
	}

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":   basetypes.BoolType{},
			"enable_qos":        basetypes.BoolType{},
			"guest_network":     basetypes.StringType{},
			"mac_auth_only":     basetypes.BoolType{},
			"mac_auth_protocol": basetypes.StringType{},
			"mac_limit":         basetypes.Int64Type{},
			"mode":              basetypes.StringType{},
			"mtu":               basetypes.Int64Type{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":      basetypes.BoolType{},
			"poe_disabled":     basetypes.BoolType{},
			"port_auth":        basetypes.StringType{},
			"port_network":     basetypes.StringType{},
			"reauth_interval":  basetypes.Int64Type{},
			"rejected_network": basetypes.StringType{},
			"speed":            basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_edge":     basetypes.BoolType{},
			"voip_network": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":   basetypes.BoolType{},
		"enable_qos":        basetypes.BoolType{},
		"guest_network":     basetypes.StringType{},
		"mac_auth_only":     basetypes.BoolType{},
		"mac_auth_protocol": basetypes.StringType{},
		"mac_limit":         basetypes.Int64Type{},
		"mode":              basetypes.StringType{},
		"mtu":               basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":      basetypes.BoolType{},
		"poe_disabled":     basetypes.BoolType{},
		"port_auth":        basetypes.StringType{},
		"port_network":     basetypes.StringType{},
		"reauth_interval":  basetypes.Int64Type{},
		"rejected_network": basetypes.StringType{},
		"speed":            basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_edge":     basetypes.BoolType{},
		"voip_network": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"all_networks":                                    v.AllNetworks,
			"allow_dhcpd":                                     v.AllowDhcpd,
			"allow_multiple_supplicants":                      v.AllowMultipleSupplicants,
			"bypass_auth_when_server_down":                    v.BypassAuthWhenServerDown,
			"bypass_auth_when_server_down_for_unkonwn_client": v.BypassAuthWhenServerDownForUnkonwnClient,
			"description":                                     v.Description,
			"disable_autoneg":                                 v.DisableAutoneg,
			"disabled":                                        v.Disabled,
			"duplex":                                          v.Duplex,
			"dynamic_vlan_networks":                           dynamicVlanNetworksVal,
			"enable_mac_auth":                                 v.EnableMacAuth,
			"enable_qos":                                      v.EnableQos,
			"guest_network":                                   v.GuestNetwork,
			"mac_auth_only":                                   v.MacAuthOnly,
			"mac_auth_protocol":                               v.MacAuthProtocol,
			"mac_limit":                                       v.MacLimit,
			"mode":                                            v.Mode,
			"mtu":                                             v.Mtu,
			"networks":                                        networksVal,
			"persist_mac":                                     v.PersistMac,
			"poe_disabled":                                    v.PoeDisabled,
			"port_auth":                                       v.PortAuth,
			"port_network":                                    v.PortNetwork,
			"reauth_interval":                                 v.ReauthInterval,
			"rejected_network":                                v.RejectedNetwork,
			"speed":                                           v.Speed,
			"storm_control":                                   stormControl,
			"stp_edge":                                        v.StpEdge,
			"voip_network":                                    v.VoipNetwork,
		})

	return objVal, diags
}

func (v PortUsagesValue) Equal(o attr.Value) bool {
	other, ok := o.(PortUsagesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllNetworks.Equal(other.AllNetworks) {
		return false
	}

	if !v.AllowDhcpd.Equal(other.AllowDhcpd) {
		return false
	}

	if !v.AllowMultipleSupplicants.Equal(other.AllowMultipleSupplicants) {
		return false
	}

	if !v.BypassAuthWhenServerDown.Equal(other.BypassAuthWhenServerDown) {
		return false
	}

	if !v.BypassAuthWhenServerDownForUnkonwnClient.Equal(other.BypassAuthWhenServerDownForUnkonwnClient) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.DynamicVlanNetworks.Equal(other.DynamicVlanNetworks) {
		return false
	}

	if !v.EnableMacAuth.Equal(other.EnableMacAuth) {
		return false
	}

	if !v.EnableQos.Equal(other.EnableQos) {
		return false
	}

	if !v.GuestNetwork.Equal(other.GuestNetwork) {
		return false
	}

	if !v.MacAuthOnly.Equal(other.MacAuthOnly) {
		return false
	}

	if !v.MacAuthProtocol.Equal(other.MacAuthProtocol) {
		return false
	}

	if !v.MacLimit.Equal(other.MacLimit) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.PersistMac.Equal(other.PersistMac) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PortAuth.Equal(other.PortAuth) {
		return false
	}

	if !v.PortNetwork.Equal(other.PortNetwork) {
		return false
	}

	if !v.ReauthInterval.Equal(other.ReauthInterval) {
		return false
	}

	if !v.RejectedNetwork.Equal(other.RejectedNetwork) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.StormControl.Equal(other.StormControl) {
		return false
	}

	if !v.StpEdge.Equal(other.StpEdge) {
		return false
	}

	if !v.VoipNetwork.Equal(other.VoipNetwork) {
		return false
	}

	return true
}

func (v PortUsagesValue) Type(ctx context.Context) attr.Type {
	return PortUsagesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortUsagesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":   basetypes.BoolType{},
		"enable_qos":        basetypes.BoolType{},
		"guest_network":     basetypes.StringType{},
		"mac_auth_only":     basetypes.BoolType{},
		"mac_auth_protocol": basetypes.StringType{},
		"mac_limit":         basetypes.Int64Type{},
		"mode":              basetypes.StringType{},
		"mtu":               basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":      basetypes.BoolType{},
		"poe_disabled":     basetypes.BoolType{},
		"port_auth":        basetypes.StringType{},
		"port_network":     basetypes.StringType{},
		"reauth_interval":  basetypes.Int64Type{},
		"rejected_network": basetypes.StringType{},
		"speed":            basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_edge":     basetypes.BoolType{},
		"voip_network": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StormControlType{}

type StormControlType struct {
	basetypes.ObjectType
}

func (t StormControlType) Equal(o attr.Type) bool {
	other, ok := o.(StormControlType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StormControlType) String() string {
	return "StormControlType"
}

func (t StormControlType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return nil, diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return nil, diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return nil, diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return nil, diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return nil, diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StormControlValue{
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueNull() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateNull,
	}
}

func NewStormControlValueUnknown() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStormControlValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StormControlValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StormControlValue Attribute Value",
				"While creating a StormControlValue value, a missing attribute value was detected. "+
					"A StormControlValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StormControlValue Attribute Type",
				"While creating a StormControlValue value, an invalid attribute value was detected. "+
					"A StormControlValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StormControlValue Attribute Value",
				"While creating a StormControlValue value, an extra attribute value was detected. "+
					"A StormControlValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StormControlValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	return StormControlValue{
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StormControlValue {
	object, diags := NewStormControlValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStormControlValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StormControlType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStormControlValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStormControlValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStormControlValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStormControlValueMust(StormControlValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StormControlType) ValueType(ctx context.Context) attr.Value {
	return StormControlValue{}
}

var _ basetypes.ObjectValuable = StormControlValue{}

type StormControlValue struct {
	NoBroadcast           basetypes.BoolValue  `tfsdk:"no_broadcast"`
	NoMulticast           basetypes.BoolValue  `tfsdk:"no_multicast"`
	NoRegisteredMulticast basetypes.BoolValue  `tfsdk:"no_registered_multicast"`
	NoUnknownUnicast      basetypes.BoolValue  `tfsdk:"no_unknown_unicast"`
	Percentage            basetypes.Int64Value `tfsdk:"percentage"`
	state                 attr.ValueState
}

func (v StormControlValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["no_broadcast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_registered_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_unknown_unicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["percentage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.NoBroadcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_broadcast"] = val

		val, err = v.NoMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_multicast"] = val

		val, err = v.NoRegisteredMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_registered_multicast"] = val

		val, err = v.NoUnknownUnicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_unknown_unicast"] = val

		val, err = v.Percentage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["percentage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StormControlValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StormControlValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StormControlValue) String() string {
	return "StormControlValue"
}

func (v StormControlValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"no_broadcast":            v.NoBroadcast,
			"no_multicast":            v.NoMulticast,
			"no_registered_multicast": v.NoRegisteredMulticast,
			"no_unknown_unicast":      v.NoUnknownUnicast,
			"percentage":              v.Percentage,
		})

	return objVal, diags
}

func (v StormControlValue) Equal(o attr.Value) bool {
	other, ok := o.(StormControlValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NoBroadcast.Equal(other.NoBroadcast) {
		return false
	}

	if !v.NoMulticast.Equal(other.NoMulticast) {
		return false
	}

	if !v.NoRegisteredMulticast.Equal(other.NoRegisteredMulticast) {
		return false
	}

	if !v.NoUnknownUnicast.Equal(other.NoUnknownUnicast) {
		return false
	}

	if !v.Percentage.Equal(other.Percentage) {
		return false
	}

	return true
}

func (v StormControlValue) Type(ctx context.Context) attr.Type {
	return StormControlType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StormControlValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RadiusConfigType{}

type RadiusConfigType struct {
	basetypes.ObjectType
}

func (t RadiusConfigType) Equal(o attr.Type) bool {
	other, ok := o.(RadiusConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadiusConfigType) String() string {
	return "RadiusConfigType"
}

func (t RadiusConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return nil, diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return nil, diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return nil, diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return nil, diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return nil, diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return nil, diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return nil, diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueNull() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewRadiusConfigValueUnknown() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadiusConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadiusConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, a missing attribute value was detected. "+
					"A RadiusConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadiusConfigValue Attribute Type",
				"While creating a RadiusConfigValue value, an invalid attribute value was detected. "+
					"A RadiusConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, an extra attribute value was detected. "+
					"A RadiusConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadiusConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadiusConfigValue {
	object, diags := NewRadiusConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadiusConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadiusConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadiusConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadiusConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadiusConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadiusConfigValueMust(RadiusConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadiusConfigType) ValueType(ctx context.Context) attr.Value {
	return RadiusConfigValue{}
}

var _ basetypes.ObjectValuable = RadiusConfigValue{}

type RadiusConfigValue struct {
	AcctInterimInterval basetypes.Int64Value  `tfsdk:"acct_interim_interval"`
	AcctServers         basetypes.ListValue   `tfsdk:"acct_servers"`
	AuthServers         basetypes.ListValue   `tfsdk:"auth_servers"`
	AuthServersRetries  basetypes.Int64Value  `tfsdk:"auth_servers_retries"`
	AuthServersTimeout  basetypes.Int64Value  `tfsdk:"auth_servers_timeout"`
	CoaEnabled          basetypes.BoolValue   `tfsdk:"coa_enabled"`
	CoaPort             basetypes.Int64Value  `tfsdk:"coa_port"`
	Network             basetypes.StringValue `tfsdk:"network"`
	SourceIp            basetypes.StringValue `tfsdk:"source_ip"`
	state               attr.ValueState
}

func (v RadiusConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["acct_interim_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: AcctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers"] = basetypes.ListType{
		ElemType: AuthServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth_servers_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["coa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["coa_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AcctInterimInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_interim_interval"] = val

		val, err = v.AcctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.AuthServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers"] = val

		val, err = v.AuthServersRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_retries"] = val

		val, err = v.AuthServersTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_timeout"] = val

		val, err = v.CoaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_enabled"] = val

		val, err = v.CoaPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_port"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.SourceIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadiusConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadiusConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadiusConfigValue) String() string {
	return "RadiusConfigValue"
}

func (v RadiusConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acctServers := types.ListValueMust(
		AcctServersType{
			basetypes.ObjectType{
				AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AcctServers.Elements(),
	)

	if v.AcctServers.IsNull() {
		acctServers = types.ListNull(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AcctServers.IsUnknown() {
		acctServers = types.ListUnknown(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	authServers := types.ListValueMust(
		AuthServersType{
			basetypes.ObjectType{
				AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AuthServers.Elements(),
	)

	if v.AuthServers.IsNull() {
		authServers = types.ListNull(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AuthServers.IsUnknown() {
		authServers = types.ListUnknown(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acct_interim_interval": v.AcctInterimInterval,
			"acct_servers":          acctServers,
			"auth_servers":          authServers,
			"auth_servers_retries":  v.AuthServersRetries,
			"auth_servers_timeout":  v.AuthServersTimeout,
			"coa_enabled":           v.CoaEnabled,
			"coa_port":              v.CoaPort,
			"network":               v.Network,
			"source_ip":             v.SourceIp,
		})

	return objVal, diags
}

func (v RadiusConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(RadiusConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AcctInterimInterval.Equal(other.AcctInterimInterval) {
		return false
	}

	if !v.AcctServers.Equal(other.AcctServers) {
		return false
	}

	if !v.AuthServers.Equal(other.AuthServers) {
		return false
	}

	if !v.AuthServersRetries.Equal(other.AuthServersRetries) {
		return false
	}

	if !v.AuthServersTimeout.Equal(other.AuthServersTimeout) {
		return false
	}

	if !v.CoaEnabled.Equal(other.CoaEnabled) {
		return false
	}

	if !v.CoaPort.Equal(other.CoaPort) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.SourceIp.Equal(other.SourceIp) {
		return false
	}

	return true
}

func (v RadiusConfigValue) Type(ctx context.Context) attr.Type {
	return RadiusConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadiusConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AcctServersType{}

type AcctServersType struct {
	basetypes.ObjectType
}

func (t AcctServersType) Equal(o attr.Type) bool {
	other, ok := o.(AcctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AcctServersType) String() string {
	return "AcctServersType"
}

func (t AcctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueNull() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAcctServersValueUnknown() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAcctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AcctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, a missing attribute value was detected. "+
					"A AcctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AcctServersValue Attribute Type",
				"While creating a AcctServersValue value, an invalid attribute value was detected. "+
					"A AcctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, an extra attribute value was detected. "+
					"A AcctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AcctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AcctServersValue {
	object, diags := NewAcctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAcctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AcctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAcctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAcctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAcctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAcctServersValueMust(AcctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AcctServersType) ValueType(ctx context.Context) attr.Value {
	return AcctServersValue{}
}

var _ basetypes.ObjectValuable = AcctServersValue{}

type AcctServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AcctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AcctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AcctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AcctServersValue) String() string {
	return "AcctServersValue"
}

func (v AcctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AcctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AcctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AcctServersValue) Type(ctx context.Context) attr.Type {
	return AcctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AcctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthServersType{}

type AuthServersType struct {
	basetypes.ObjectType
}

func (t AuthServersType) Equal(o attr.Type) bool {
	other, ok := o.(AuthServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthServersType) String() string {
	return "AuthServersType"
}

func (t AuthServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueNull() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthServersValueUnknown() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, a missing attribute value was detected. "+
					"A AuthServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthServersValue Attribute Type",
				"While creating a AuthServersValue value, an invalid attribute value was detected. "+
					"A AuthServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, an extra attribute value was detected. "+
					"A AuthServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthServersValue {
	object, diags := NewAuthServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthServersValueMust(AuthServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthServersType) ValueType(ctx context.Context) attr.Value {
	return AuthServersValue{}
}

var _ basetypes.ObjectValuable = AuthServersValue{}

type AuthServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AuthServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthServersValue) String() string {
	return "AuthServersValue"
}

func (v AuthServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AuthServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AuthServersValue) Type(ctx context.Context) attr.Type {
	return AuthServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}
