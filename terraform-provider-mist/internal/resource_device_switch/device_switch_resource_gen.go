// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_device_switch

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DeviceSwitchResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"acl_policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"action": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"allow",
												"deny",
											),
										},
										Default: stringdefault.StaticString("allow"),
									},
									"dst_tag": schema.StringAttribute{
										Optional: true,
										Computed: true,
									},
								},
								CustomType: ActionsType{
									ObjectType: types.ObjectType{
										AttrTypes: ActionsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "- for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n- for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
							MarkdownDescription: "- for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n- for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
						},
						"name": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"src_tags": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "- for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n- for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
							MarkdownDescription: "- for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n- for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
					},
					CustomType: AclPoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: AclPoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
				Computed: true,
			},
			"acl_tags": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"gbp_tag": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "required if\n- `type`==`dynamic_gbp` (gbp_tag received from RADIUS)\n- `type`==`static_gbp` (applying gbp tag against matching conditions)",
							MarkdownDescription: "required if\n- `type`==`dynamic_gbp` (gbp_tag received from RADIUS)\n- `type`==`static_gbp` (applying gbp tag against matching conditions)",
						},
						"macs": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "required if \n- `type`==`mac`\n- `type`==`static_gbp` if from matching mac",
							MarkdownDescription: "required if \n- `type`==`mac`\n- `type`==`static_gbp` if from matching mac",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if:\n- `type`==`mac` (optional. default is `any`)\n- `type`==`subnet` (optional. default is `any`)\n- `type`==`network`\n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching network (vlan)",
							MarkdownDescription: "if:\n- `type`==`mac` (optional. default is `any`)\n- `type`==`subnet` (optional. default is `any`)\n- `type`==`network`\n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching network (vlan)",
						},
						"radius_group": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "required if \n- `type`==`radius_group` \n- `type`==`static_gbp` if from matching radius_group",
							MarkdownDescription: "required if \n- `type`==`radius_group` \n- `type`==`static_gbp` if from matching radius_group",
						},
						"specs": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"port_range": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "matched dst port, \"0\" means any",
										MarkdownDescription: "matched dst port, \"0\" means any",
										Default:             stringdefault.StaticString("80"),
									},
									"protocol": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "`tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254",
										MarkdownDescription: "`tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254",
										Default:             stringdefault.StaticString("any"),
									},
								},
								CustomType: SpecsType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "if `type`==`resource`\nempty means unrestricted, i.e. any",
							MarkdownDescription: "if `type`==`resource`\nempty means unrestricted, i.e. any",
						},
						"subnets": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "if \n- `type`==`subnet` \n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching subnet",
							MarkdownDescription: "if \n- `type`==`subnet` \n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching subnet",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"type": schema.StringAttribute{
							Required: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"mac",
									"subnet",
									"network",
									"radius_group",
									"any",
									"resource",
									"dynamic_gbp",
									"static_gbp",
								),
							},
						},
					},
					CustomType: AclTagsType{
						ObjectType: types.ObjectType{
							AttrTypes: AclTagsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "ACL Tags to identify traffic source or destination. Key name is the tag name",
				MarkdownDescription: "ACL Tags to identify traffic source or destination. Key name is the tag name",
			},
			"additional_config_cmds": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
				MarkdownDescription: "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"deviceprofile_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"dhcp_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"config": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"dns_servers": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`local` - optional, if not defined, system one will be used",
									MarkdownDescription: "if `type`==`local` - optional, if not defined, system one will be used",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"dns_suffix": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`local` - optional, if not defined, system one will be used",
									MarkdownDescription: "if `type`==`local` - optional, if not defined, system one will be used",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"fixed_bindings": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ip": schema.StringAttribute{
												Optional: true,
												Computed: true,
											},
											"name": schema.StringAttribute{
												Optional: true,
												Computed: true,
											},
										},
										CustomType: FixedBindingsType{
											ObjectType: types.ObjectType{
												AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Property key is the MAC Address",
									MarkdownDescription: "Property key is the MAC Address",
								},
								"gateway": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`local` - optional, `ip` will be used if not provided",
									MarkdownDescription: "if `type`==`local` - optional, `ip` will be used if not provided",
								},
								"ip_end": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`local`",
									MarkdownDescription: "if `type`==`local`",
								},
								"ip_end6": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if `type6`==`local`",
									MarkdownDescription: "if `type6`==`local`",
								},
								"ip_start": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`local`",
									MarkdownDescription: "if `type`==`local`",
								},
								"ip_start6": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if `type6`==`local`",
									MarkdownDescription: "if `type6`==`local`",
								},
								"lease_time": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]",
									MarkdownDescription: "in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]",
									Validators: []validator.Int64{
										int64validator.Between(3600, 604800),
									},
									Default: int64default.StaticInt64(86400),
								},
								"options": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"string",
														"boolean",
														"ip",
														"hex",
														"int16",
														"int32",
														"uint16",
														"uint32",
													),
												},
											},
											"value": schema.StringAttribute{
												Optional: true,
												Computed: true,
											},
										},
										CustomType: OptionsType{
											ObjectType: types.ObjectType{
												AttrTypes: OptionsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Property key is the DHCP option number",
									MarkdownDescription: "Property key is the DHCP option number",
								},
								"server_id_override": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "`server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, \nshould overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.",
									MarkdownDescription: "`server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, \nshould overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.",
									Default:             booldefault.StaticBool(false),
								},
								"servers": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`relay`",
									MarkdownDescription: "if `type`==`relay`",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"servers6": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type6`==`relay`",
									MarkdownDescription: "if `type6`==`relay`",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "DHCP Server (local) or DHCP Relay (relay)",
									MarkdownDescription: "DHCP Server (local) or DHCP Relay (relay)",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"local",
											"relay",
											"none",
										),
									},
									Default: stringdefault.StaticString("local"),
								},
								"type6": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "DHCP Server (local) or DHCP Relay (relay)",
									MarkdownDescription: "DHCP Server (local) or DHCP Relay (relay)",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"local",
											"relay",
											"none",
										),
									},
									Default: stringdefault.StaticString("none"),
								},
								"vendor_encapulated": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"string",
														"boolean",
														"ip",
														"hex",
														"int16",
														"int32",
														"uint16",
														"uint32",
													),
												},
											},
											"value": schema.StringAttribute{
												Optional: true,
												Computed: true,
											},
										},
										CustomType: VendorEncapulatedType{
											ObjectType: types.ObjectType{
												AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Property key is <enterprise number>:<sub option code>, with\n* enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)\n* sub option code: 1-255, sub-option code",
									MarkdownDescription: "Property key is <enterprise number>:<sub option code>, with\n* enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)\n* sub option code: 1-255, sub-option code",
								},
							},
							CustomType: ConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "if set to `true`, disable the DHCP server",
						MarkdownDescription: "if set to `true`, disable the DHCP server",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: DhcpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: DhcpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"dhcp_snooping": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"all_networks": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"enable_arp_spoof_check": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enable for dynamic ARP inspection check",
						MarkdownDescription: "Enable for dynamic ARP inspection check",
					},
					"enable_ip_source_guard": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enable for check for forging source IP address",
						MarkdownDescription: "Enable for check for forging source IP address",
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"networks": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "if `all_networks`==`false`, list of network with DHCP snooping enabled",
						MarkdownDescription: "if `all_networks`==`false`, list of network with DHCP snooping enabled",
						Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
				},
				CustomType: DhcpSnoopingType{
					ObjectType: types.ObjectType{
						AttrTypes: DhcpSnoopingValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"disable_auto_config": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "for a claimed switch, we control the configs by default. This option (disables the behavior)",
				MarkdownDescription: "for a claimed switch, we control the configs by default. This option (disables the behavior)",
				Default:             booldefault.StaticBool(false),
			},
			"dns_servers": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"dns_suffix": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"evpn_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"role": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"core",
								"distribution",
								"access",
							),
						},
					},
				},
				CustomType: EvpnConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: EvpnConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "EVPN Junos settings",
				MarkdownDescription: "EVPN Junos settings",
			},
			"extra_routes": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"discard": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "this takes precedence",
							MarkdownDescription: "this takes precedence",
							Default:             booldefault.StaticBool(false),
						},
						"metric": schema.Int64Attribute{
							Optional: true,
							Computed: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 4294967295),
							},
						},
						"next_qualified": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"metric": schema.Int64Attribute{
										Optional: true,
										Computed: true,
									},
									"preference": schema.Int64Attribute{
										Optional: true,
										Computed: true,
									},
								},
								CustomType: NextQualifiedType{
									ObjectType: types.ObjectType{
										AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
							Computed: true,
						},
						"no_resolve": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"preference": schema.Int64Attribute{
							Optional: true,
							Computed: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 4294967295),
							},
						},
						"via": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "next-hop IP Address",
							MarkdownDescription: "next-hop IP Address",
						},
					},
					CustomType: ExtraRoutesType{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
				Computed: true,
			},
			"extra_routes6": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"discard": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "this takes precedence",
							MarkdownDescription: "this takes precedence",
							Default:             booldefault.StaticBool(false),
						},
						"metric": schema.Int64Attribute{
							Optional: true,
							Computed: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 4294967295),
							},
						},
						"next_qualified": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"metric": schema.Int64Attribute{
										Optional: true,
										Computed: true,
									},
									"preference": schema.Int64Attribute{
										Optional: true,
										Computed: true,
									},
								},
								CustomType: NextQualifiedType{
									ObjectType: types.ObjectType{
										AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
							Computed: true,
						},
						"no_resolve": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"preference": schema.Int64Attribute{
							Optional: true,
							Computed: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 4294967295),
							},
						},
						"via": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "next-hop IP Address",
							MarkdownDescription: "next-hop IP Address",
						},
					},
					CustomType: ExtraRoutes6Type{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutes6Value{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\")",
				MarkdownDescription: "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\")",
			},
			"id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"image1_url": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"image2_url": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"image3_url": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"ip_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dns": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{
							listvalidator.UniqueValues(),
						},
						Default: listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"dns_suffix": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{
							listvalidator.UniqueValues(),
						},
						Default: listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"gateway": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"ip": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"netmask": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "used only if `subnet` is not specified in `networks`",
						MarkdownDescription: "used only if `subnet` is not specified in `networks`",
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "the network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp",
						MarkdownDescription: "the network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp",
					},
					"type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"static",
								"dynamic",
							),
						},
						Default: stringdefault.StaticString("dynamic"),
					},
					"use_mgmt_vrf": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP)",
						MarkdownDescription: "for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP)",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: IpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Junos IP Config",
				MarkdownDescription: "Junos IP Config",
			},
			"managed": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "for an adopted switch, we don’t overwrite their existing configs automatically",
				MarkdownDescription: "for an adopted switch, we don’t overwrite their existing configs automatically",
				Default:             booldefault.StaticBool(false),
			},
			"name": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"networks": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"isolation": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)\nNOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set",
							MarkdownDescription: "whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)\nNOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set",
							Default:             booldefault.StaticBool(false),
						},
						"isolation_vlan_id": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"subnet": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "optional for pure switching, required when L3 / routing features are used",
							MarkdownDescription: "optional for pure switching, required when L3 / routing features are used",
						},
						"vlan_id": schema.Int64Attribute{
							Required: true,
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is network name",
				MarkdownDescription: "Property key is network name",
			},
			"notes": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"ntp_servers": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "list of NTP servers specific to this device. By default, those in Site Settings will be used",
				MarkdownDescription: "list of NTP servers specific to this device. By default, those in Site Settings will be used",
				Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"oob_ip_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ip": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"netmask": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "used only if `subnet` is not specified in `networks`",
							MarkdownDescription: "used only if `subnet` is not specified in `networks`",
						},
						"network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "optional, the network to be used for mgmt",
							MarkdownDescription: "optional, the network to be used for mgmt",
						},
						"type": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"static",
									"dynamic",
								),
							},
							Default: stringdefault.StaticString("dynamic"),
						},
					},
					CustomType: OobIpConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Junos out-of_band (vme/em0/fxp0) IP config",
				MarkdownDescription: "Junos out-of_band (vme/em0/fxp0) IP config",
			},
			"org_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"ospf_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"areas": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"no_summary": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "for a stub/nssa area, where to avoid forwarding type-3 LSA to this area",
									MarkdownDescription: "for a stub/nssa area, where to avoid forwarding type-3 LSA to this area",
								},
							},
							CustomType: AreasType{
								ObjectType: types.ObjectType{
									AttrTypes: AreasValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "OSPF areas to run on this device and the corresponding per-area-specific configs. Property key is the area",
						MarkdownDescription: "OSPF areas to run on this device and the corresponding per-area-specific configs. Property key is the area",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to rung OSPF on this device",
						MarkdownDescription: "whether to rung OSPF on this device",
					},
					"reference_bandwidth": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Bandwidth for calculating metric defaults (9600..4000000000000)",
						MarkdownDescription: "Bandwidth for calculating metric defaults (9600..4000000000000)",
						Default:             stringdefault.StaticString("100M"),
					},
				},
				CustomType: OspfConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: OspfConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Junos OSPF config",
				MarkdownDescription: "Junos OSPF config",
			},
			"other_ip_configs": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"evpn_anycast": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "for EVPN, if anycast is desired",
							MarkdownDescription: "for EVPN, if anycast is desired",
							Default:             booldefault.StaticBool(false),
						},
						"gateway6": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"ip": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "required if `type`==`static`",
							MarkdownDescription: "required if `type`==`static`",
						},
						"ip6": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "required if `type6`==`static`",
							MarkdownDescription: "required if `type6`==`static`",
						},
						"netmask": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "optional, `subnet` from `network` definition will be used if defined",
							MarkdownDescription: "optional, `subnet` from `network` definition will be used if defined",
						},
						"netmask6": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "optional, `subnet` from `network` definition will be used if defined",
							MarkdownDescription: "optional, `subnet` from `network` definition will be used if defined",
						},
						"type": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"static",
									"dhcp",
								),
							},
							Default: stringdefault.StaticString("dhcp"),
						},
						"type6": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"disabled",
									"static",
									"dhcp",
									"autoconf",
								),
							},
							Default: stringdefault.StaticString("disabled"),
						},
					},
					CustomType: OtherIpConfigsType{
						ObjectType: types.ObjectType{
							AttrTypes: OtherIpConfigsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is the network name",
				MarkdownDescription: "Property key is the network name",
			},
			"port_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ae_disable_lacp": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "To disable LACP support for the AE interface",
							MarkdownDescription: "To disable LACP support for the AE interface",
						},
						"ae_idx": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Users could force to use the designated AE name",
							MarkdownDescription: "Users could force to use the designated AE name",
						},
						"ae_lacp_slow": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "to use fast timeout",
							MarkdownDescription: "to use fast timeout",
							Default:             booldefault.StaticBool(true),
						},
						"aggregated": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"critical": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if want to generate port up/down alarm",
							MarkdownDescription: "if want to generate port up/down alarm",
						},
						"description": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"disable_autoneg": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `speed` and `duplex` are specified, whether to disable autonegotiation",
							MarkdownDescription: "if `speed` and `duplex` are specified, whether to disable autonegotiation",
							Default:             booldefault.StaticBool(false),
						},
						"duplex": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"auto",
									"full",
									"half",
								),
							},
							Default: stringdefault.StaticString("auto"),
						},
						"dynamic_usage": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Enable dynamic usage for this port. Set to `dynamic` to enable.",
							MarkdownDescription: "Enable dynamic usage for this port. Set to `dynamic` to enable.",
						},
						"esilag": schema.BoolAttribute{
							Optional: true,
							Computed: true,
						},
						"mtu": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation",
							MarkdownDescription: "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation",
							Default:             int64default.StaticInt64(1514),
						},
						"no_local_overwrite": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "prevent helpdesk to override the port config",
							MarkdownDescription: "prevent helpdesk to override the port config",
						},
						"poe_disabled": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"speed": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"auto",
									"10m",
									"100m",
									"1g",
									"2.5g",
									"5g",
								),
							},
							Default: stringdefault.StaticString("auto"),
						},
						"usage": schema.StringAttribute{
							Required:            true,
							Description:         "port usage name. \n\nIf EVPN is used, use `evpn_uplink`or `evpn_downlink`",
							MarkdownDescription: "port usage name. \n\nIf EVPN is used, use `evpn_uplink`or `evpn_downlink`",
						},
					},
					CustomType: PortConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is the port name or range (e.g. \"ge-0/0/0-10\")",
				MarkdownDescription: "Property key is the port name or range (e.g. \"ge-0/0/0-10\")",
			},
			"port_mirroring": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"input_networks_ingress": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
							MarkdownDescription: "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"input_port_ids_egress": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
							MarkdownDescription: "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"input_port_ids_ingress": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
							MarkdownDescription: "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"output_network": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"output_port_id": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "exaclty on of the `output_port_id` or `output_network` should be provided",
							MarkdownDescription: "exaclty on of the `output_port_id` or `output_network` should be provided",
						},
					},
					CustomType: PortMirroringType{
						ObjectType: types.ObjectType{
							AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Property key is the port mirroring instance name\nport_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.",
				MarkdownDescription: "Property key is the port mirroring instance name\nport_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.",
			},
			"port_usages": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"all_networks": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`==`trunk` whether to trunk all network/vlans",
							MarkdownDescription: "Only if `mode`==`trunk` whether to trunk all network/vlans",
							Default:             booldefault.StaticBool(false),
						},
						"allow_dhcpd": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.\n\nWhen it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.",
							MarkdownDescription: "Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.\n\nWhen it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.",
						},
						"allow_multiple_supplicants": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic`",
							MarkdownDescription: "Only if `mode`!=`dynamic`",
							Default:             booldefault.StaticBool(false),
						},
						"bypass_auth_when_server_down": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down",
							Default:             booldefault.StaticBool(false),
						},
						"bypass_auth_when_server_down_for_unkonwn_client": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							Default:             booldefault.StaticBool(false),
						},
						"description": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic`",
							MarkdownDescription: "Only if `mode`!=`dynamic`",
						},
						"disable_autoneg": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation",
							MarkdownDescription: "Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation",
							Default:             booldefault.StaticBool(false),
						},
						"disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` whether the port is disabled",
							MarkdownDescription: "Only if `mode`!=`dynamic` whether the port is disabled",
							Default:             booldefault.StaticBool(false),
						},
						"duplex": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` link connection mode",
							MarkdownDescription: "Only if `mode`!=`dynamic` link connection mode",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"half",
									"full",
									"auto",
								),
							},
							Default: stringdefault.StaticString("auto"),
						},
						"dynamic_vlan_networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
							MarkdownDescription: "Only if `mode`!=`dynamic` if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"enable_mac_auth": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth",
							Default:             booldefault.StaticBool(false),
						},
						"enable_qos": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"guest_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
						},
						"inter_switch_link": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` inter_switch_link is used together with \"isolation\" under networks\nNOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together",
							MarkdownDescription: "Only if `mode`!=`dynamic` inter_switch_link is used together with \"isolation\" under networks\nNOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together",
							Default:             booldefault.StaticBool(false),
						},
						"mac_auth_only": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`",
						},
						"mac_auth_protocol": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled.",
							MarkdownDescription: "if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"pap",
									"eap-peap",
									"eap-md5",
								),
							},
							Default: stringdefault.StaticString("eap-md5"),
						},
						"mac_limit": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform",
							MarkdownDescription: "Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform",
							Validators: []validator.Int64{
								int64validator.AtLeast(0),
							},
							Default: int64default.StaticInt64(0),
						},
						"mode": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "`mode`==`dynamic` must only be used with the port usage with the name `dynamic`",
							MarkdownDescription: "`mode`==`dynamic` must only be used with the port usage with the name `dynamic`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"access",
									"trunk",
									"inet",
									"dynamic",
								),
							},
						},
						"mtu": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.",
							MarkdownDescription: "Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.",
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`==`trunk`, the list of network/vlans",
							MarkdownDescription: "Only if `mode`==`trunk`, the list of network/vlans",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"persist_mac": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses",
							Default:             booldefault.StaticBool(false),
						},
						"poe_disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port",
							MarkdownDescription: "Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port",
							Default:             booldefault.StaticBool(false),
						},
						"port_auth": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x",
							MarkdownDescription: "Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x",
						},
						"port_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` native network/vlan for untagged traffic",
							MarkdownDescription: "Only if `mode`!=`dynamic` native network/vlan for untagged traffic",
						},
						"reauth_interval": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range",
							Validators: []validator.Int64{
								int64validator.Between(10, 65535),
							},
							Default: int64default.StaticInt64(3600),
						},
						"rejected_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails",
						},
						"reset_default_when": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage\nConfiguring to none will let the DPC port keep at the current port usage.",
							MarkdownDescription: "Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage\nConfiguring to none will let the DPC port keep at the current port usage.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"none",
									"link_down",
								),
							},
							Default: stringdefault.StaticString("link_down"),
						},
						"rules": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"equals": schema.StringAttribute{
										Optional: true,
										Computed: true,
									},
									"equals_any": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Computed:            true,
										Description:         "use `equals_any` to match any item in a list",
										MarkdownDescription: "use `equals_any` to match any item in a list",
										Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
									},
									"expression": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "\"[0:3]\":\"abcdef\" -> \"abc\"\n\"split(.)[1]\": \"a.b.c\" -> \"b\"\n\"split(-)[1][0:3]: \"a1234-b5678-c90\" -> \"b56\"",
										MarkdownDescription: "\"[0:3]\":\"abcdef\" -> \"abc\"\n\"split(.)[1]\": \"a.b.c\" -> \"b\"\n\"split(-)[1][0:3]: \"a1234-b5678-c90\" -> \"b56\"",
									},
									"src": schema.StringAttribute{
										Required: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"lldp_chassis_id",
												"lldp_system_name",
												"lldp_serial_number",
												"lldp_hardware_revision",
												"lldp_manufacturer_name",
												"lldp_oui",
												"radius_username",
												"radius_usermac",
												"radius_dynamicfilter",
												"link_peermac",
											),
										},
									},
									"usage": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "`port_usage` name",
										MarkdownDescription: "`port_usage` name",
									},
								},
								CustomType: RulesType{
									ObjectType: types.ObjectType{
										AttrTypes: RulesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`==`dynamic`",
							MarkdownDescription: "Only if `mode`==`dynamic`",
						},
						"speed": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed",
							MarkdownDescription: "Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed",
						},
						"storm_control": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"no_broadcast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on broadcast traffic",
									MarkdownDescription: "whether to disable storm control on broadcast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"no_multicast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on multicast traffic",
									MarkdownDescription: "whether to disable storm control on multicast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"no_registered_multicast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on registered multicast traffic",
									MarkdownDescription: "whether to disable storm control on registered multicast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"no_unknown_unicast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on unknown unicast traffic",
									MarkdownDescription: "whether to disable storm control on unknown unicast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"percentage": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									MarkdownDescription: "bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									Validators: []validator.Int64{
										int64validator.Between(0, 100),
									},
									Default: int64default.StaticInt64(80),
								},
							},
							CustomType: StormControlType{
								ObjectType: types.ObjectType{
									AttrTypes: StormControlValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Switch storm control\nOnly if `mode`!=`dynamic`",
							MarkdownDescription: "Switch storm control\nOnly if `mode`!=`dynamic`",
						},
						"stp_edge": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames",
							MarkdownDescription: "Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames",
							Default:             booldefault.StaticBool(false),
						},
						"voip_network": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
							MarkdownDescription: "Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
						},
					},
					CustomType: PortUsagesType{
						ObjectType: types.ObjectType{
							AttrTypes: PortUsagesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
				Computed: true,
			},
			"radius_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"acct_interim_interval": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						MarkdownDescription: "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						Validators: []validator.Int64{
							int64validator.Between(0, 65535),
						},
						Default: int64default.StaticInt64(0),
					},
					"acct_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "ip / hostname of RADIUS server",
									MarkdownDescription: "ip / hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"hex",
											"ascii",
										),
									},
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"port": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Acct port of RADIUS server",
									MarkdownDescription: "Acct port of RADIUS server",
									Default:             int64default.StaticInt64(1813),
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Description:         "secret of RADIUS server",
									MarkdownDescription: "secret of RADIUS server",
								},
							},
							CustomType: AcctServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
						Validators: []validator.List{
							listvalidator.UniqueValues(),
						},
					},
					"auth_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "ip / hostname of RADIUS server",
									MarkdownDescription: "ip / hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"hex",
											"ascii",
										),
									},
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"port": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Auth port of RADIUS server",
									MarkdownDescription: "Auth port of RADIUS server",
									Default:             int64default.StaticInt64(1812),
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Description:         "secret of RADIUS server",
									MarkdownDescription: "secret of RADIUS server",
								},
							},
							CustomType: AuthServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							listvalidator.UniqueValues(),
						},
					},
					"auth_servers_retries": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "radius auth session retries",
						MarkdownDescription: "radius auth session retries",
						Default:             int64default.StaticInt64(3),
					},
					"auth_servers_timeout": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "radius auth session timeout",
						MarkdownDescription: "radius auth session timeout",
						Default:             int64default.StaticInt64(5),
					},
					"coa_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"coa_port": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(3799),
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "use `network`or `source_ip`\nwhich network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
						MarkdownDescription: "use `network`or `source_ip`\nwhich network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
					},
					"source_ip": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "use `network`or `source_ip`",
						MarkdownDescription: "use `network`or `source_ip`",
					},
				},
				CustomType: RadiusConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Junos Radius config",
				MarkdownDescription: "Junos Radius config",
			},
			"role": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"access",
						"aggregation",
					),
				},
				Default: stringdefault.StaticString("access"),
			},
			"router_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "used for OSPF / BGP / EVPN",
				MarkdownDescription: "used for OSPF / BGP / EVPN",
			},
			"site_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"stp_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"rstp",
								"vstp",
							),
						},
						Default: stringdefault.StaticString("rstp"),
					},
				},
				CustomType: StpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: StpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"switch_mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"config_revert_timer": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "rollback timer for commit confirmed",
						MarkdownDescription: "rollback timer for commit confirmed",
						Validators: []validator.Int64{
							int64validator.Between(1, 30),
						},
						Default: int64default.StaticInt64(10),
					},
					"protect_re": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allowed_services": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "optionally, services we'll allow",
								MarkdownDescription: "optionally, services we'll allow",
								Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
							},
							"custom": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"port_range": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "matched dst port, \"0\" means any",
											MarkdownDescription: "matched dst port, \"0\" means any",
											Default:             stringdefault.StaticString("0"),
										},
										"protocol": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"tcp",
													"udp",
													"icmp",
													"any",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
										"subnet": schema.ListAttribute{
											ElementType: types.StringType,
											Optional:    true,
											Computed:    true,
											Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
										},
									},
									CustomType: CustomType{
										ObjectType: types.ObjectType{
											AttrTypes: CustomValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "when enabled, all traffic that is not essential to our operation will be dropped\ne.g. ntp / dns / traffic to mist will be allowed by default\n     if dhcpd is enabled, we'll make sure it works",
								MarkdownDescription: "when enabled, all traffic that is not essential to our operation will be dropped\ne.g. ntp / dns / traffic to mist will be allowed by default\n     if dhcpd is enabled, we'll make sure it works",
								Default:             booldefault.StaticBool(false),
							},
							"trusted_hosts": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "host/subnets we'll allow traffic to/from",
								MarkdownDescription: "host/subnets we'll allow traffic to/from",
								Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
							},
						},
						CustomType: ProtectReType{
							ObjectType: types.ObjectType{
								AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "restrict inbound-traffic to host\nwhen enabled, all traffic that is not essential to our operation will be dropped \ne.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works",
						MarkdownDescription: "restrict inbound-traffic to host\nwhen enabled, all traffic that is not essential to our operation will be dropped \ne.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works",
					},
				},
				CustomType: SwitchMgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchMgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"use_router_id_as_source_ip": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to use it for snmp / syslog / tacplus / radius",
				MarkdownDescription: "whether to use it for snmp / syslog / tacplus / radius",
				Default:             booldefault.StaticBool(false),
			},
			"vars": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "a dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
				MarkdownDescription: "a dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
			},
			"virtual_chassis": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"members": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"mac": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "fpc0, same as the mac of device_id",
									MarkdownDescription: "fpc0, same as the mac of device_id",
								},
								"vc_role": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Both vc_role master and backup will be matched to routing-engine role in Junos preprovisioned VC config",
									MarkdownDescription: "Both vc_role master and backup will be matched to routing-engine role in Junos preprovisioned VC config",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"master",
											"linecard",
											"backup",
										),
									},
								},
							},
							CustomType: MembersType{
								ObjectType: types.ObjectType{
									AttrTypes: MembersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "list of Virtual Chassis members",
						MarkdownDescription: "list of Virtual Chassis members",
					},
					"preprovisioned": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "to configure whether the VC is preprovisioned or nonprovisioned",
						MarkdownDescription: "to configure whether the VC is preprovisioned or nonprovisioned",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: VirtualChassisType{
					ObjectType: types.ObjectType{
						AttrTypes: VirtualChassisValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "required for preprovisioned Virtual Chassis",
				MarkdownDescription: "required for preprovisioned Virtual Chassis",
			},
			"vrf_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to enable VRF (when supported on the device)",
						MarkdownDescription: "whether to enable VRF (when supported on the device)",
					},
				},
				CustomType: VrfConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: VrfConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"vrrp_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"groups": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"priority": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
							},
							CustomType: GroupsType{
								ObjectType: types.ObjectType{
									AttrTypes: GroupsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Property key is the VRRP name",
						MarkdownDescription: "Property key is the VRRP name",
					},
				},
				CustomType: VrrpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: VrrpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Junos VRRP config",
				MarkdownDescription: "Junos VRRP config",
			},
		},
	}
}

type DeviceSwitchModel struct {
	AclPolicies           types.List          `tfsdk:"acl_policies"`
	AclTags               types.Map           `tfsdk:"acl_tags"`
	AdditionalConfigCmds  types.List          `tfsdk:"additional_config_cmds"`
	DeviceprofileId       types.String        `tfsdk:"deviceprofile_id"`
	DhcpConfig            DhcpConfigValue     `tfsdk:"dhcp_config"`
	DhcpSnooping          DhcpSnoopingValue   `tfsdk:"dhcp_snooping"`
	DisableAutoConfig     types.Bool          `tfsdk:"disable_auto_config"`
	DnsServers            types.List          `tfsdk:"dns_servers"`
	DnsSuffix             types.List          `tfsdk:"dns_suffix"`
	EvpnConfig            EvpnConfigValue     `tfsdk:"evpn_config"`
	ExtraRoutes           types.Map           `tfsdk:"extra_routes"`
	ExtraRoutes6          types.Map           `tfsdk:"extra_routes6"`
	Id                    types.String        `tfsdk:"id"`
	Image1Url             types.String        `tfsdk:"image1_url"`
	Image2Url             types.String        `tfsdk:"image2_url"`
	Image3Url             types.String        `tfsdk:"image3_url"`
	IpConfig              IpConfigValue       `tfsdk:"ip_config"`
	Managed               types.Bool          `tfsdk:"managed"`
	Name                  types.String        `tfsdk:"name"`
	Networks              types.Map           `tfsdk:"networks"`
	Notes                 types.String        `tfsdk:"notes"`
	NtpServers            types.List          `tfsdk:"ntp_servers"`
	OobIpConfig           types.Map           `tfsdk:"oob_ip_config"`
	OrgId                 types.String        `tfsdk:"org_id"`
	OspfConfig            OspfConfigValue     `tfsdk:"ospf_config"`
	OtherIpConfigs        types.Map           `tfsdk:"other_ip_configs"`
	PortConfig            types.Map           `tfsdk:"port_config"`
	PortMirroring         types.Map           `tfsdk:"port_mirroring"`
	PortUsages            types.Map           `tfsdk:"port_usages"`
	RadiusConfig          RadiusConfigValue   `tfsdk:"radius_config"`
	Role                  types.String        `tfsdk:"role"`
	RouterId              types.String        `tfsdk:"router_id"`
	SiteId                types.String        `tfsdk:"site_id"`
	StpConfig             StpConfigValue      `tfsdk:"stp_config"`
	SwitchMgmt            SwitchMgmtValue     `tfsdk:"switch_mgmt"`
	UseRouterIdAsSourceIp types.Bool          `tfsdk:"use_router_id_as_source_ip"`
	Vars                  types.Map           `tfsdk:"vars"`
	VirtualChassis        VirtualChassisValue `tfsdk:"virtual_chassis"`
	VrfConfig             VrfConfigValue      `tfsdk:"vrf_config"`
	VrrpConfig            VrrpConfigValue     `tfsdk:"vrrp_config"`
}

var _ basetypes.ObjectTypable = AclPoliciesType{}

type AclPoliciesType struct {
	basetypes.ObjectType
}

func (t AclPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(AclPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AclPoliciesType) String() string {
	return "AclPoliciesType"
}

func (t AclPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionsAttribute, ok := attributes["actions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`actions is missing from object`)

		return nil, diags
	}

	actionsVal, ok := actionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`actions expected to be basetypes.ListValue, was: %T`, actionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	srcTagsAttribute, ok := attributes["src_tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_tags is missing from object`)

		return nil, diags
	}

	srcTagsVal, ok := srcTagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_tags expected to be basetypes.ListValue, was: %T`, srcTagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AclPoliciesValue{
		Actions: actionsVal,
		Name:    nameVal,
		SrcTags: srcTagsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAclPoliciesValueNull() AclPoliciesValue {
	return AclPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewAclPoliciesValueUnknown() AclPoliciesValue {
	return AclPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAclPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AclPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AclPoliciesValue Attribute Value",
				"While creating a AclPoliciesValue value, a missing attribute value was detected. "+
					"A AclPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AclPoliciesValue Attribute Type",
				"While creating a AclPoliciesValue value, an invalid attribute value was detected. "+
					"A AclPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AclPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AclPoliciesValue Attribute Value",
				"While creating a AclPoliciesValue value, an extra attribute value was detected. "+
					"A AclPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AclPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAclPoliciesValueUnknown(), diags
	}

	actionsAttribute, ok := attributes["actions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`actions is missing from object`)

		return NewAclPoliciesValueUnknown(), diags
	}

	actionsVal, ok := actionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`actions expected to be basetypes.ListValue, was: %T`, actionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAclPoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	srcTagsAttribute, ok := attributes["src_tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_tags is missing from object`)

		return NewAclPoliciesValueUnknown(), diags
	}

	srcTagsVal, ok := srcTagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_tags expected to be basetypes.ListValue, was: %T`, srcTagsAttribute))
	}

	if diags.HasError() {
		return NewAclPoliciesValueUnknown(), diags
	}

	return AclPoliciesValue{
		Actions: actionsVal,
		Name:    nameVal,
		SrcTags: srcTagsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAclPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AclPoliciesValue {
	object, diags := NewAclPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAclPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AclPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAclPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAclPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAclPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAclPoliciesValueMust(AclPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AclPoliciesType) ValueType(ctx context.Context) attr.Value {
	return AclPoliciesValue{}
}

var _ basetypes.ObjectValuable = AclPoliciesValue{}

type AclPoliciesValue struct {
	Actions basetypes.ListValue   `tfsdk:"actions"`
	Name    basetypes.StringValue `tfsdk:"name"`
	SrcTags basetypes.ListValue   `tfsdk:"src_tags"`
	state   attr.ValueState
}

func (v AclPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["actions"] = basetypes.ListType{
		ElemType: ActionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src_tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Actions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["actions"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.SrcTags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src_tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AclPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AclPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AclPoliciesValue) String() string {
	return "AclPoliciesValue"
}

func (v AclPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	actions := types.ListValueMust(
		ActionsType{
			basetypes.ObjectType{
				AttrTypes: ActionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Actions.Elements(),
	)

	if v.Actions.IsNull() {
		actions = types.ListNull(
			ActionsType{
				basetypes.ObjectType{
					AttrTypes: ActionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Actions.IsUnknown() {
		actions = types.ListUnknown(
			ActionsType{
				basetypes.ObjectType{
					AttrTypes: ActionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	srcTagsVal, d := types.ListValue(types.StringType, v.SrcTags.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"actions": basetypes.ListType{
				ElemType: ActionsValue{}.Type(ctx),
			},
			"name": basetypes.StringType{},
			"src_tags": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"actions": basetypes.ListType{
			ElemType: ActionsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"src_tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"actions":  actions,
			"name":     v.Name,
			"src_tags": srcTagsVal,
		})

	return objVal, diags
}

func (v AclPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(AclPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Actions.Equal(other.Actions) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.SrcTags.Equal(other.SrcTags) {
		return false
	}

	return true
}

func (v AclPoliciesValue) Type(ctx context.Context) attr.Type {
	return AclPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AclPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"actions": basetypes.ListType{
			ElemType: ActionsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"src_tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ActionsType{}

type ActionsType struct {
	basetypes.ObjectType
}

func (t ActionsType) Equal(o attr.Type) bool {
	other, ok := o.(ActionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionsType) String() string {
	return "ActionsType"
}

func (t ActionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	dstTagAttribute, ok := attributes["dst_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_tag is missing from object`)

		return nil, diags
	}

	dstTagVal, ok := dstTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_tag expected to be basetypes.StringValue, was: %T`, dstTagAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionsValue{
		Action: actionVal,
		DstTag: dstTagVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewActionsValueNull() ActionsValue {
	return ActionsValue{
		state: attr.ValueStateNull,
	}
}

func NewActionsValueUnknown() ActionsValue {
	return ActionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionsValue Attribute Value",
				"While creating a ActionsValue value, a missing attribute value was detected. "+
					"A ActionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionsValue Attribute Type",
				"While creating a ActionsValue value, an invalid attribute value was detected. "+
					"A ActionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionsValue Attribute Value",
				"While creating a ActionsValue value, an extra attribute value was detected. "+
					"A ActionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionsValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewActionsValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	dstTagAttribute, ok := attributes["dst_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_tag is missing from object`)

		return NewActionsValueUnknown(), diags
	}

	dstTagVal, ok := dstTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_tag expected to be basetypes.StringValue, was: %T`, dstTagAttribute))
	}

	if diags.HasError() {
		return NewActionsValueUnknown(), diags
	}

	return ActionsValue{
		Action: actionVal,
		DstTag: dstTagVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewActionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionsValue {
	object, diags := NewActionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionsValueMust(ActionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionsType) ValueType(ctx context.Context) attr.Value {
	return ActionsValue{}
}

var _ basetypes.ObjectValuable = ActionsValue{}

type ActionsValue struct {
	Action basetypes.StringValue `tfsdk:"action"`
	DstTag basetypes.StringValue `tfsdk:"dst_tag"`
	state  attr.ValueState
}

func (v ActionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dst_tag"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.DstTag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dst_tag"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionsValue) String() string {
	return "ActionsValue"
}

func (v ActionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"action":  basetypes.StringType{},
		"dst_tag": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":  v.Action,
			"dst_tag": v.DstTag,
		})

	return objVal, diags
}

func (v ActionsValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.DstTag.Equal(other.DstTag) {
		return false
	}

	return true
}

func (v ActionsValue) Type(ctx context.Context) attr.Type {
	return ActionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action":  basetypes.StringType{},
		"dst_tag": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AclTagsType{}

type AclTagsType struct {
	basetypes.ObjectType
}

func (t AclTagsType) Equal(o attr.Type) bool {
	other, ok := o.(AclTagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AclTagsType) String() string {
	return "AclTagsType"
}

func (t AclTagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gbpTagAttribute, ok := attributes["gbp_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gbp_tag is missing from object`)

		return nil, diags
	}

	gbpTagVal, ok := gbpTagAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gbp_tag expected to be basetypes.Int64Value, was: %T`, gbpTagAttribute))
	}

	macsAttribute, ok := attributes["macs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`macs is missing from object`)

		return nil, diags
	}

	macsVal, ok := macsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`macs expected to be basetypes.ListValue, was: %T`, macsAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	radiusGroupAttribute, ok := attributes["radius_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_group is missing from object`)

		return nil, diags
	}

	radiusGroupVal, ok := radiusGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_group expected to be basetypes.StringValue, was: %T`, radiusGroupAttribute))
	}

	specsAttribute, ok := attributes["specs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`specs is missing from object`)

		return nil, diags
	}

	specsVal, ok := specsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`specs expected to be basetypes.ListValue, was: %T`, specsAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AclTagsValue{
		GbpTag:      gbpTagVal,
		Macs:        macsVal,
		Network:     networkVal,
		RadiusGroup: radiusGroupVal,
		Specs:       specsVal,
		Subnets:     subnetsVal,
		AclTagsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAclTagsValueNull() AclTagsValue {
	return AclTagsValue{
		state: attr.ValueStateNull,
	}
}

func NewAclTagsValueUnknown() AclTagsValue {
	return AclTagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAclTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AclTagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AclTagsValue Attribute Value",
				"While creating a AclTagsValue value, a missing attribute value was detected. "+
					"A AclTagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclTagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AclTagsValue Attribute Type",
				"While creating a AclTagsValue value, an invalid attribute value was detected. "+
					"A AclTagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclTagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AclTagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AclTagsValue Attribute Value",
				"While creating a AclTagsValue value, an extra attribute value was detected. "+
					"A AclTagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AclTagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAclTagsValueUnknown(), diags
	}

	gbpTagAttribute, ok := attributes["gbp_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gbp_tag is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	gbpTagVal, ok := gbpTagAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gbp_tag expected to be basetypes.Int64Value, was: %T`, gbpTagAttribute))
	}

	macsAttribute, ok := attributes["macs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`macs is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	macsVal, ok := macsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`macs expected to be basetypes.ListValue, was: %T`, macsAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	radiusGroupAttribute, ok := attributes["radius_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_group is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	radiusGroupVal, ok := radiusGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_group expected to be basetypes.StringValue, was: %T`, radiusGroupAttribute))
	}

	specsAttribute, ok := attributes["specs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`specs is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	specsVal, ok := specsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`specs expected to be basetypes.ListValue, was: %T`, specsAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAclTagsValueUnknown(), diags
	}

	return AclTagsValue{
		GbpTag:      gbpTagVal,
		Macs:        macsVal,
		Network:     networkVal,
		RadiusGroup: radiusGroupVal,
		Specs:       specsVal,
		Subnets:     subnetsVal,
		AclTagsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAclTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AclTagsValue {
	object, diags := NewAclTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAclTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AclTagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAclTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAclTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAclTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAclTagsValueMust(AclTagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AclTagsType) ValueType(ctx context.Context) attr.Value {
	return AclTagsValue{}
}

var _ basetypes.ObjectValuable = AclTagsValue{}

type AclTagsValue struct {
	GbpTag      basetypes.Int64Value  `tfsdk:"gbp_tag"`
	Macs        basetypes.ListValue   `tfsdk:"macs"`
	Network     basetypes.StringValue `tfsdk:"network"`
	RadiusGroup basetypes.StringValue `tfsdk:"radius_group"`
	Specs       basetypes.ListValue   `tfsdk:"specs"`
	Subnets     basetypes.ListValue   `tfsdk:"subnets"`
	AclTagsType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v AclTagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["gbp_tag"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["macs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["radius_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["specs"] = basetypes.ListType{
		ElemType: SpecsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.GbpTag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gbp_tag"] = val

		val, err = v.Macs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["macs"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.RadiusGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius_group"] = val

		val, err = v.Specs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["specs"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.AclTagsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AclTagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AclTagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AclTagsValue) String() string {
	return "AclTagsValue"
}

func (v AclTagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	specs := types.ListValueMust(
		SpecsType{
			basetypes.ObjectType{
				AttrTypes: SpecsValue{}.AttributeTypes(ctx),
			},
		},
		v.Specs.Elements(),
	)

	if v.Specs.IsNull() {
		specs = types.ListNull(
			SpecsType{
				basetypes.ObjectType{
					AttrTypes: SpecsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Specs.IsUnknown() {
		specs = types.ListUnknown(
			SpecsType{
				basetypes.ObjectType{
					AttrTypes: SpecsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	macsVal, d := types.ListValue(types.StringType, v.Macs.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"gbp_tag": basetypes.Int64Type{},
			"macs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network":      basetypes.StringType{},
			"radius_group": basetypes.StringType{},
			"specs": basetypes.ListType{
				ElemType: SpecsValue{}.Type(ctx),
			},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	subnetsVal, d := types.ListValue(types.StringType, v.Subnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"gbp_tag": basetypes.Int64Type{},
			"macs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network":      basetypes.StringType{},
			"radius_group": basetypes.StringType{},
			"specs": basetypes.ListType{
				ElemType: SpecsValue{}.Type(ctx),
			},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"gbp_tag": basetypes.Int64Type{},
		"macs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network":      basetypes.StringType{},
		"radius_group": basetypes.StringType{},
		"specs": basetypes.ListType{
			ElemType: SpecsValue{}.Type(ctx),
		},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gbp_tag":      v.GbpTag,
			"macs":         macsVal,
			"network":      v.Network,
			"radius_group": v.RadiusGroup,
			"specs":        specs,
			"subnets":      subnetsVal,
			"type":         v.AclTagsType,
		})

	return objVal, diags
}

func (v AclTagsValue) Equal(o attr.Value) bool {
	other, ok := o.(AclTagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.GbpTag.Equal(other.GbpTag) {
		return false
	}

	if !v.Macs.Equal(other.Macs) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.RadiusGroup.Equal(other.RadiusGroup) {
		return false
	}

	if !v.Specs.Equal(other.Specs) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.AclTagsType.Equal(other.AclTagsType) {
		return false
	}

	return true
}

func (v AclTagsValue) Type(ctx context.Context) attr.Type {
	return AclTagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AclTagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gbp_tag": basetypes.Int64Type{},
		"macs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network":      basetypes.StringType{},
		"radius_group": basetypes.StringType{},
		"specs": basetypes.ListType{
			ElemType: SpecsValue{}.Type(ctx),
		},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecsType{}

type SpecsType struct {
	basetypes.ObjectType
}

func (t SpecsType) Equal(o attr.Type) bool {
	other, ok := o.(SpecsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecsType) String() string {
	return "SpecsType"
}

func (t SpecsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return nil, diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecsValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecsValueNull() SpecsValue {
	return SpecsValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecsValueUnknown() SpecsValue {
	return SpecsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecsValue Attribute Value",
				"While creating a SpecsValue value, a missing attribute value was detected. "+
					"A SpecsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecsValue Attribute Type",
				"While creating a SpecsValue value, an invalid attribute value was detected. "+
					"A SpecsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecsValue Attribute Value",
				"While creating a SpecsValue value, an extra attribute value was detected. "+
					"A SpecsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecsValueUnknown(), diags
	}

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return NewSpecsValueUnknown(), diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewSpecsValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return NewSpecsValueUnknown(), diags
	}

	return SpecsValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecsValue {
	object, diags := NewSpecsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecsValueMust(SpecsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecsType) ValueType(ctx context.Context) attr.Value {
	return SpecsValue{}
}

var _ basetypes.ObjectValuable = SpecsValue{}

type SpecsValue struct {
	PortRange basetypes.StringValue `tfsdk:"port_range"`
	Protocol  basetypes.StringValue `tfsdk:"protocol"`
	state     attr.ValueState
}

func (v SpecsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecsValue) String() string {
	return "SpecsValue"
}

func (v SpecsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_range": v.PortRange,
			"protocol":   v.Protocol,
		})

	return objVal, diags
}

func (v SpecsValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortRange.Equal(other.PortRange) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	return true
}

func (v SpecsValue) Type(ctx context.Context) attr.Type {
	return SpecsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DhcpConfigType{}

type DhcpConfigType struct {
	basetypes.ObjectType
}

func (t DhcpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpConfigType) String() string {
	return "DhcpConfigType"
}

func (t DhcpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return nil, diags
	}

	configVal, ok := configAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.MapValue, was: %T`, configAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpConfigValue{
		Config:  configVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpConfigValueNull() DhcpConfigValue {
	return DhcpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpConfigValueUnknown() DhcpConfigValue {
	return DhcpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpConfigValue Attribute Value",
				"While creating a DhcpConfigValue value, a missing attribute value was detected. "+
					"A DhcpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpConfigValue Attribute Type",
				"While creating a DhcpConfigValue value, an invalid attribute value was detected. "+
					"A DhcpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpConfigValue Attribute Value",
				"While creating a DhcpConfigValue value, an extra attribute value was detected. "+
					"A DhcpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpConfigValueUnknown(), diags
	}

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return NewDhcpConfigValueUnknown(), diags
	}

	configVal, ok := configAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.MapValue, was: %T`, configAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDhcpConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewDhcpConfigValueUnknown(), diags
	}

	return DhcpConfigValue{
		Config:  configVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpConfigValue {
	object, diags := NewDhcpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpConfigValueMust(DhcpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpConfigType) ValueType(ctx context.Context) attr.Value {
	return DhcpConfigValue{}
}

var _ basetypes.ObjectValuable = DhcpConfigValue{}

type DhcpConfigValue struct {
	Config  basetypes.MapValue  `tfsdk:"config"`
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v DhcpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["config"] = basetypes.MapType{
		ElemType: ConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Config.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpConfigValue) String() string {
	return "DhcpConfigValue"
}

func (v DhcpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	config := types.MapValueMust(
		ConfigType{
			basetypes.ObjectType{
				AttrTypes: ConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.Config.Elements(),
	)

	if v.Config.IsNull() {
		config = types.MapNull(
			ConfigType{
				basetypes.ObjectType{
					AttrTypes: ConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Config.IsUnknown() {
		config = types.MapUnknown(
			ConfigType{
				basetypes.ObjectType{
					AttrTypes: ConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"config": basetypes.MapType{
			ElemType: ConfigValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"config":  config,
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v DhcpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Config.Equal(other.Config) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v DhcpConfigValue) Type(ctx context.Context) attr.Type {
	return DhcpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config": basetypes.MapType{
			ElemType: ConfigValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ConfigType{}

type ConfigType struct {
	basetypes.ObjectType
}

func (t ConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigType) String() string {
	return "ConfigType"
}

func (t ConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsServersAttribute, ok := attributes["dns_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_servers is missing from object`)

		return nil, diags
	}

	dnsServersVal, ok := dnsServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_servers expected to be basetypes.ListValue, was: %T`, dnsServersAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	fixedBindingsAttribute, ok := attributes["fixed_bindings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_bindings is missing from object`)

		return nil, diags
	}

	fixedBindingsVal, ok := fixedBindingsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_bindings expected to be basetypes.MapValue, was: %T`, fixedBindingsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipEndAttribute, ok := attributes["ip_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end is missing from object`)

		return nil, diags
	}

	ipEndVal, ok := ipEndAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end expected to be basetypes.StringValue, was: %T`, ipEndAttribute))
	}

	ipEnd6Attribute, ok := attributes["ip_end6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end6 is missing from object`)

		return nil, diags
	}

	ipEnd6Val, ok := ipEnd6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end6 expected to be basetypes.StringValue, was: %T`, ipEnd6Attribute))
	}

	ipStartAttribute, ok := attributes["ip_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start is missing from object`)

		return nil, diags
	}

	ipStartVal, ok := ipStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start expected to be basetypes.StringValue, was: %T`, ipStartAttribute))
	}

	ipStart6Attribute, ok := attributes["ip_start6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start6 is missing from object`)

		return nil, diags
	}

	ipStart6Val, ok := ipStart6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start6 expected to be basetypes.StringValue, was: %T`, ipStart6Attribute))
	}

	leaseTimeAttribute, ok := attributes["lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lease_time is missing from object`)

		return nil, diags
	}

	leaseTimeVal, ok := leaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lease_time expected to be basetypes.Int64Value, was: %T`, leaseTimeAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return nil, diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	serverIdOverrideAttribute, ok := attributes["server_id_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id_override is missing from object`)

		return nil, diags
	}

	serverIdOverrideVal, ok := serverIdOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id_override expected to be basetypes.BoolValue, was: %T`, serverIdOverrideAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	servers6Attribute, ok := attributes["servers6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers6 is missing from object`)

		return nil, diags
	}

	servers6Val, ok := servers6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers6 expected to be basetypes.ListValue, was: %T`, servers6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return nil, diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vendorEncapulatedAttribute, ok := attributes["vendor_encapulated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_encapulated is missing from object`)

		return nil, diags
	}

	vendorEncapulatedVal, ok := vendorEncapulatedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_encapulated expected to be basetypes.MapValue, was: %T`, vendorEncapulatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigValue{
		DnsServers:        dnsServersVal,
		DnsSuffix:         dnsSuffixVal,
		FixedBindings:     fixedBindingsVal,
		Gateway:           gatewayVal,
		IpEnd:             ipEndVal,
		IpEnd6:            ipEnd6Val,
		IpStart:           ipStartVal,
		IpStart6:          ipStart6Val,
		LeaseTime:         leaseTimeVal,
		Options:           optionsVal,
		ServerIdOverride:  serverIdOverrideVal,
		Servers:           serversVal,
		Servers6:          servers6Val,
		ConfigType:        typeVal,
		Type6:             type6Val,
		VendorEncapulated: vendorEncapulatedVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewConfigValueNull() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigValueUnknown() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigValue Attribute Value",
				"While creating a ConfigValue value, a missing attribute value was detected. "+
					"A ConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigValue Attribute Type",
				"While creating a ConfigValue value, an invalid attribute value was detected. "+
					"A ConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigValue Attribute Value",
				"While creating a ConfigValue value, an extra attribute value was detected. "+
					"A ConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	dnsServersAttribute, ok := attributes["dns_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_servers is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dnsServersVal, ok := dnsServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_servers expected to be basetypes.ListValue, was: %T`, dnsServersAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	fixedBindingsAttribute, ok := attributes["fixed_bindings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_bindings is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	fixedBindingsVal, ok := fixedBindingsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_bindings expected to be basetypes.MapValue, was: %T`, fixedBindingsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipEndAttribute, ok := attributes["ip_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipEndVal, ok := ipEndAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end expected to be basetypes.StringValue, was: %T`, ipEndAttribute))
	}

	ipEnd6Attribute, ok := attributes["ip_end6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipEnd6Val, ok := ipEnd6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end6 expected to be basetypes.StringValue, was: %T`, ipEnd6Attribute))
	}

	ipStartAttribute, ok := attributes["ip_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipStartVal, ok := ipStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start expected to be basetypes.StringValue, was: %T`, ipStartAttribute))
	}

	ipStart6Attribute, ok := attributes["ip_start6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipStart6Val, ok := ipStart6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start6 expected to be basetypes.StringValue, was: %T`, ipStart6Attribute))
	}

	leaseTimeAttribute, ok := attributes["lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lease_time is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	leaseTimeVal, ok := leaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lease_time expected to be basetypes.Int64Value, was: %T`, leaseTimeAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	serverIdOverrideAttribute, ok := attributes["server_id_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id_override is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	serverIdOverrideVal, ok := serverIdOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id_override expected to be basetypes.BoolValue, was: %T`, serverIdOverrideAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	servers6Attribute, ok := attributes["servers6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	servers6Val, ok := servers6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers6 expected to be basetypes.ListValue, was: %T`, servers6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vendorEncapulatedAttribute, ok := attributes["vendor_encapulated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_encapulated is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	vendorEncapulatedVal, ok := vendorEncapulatedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_encapulated expected to be basetypes.MapValue, was: %T`, vendorEncapulatedAttribute))
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	return ConfigValue{
		DnsServers:        dnsServersVal,
		DnsSuffix:         dnsSuffixVal,
		FixedBindings:     fixedBindingsVal,
		Gateway:           gatewayVal,
		IpEnd:             ipEndVal,
		IpEnd6:            ipEnd6Val,
		IpStart:           ipStartVal,
		IpStart6:          ipStart6Val,
		LeaseTime:         leaseTimeVal,
		Options:           optionsVal,
		ServerIdOverride:  serverIdOverrideVal,
		Servers:           serversVal,
		Servers6:          servers6Val,
		ConfigType:        typeVal,
		Type6:             type6Val,
		VendorEncapulated: vendorEncapulatedVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigValue {
	object, diags := NewConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigValueMust(ConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigType) ValueType(ctx context.Context) attr.Value {
	return ConfigValue{}
}

var _ basetypes.ObjectValuable = ConfigValue{}

type ConfigValue struct {
	DnsServers        basetypes.ListValue   `tfsdk:"dns_servers"`
	DnsSuffix         basetypes.ListValue   `tfsdk:"dns_suffix"`
	FixedBindings     basetypes.MapValue    `tfsdk:"fixed_bindings"`
	Gateway           basetypes.StringValue `tfsdk:"gateway"`
	IpEnd             basetypes.StringValue `tfsdk:"ip_end"`
	IpEnd6            basetypes.StringValue `tfsdk:"ip_end6"`
	IpStart           basetypes.StringValue `tfsdk:"ip_start"`
	IpStart6          basetypes.StringValue `tfsdk:"ip_start6"`
	LeaseTime         basetypes.Int64Value  `tfsdk:"lease_time"`
	Options           basetypes.MapValue    `tfsdk:"options"`
	ServerIdOverride  basetypes.BoolValue   `tfsdk:"server_id_override"`
	Servers           basetypes.ListValue   `tfsdk:"servers"`
	Servers6          basetypes.ListValue   `tfsdk:"servers6"`
	ConfigType        basetypes.StringValue `tfsdk:"type"`
	Type6             basetypes.StringValue `tfsdk:"type6"`
	VendorEncapulated basetypes.MapValue    `tfsdk:"vendor_encapulated"`
	state             attr.ValueState
}

func (v ConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["dns_servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["fixed_bindings"] = basetypes.MapType{
		ElemType: FixedBindingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_end"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_end6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_start"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_start6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lease_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["options"] = basetypes.MapType{
		ElemType: OptionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["server_id_override"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["servers6"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vendor_encapulated"] = basetypes.MapType{
		ElemType: VendorEncapulatedValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.DnsServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_servers"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.FixedBindings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_bindings"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.IpEnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_end"] = val

		val, err = v.IpEnd6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_end6"] = val

		val, err = v.IpStart.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_start"] = val

		val, err = v.IpStart6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_start6"] = val

		val, err = v.LeaseTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lease_time"] = val

		val, err = v.Options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options"] = val

		val, err = v.ServerIdOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_id_override"] = val

		val, err = v.Servers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.Servers6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers6"] = val

		val, err = v.ConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Type6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type6"] = val

		val, err = v.VendorEncapulated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vendor_encapulated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigValue) String() string {
	return "ConfigValue"
}

func (v ConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	fixedBindings := types.MapValueMust(
		FixedBindingsType{
			basetypes.ObjectType{
				AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
			},
		},
		v.FixedBindings.Elements(),
	)

	if v.FixedBindings.IsNull() {
		fixedBindings = types.MapNull(
			FixedBindingsType{
				basetypes.ObjectType{
					AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FixedBindings.IsUnknown() {
		fixedBindings = types.MapUnknown(
			FixedBindingsType{
				basetypes.ObjectType{
					AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	options := types.MapValueMust(
		OptionsType{
			basetypes.ObjectType{
				AttrTypes: OptionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Options.Elements(),
	)

	if v.Options.IsNull() {
		options = types.MapNull(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Options.IsUnknown() {
		options = types.MapUnknown(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vendorEncapulated := types.MapValueMust(
		VendorEncapulatedType{
			basetypes.ObjectType{
				AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
			},
		},
		v.VendorEncapulated.Elements(),
	)

	if v.VendorEncapulated.IsNull() {
		vendorEncapulated = types.MapNull(
			VendorEncapulatedType{
				basetypes.ObjectType{
					AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VendorEncapulated.IsUnknown() {
		vendorEncapulated = types.MapUnknown(
			VendorEncapulatedType{
				basetypes.ObjectType{
					AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	dnsServersVal, d := types.ListValue(types.StringType, v.DnsServers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":     basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":   basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":  basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":     basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":   basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":  basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	serversVal, d := types.ListValue(types.StringType, v.Servers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":     basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":   basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":  basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	servers6Val, d := types.ListValue(types.StringType, v.Servers6.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":     basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":   basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":  basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"fixed_bindings": basetypes.MapType{
			ElemType: FixedBindingsValue{}.Type(ctx),
		},
		"gateway":    basetypes.StringType{},
		"ip_end":     basetypes.StringType{},
		"ip_end6":    basetypes.StringType{},
		"ip_start":   basetypes.StringType{},
		"ip_start6":  basetypes.StringType{},
		"lease_time": basetypes.Int64Type{},
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"server_id_override": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"servers6": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type":  basetypes.StringType{},
		"type6": basetypes.StringType{},
		"vendor_encapulated": basetypes.MapType{
			ElemType: VendorEncapulatedValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns_servers":        dnsServersVal,
			"dns_suffix":         dnsSuffixVal,
			"fixed_bindings":     fixedBindings,
			"gateway":            v.Gateway,
			"ip_end":             v.IpEnd,
			"ip_end6":            v.IpEnd6,
			"ip_start":           v.IpStart,
			"ip_start6":          v.IpStart6,
			"lease_time":         v.LeaseTime,
			"options":            options,
			"server_id_override": v.ServerIdOverride,
			"servers":            serversVal,
			"servers6":           servers6Val,
			"type":               v.ConfigType,
			"type6":              v.Type6,
			"vendor_encapulated": vendorEncapulated,
		})

	return objVal, diags
}

func (v ConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DnsServers.Equal(other.DnsServers) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.FixedBindings.Equal(other.FixedBindings) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.IpEnd.Equal(other.IpEnd) {
		return false
	}

	if !v.IpEnd6.Equal(other.IpEnd6) {
		return false
	}

	if !v.IpStart.Equal(other.IpStart) {
		return false
	}

	if !v.IpStart6.Equal(other.IpStart6) {
		return false
	}

	if !v.LeaseTime.Equal(other.LeaseTime) {
		return false
	}

	if !v.Options.Equal(other.Options) {
		return false
	}

	if !v.ServerIdOverride.Equal(other.ServerIdOverride) {
		return false
	}

	if !v.Servers.Equal(other.Servers) {
		return false
	}

	if !v.Servers6.Equal(other.Servers6) {
		return false
	}

	if !v.ConfigType.Equal(other.ConfigType) {
		return false
	}

	if !v.Type6.Equal(other.Type6) {
		return false
	}

	if !v.VendorEncapulated.Equal(other.VendorEncapulated) {
		return false
	}

	return true
}

func (v ConfigValue) Type(ctx context.Context) attr.Type {
	return ConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"fixed_bindings": basetypes.MapType{
			ElemType: FixedBindingsValue{}.Type(ctx),
		},
		"gateway":    basetypes.StringType{},
		"ip_end":     basetypes.StringType{},
		"ip_end6":    basetypes.StringType{},
		"ip_start":   basetypes.StringType{},
		"ip_start6":  basetypes.StringType{},
		"lease_time": basetypes.Int64Type{},
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"server_id_override": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"servers6": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type":  basetypes.StringType{},
		"type6": basetypes.StringType{},
		"vendor_encapulated": basetypes.MapType{
			ElemType: VendorEncapulatedValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = FixedBindingsType{}

type FixedBindingsType struct {
	basetypes.ObjectType
}

func (t FixedBindingsType) Equal(o attr.Type) bool {
	other, ok := o.(FixedBindingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FixedBindingsType) String() string {
	return "FixedBindingsType"
}

func (t FixedBindingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FixedBindingsValue{
		Ip:    ipVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewFixedBindingsValueNull() FixedBindingsValue {
	return FixedBindingsValue{
		state: attr.ValueStateNull,
	}
}

func NewFixedBindingsValueUnknown() FixedBindingsValue {
	return FixedBindingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFixedBindingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FixedBindingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FixedBindingsValue Attribute Value",
				"While creating a FixedBindingsValue value, a missing attribute value was detected. "+
					"A FixedBindingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FixedBindingsValue Attribute Type",
				"While creating a FixedBindingsValue value, an invalid attribute value was detected. "+
					"A FixedBindingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FixedBindingsValue Attribute Value",
				"While creating a FixedBindingsValue value, an extra attribute value was detected. "+
					"A FixedBindingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FixedBindingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFixedBindingsValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewFixedBindingsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFixedBindingsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewFixedBindingsValueUnknown(), diags
	}

	return FixedBindingsValue{
		Ip:    ipVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewFixedBindingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FixedBindingsValue {
	object, diags := NewFixedBindingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFixedBindingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FixedBindingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFixedBindingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFixedBindingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFixedBindingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFixedBindingsValueMust(FixedBindingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FixedBindingsType) ValueType(ctx context.Context) attr.Value {
	return FixedBindingsValue{}
}

var _ basetypes.ObjectValuable = FixedBindingsValue{}

type FixedBindingsValue struct {
	Ip    basetypes.StringValue `tfsdk:"ip"`
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v FixedBindingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FixedBindingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FixedBindingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FixedBindingsValue) String() string {
	return "FixedBindingsValue"
}

func (v FixedBindingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":   v.Ip,
			"name": v.Name,
		})

	return objVal, diags
}

func (v FixedBindingsValue) Equal(o attr.Value) bool {
	other, ok := o.(FixedBindingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v FixedBindingsValue) Type(ctx context.Context) attr.Type {
	return FixedBindingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FixedBindingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		OptionsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		OptionsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	OptionsType basetypes.StringValue `tfsdk:"type"`
	Value       basetypes.StringValue `tfsdk:"value"`
	state       attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.OptionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":  v.OptionsType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OptionsType.Equal(other.OptionsType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VendorEncapulatedType{}

type VendorEncapulatedType struct {
	basetypes.ObjectType
}

func (t VendorEncapulatedType) Equal(o attr.Type) bool {
	other, ok := o.(VendorEncapulatedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VendorEncapulatedType) String() string {
	return "VendorEncapulatedType"
}

func (t VendorEncapulatedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VendorEncapulatedValue{
		VendorEncapulatedType: typeVal,
		Value:                 valueVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVendorEncapulatedValueNull() VendorEncapulatedValue {
	return VendorEncapulatedValue{
		state: attr.ValueStateNull,
	}
}

func NewVendorEncapulatedValueUnknown() VendorEncapulatedValue {
	return VendorEncapulatedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVendorEncapulatedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VendorEncapulatedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VendorEncapulatedValue Attribute Value",
				"While creating a VendorEncapulatedValue value, a missing attribute value was detected. "+
					"A VendorEncapulatedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VendorEncapulatedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VendorEncapulatedValue Attribute Type",
				"While creating a VendorEncapulatedValue value, an invalid attribute value was detected. "+
					"A VendorEncapulatedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VendorEncapulatedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VendorEncapulatedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VendorEncapulatedValue Attribute Value",
				"While creating a VendorEncapulatedValue value, an extra attribute value was detected. "+
					"A VendorEncapulatedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VendorEncapulatedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVendorEncapulatedValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewVendorEncapulatedValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewVendorEncapulatedValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewVendorEncapulatedValueUnknown(), diags
	}

	return VendorEncapulatedValue{
		VendorEncapulatedType: typeVal,
		Value:                 valueVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVendorEncapulatedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VendorEncapulatedValue {
	object, diags := NewVendorEncapulatedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVendorEncapulatedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VendorEncapulatedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVendorEncapulatedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVendorEncapulatedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVendorEncapulatedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVendorEncapulatedValueMust(VendorEncapulatedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VendorEncapulatedType) ValueType(ctx context.Context) attr.Value {
	return VendorEncapulatedValue{}
}

var _ basetypes.ObjectValuable = VendorEncapulatedValue{}

type VendorEncapulatedValue struct {
	VendorEncapulatedType basetypes.StringValue `tfsdk:"type"`
	Value                 basetypes.StringValue `tfsdk:"value"`
	state                 attr.ValueState
}

func (v VendorEncapulatedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.VendorEncapulatedType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VendorEncapulatedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VendorEncapulatedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VendorEncapulatedValue) String() string {
	return "VendorEncapulatedValue"
}

func (v VendorEncapulatedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":  v.VendorEncapulatedType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v VendorEncapulatedValue) Equal(o attr.Value) bool {
	other, ok := o.(VendorEncapulatedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VendorEncapulatedType.Equal(other.VendorEncapulatedType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v VendorEncapulatedValue) Type(ctx context.Context) attr.Type {
	return VendorEncapulatedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VendorEncapulatedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DhcpSnoopingType{}

type DhcpSnoopingType struct {
	basetypes.ObjectType
}

func (t DhcpSnoopingType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpSnoopingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpSnoopingType) String() string {
	return "DhcpSnoopingType"
}

func (t DhcpSnoopingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return nil, diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return nil, diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableIpSourceGuardAttribute, ok := attributes["enable_ip_source_guard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ip_source_guard is missing from object`)

		return nil, diags
	}

	enableIpSourceGuardVal, ok := enableIpSourceGuardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ip_source_guard expected to be basetypes.BoolValue, was: %T`, enableIpSourceGuardAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpSnoopingValue{
		AllNetworks:         allNetworksVal,
		EnableArpSpoofCheck: enableArpSpoofCheckVal,
		EnableIpSourceGuard: enableIpSourceGuardVal,
		Enabled:             enabledVal,
		Networks:            networksVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDhcpSnoopingValueNull() DhcpSnoopingValue {
	return DhcpSnoopingValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpSnoopingValueUnknown() DhcpSnoopingValue {
	return DhcpSnoopingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpSnoopingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpSnoopingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpSnoopingValue Attribute Value",
				"While creating a DhcpSnoopingValue value, a missing attribute value was detected. "+
					"A DhcpSnoopingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpSnoopingValue Attribute Type",
				"While creating a DhcpSnoopingValue value, an invalid attribute value was detected. "+
					"A DhcpSnoopingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpSnoopingValue Attribute Value",
				"While creating a DhcpSnoopingValue value, an extra attribute value was detected. "+
					"A DhcpSnoopingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpSnoopingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpSnoopingValueUnknown(), diags
	}

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableIpSourceGuardAttribute, ok := attributes["enable_ip_source_guard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ip_source_guard is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enableIpSourceGuardVal, ok := enableIpSourceGuardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ip_source_guard expected to be basetypes.BoolValue, was: %T`, enableIpSourceGuardAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewDhcpSnoopingValueUnknown(), diags
	}

	return DhcpSnoopingValue{
		AllNetworks:         allNetworksVal,
		EnableArpSpoofCheck: enableArpSpoofCheckVal,
		EnableIpSourceGuard: enableIpSourceGuardVal,
		Enabled:             enabledVal,
		Networks:            networksVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDhcpSnoopingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpSnoopingValue {
	object, diags := NewDhcpSnoopingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpSnoopingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpSnoopingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpSnoopingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpSnoopingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpSnoopingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpSnoopingValueMust(DhcpSnoopingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpSnoopingType) ValueType(ctx context.Context) attr.Value {
	return DhcpSnoopingValue{}
}

var _ basetypes.ObjectValuable = DhcpSnoopingValue{}

type DhcpSnoopingValue struct {
	AllNetworks         basetypes.BoolValue `tfsdk:"all_networks"`
	EnableArpSpoofCheck basetypes.BoolValue `tfsdk:"enable_arp_spoof_check"`
	EnableIpSourceGuard basetypes.BoolValue `tfsdk:"enable_ip_source_guard"`
	Enabled             basetypes.BoolValue `tfsdk:"enabled"`
	Networks            basetypes.ListValue `tfsdk:"networks"`
	state               attr.ValueState
}

func (v DhcpSnoopingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["all_networks"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_arp_spoof_check"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_ip_source_guard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AllNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["all_networks"] = val

		val, err = v.EnableArpSpoofCheck.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_arp_spoof_check"] = val

		val, err = v.EnableIpSourceGuard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_ip_source_guard"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpSnoopingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpSnoopingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpSnoopingValue) String() string {
	return "DhcpSnoopingValue"
}

func (v DhcpSnoopingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":           basetypes.BoolType{},
			"enable_arp_spoof_check": basetypes.BoolType{},
			"enable_ip_source_guard": basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"all_networks":           basetypes.BoolType{},
		"enable_arp_spoof_check": basetypes.BoolType{},
		"enable_ip_source_guard": basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"all_networks":           v.AllNetworks,
			"enable_arp_spoof_check": v.EnableArpSpoofCheck,
			"enable_ip_source_guard": v.EnableIpSourceGuard,
			"enabled":                v.Enabled,
			"networks":               networksVal,
		})

	return objVal, diags
}

func (v DhcpSnoopingValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpSnoopingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllNetworks.Equal(other.AllNetworks) {
		return false
	}

	if !v.EnableArpSpoofCheck.Equal(other.EnableArpSpoofCheck) {
		return false
	}

	if !v.EnableIpSourceGuard.Equal(other.EnableIpSourceGuard) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v DhcpSnoopingValue) Type(ctx context.Context) attr.Type {
	return DhcpSnoopingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpSnoopingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"all_networks":           basetypes.BoolType{},
		"enable_arp_spoof_check": basetypes.BoolType{},
		"enable_ip_source_guard": basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = EvpnConfigType{}

type EvpnConfigType struct {
	basetypes.ObjectType
}

func (t EvpnConfigType) Equal(o attr.Type) bool {
	other, ok := o.(EvpnConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EvpnConfigType) String() string {
	return "EvpnConfigType"
}

func (t EvpnConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EvpnConfigValue{
		Enabled: enabledVal,
		Role:    roleVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewEvpnConfigValueNull() EvpnConfigValue {
	return EvpnConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewEvpnConfigValueUnknown() EvpnConfigValue {
	return EvpnConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEvpnConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EvpnConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EvpnConfigValue Attribute Value",
				"While creating a EvpnConfigValue value, a missing attribute value was detected. "+
					"A EvpnConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EvpnConfigValue Attribute Type",
				"While creating a EvpnConfigValue value, an invalid attribute value was detected. "+
					"A EvpnConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EvpnConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EvpnConfigValue Attribute Value",
				"While creating a EvpnConfigValue value, an extra attribute value was detected. "+
					"A EvpnConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EvpnConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEvpnConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewEvpnConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewEvpnConfigValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return NewEvpnConfigValueUnknown(), diags
	}

	return EvpnConfigValue{
		Enabled: enabledVal,
		Role:    roleVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewEvpnConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EvpnConfigValue {
	object, diags := NewEvpnConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEvpnConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EvpnConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEvpnConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEvpnConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEvpnConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEvpnConfigValueMust(EvpnConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EvpnConfigType) ValueType(ctx context.Context) attr.Value {
	return EvpnConfigValue{}
}

var _ basetypes.ObjectValuable = EvpnConfigValue{}

type EvpnConfigValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Role    basetypes.StringValue `tfsdk:"role"`
	state   attr.ValueState
}

func (v EvpnConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EvpnConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EvpnConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EvpnConfigValue) String() string {
	return "EvpnConfigValue"
}

func (v EvpnConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"role":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"role":    v.Role,
		})

	return objVal, diags
}

func (v EvpnConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(EvpnConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	return true
}

func (v EvpnConfigValue) Type(ctx context.Context) attr.Type {
	return EvpnConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EvpnConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"role":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutesType{}

type ExtraRoutesType struct {
	basetypes.ObjectType
}

func (t ExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutesType) String() string {
	return "ExtraRoutesType"
}

func (t ExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return nil, diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return nil, diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return nil, diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutesValue{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueNull() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutesValueUnknown() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, a missing attribute value was detected. "+
					"A ExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutesValue Attribute Type",
				"While creating a ExtraRoutesValue value, an invalid attribute value was detected. "+
					"A ExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, an extra attribute value was detected. "+
					"A ExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	return ExtraRoutesValue{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutesValue {
	object, diags := NewExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutesValueMust(ExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = ExtraRoutesValue{}

type ExtraRoutesValue struct {
	Discard       basetypes.BoolValue   `tfsdk:"discard"`
	Metric        basetypes.Int64Value  `tfsdk:"metric"`
	NextQualified basetypes.MapValue    `tfsdk:"next_qualified"`
	NoResolve     basetypes.BoolValue   `tfsdk:"no_resolve"`
	Preference    basetypes.Int64Value  `tfsdk:"preference"`
	Via           basetypes.StringValue `tfsdk:"via"`
	state         attr.ValueState
}

func (v ExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["discard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_qualified"] = basetypes.MapType{
		ElemType: NextQualifiedValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["no_resolve"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Discard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discard"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.NextQualified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_qualified"] = val

		val, err = v.NoResolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_resolve"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutesValue) String() string {
	return "ExtraRoutesValue"
}

func (v ExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	nextQualified := types.MapValueMust(
		NextQualifiedType{
			basetypes.ObjectType{
				AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
			},
		},
		v.NextQualified.Elements(),
	)

	if v.NextQualified.IsNull() {
		nextQualified = types.MapNull(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NextQualified.IsUnknown() {
		nextQualified = types.MapUnknown(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"discard":        v.Discard,
			"metric":         v.Metric,
			"next_qualified": nextQualified,
			"no_resolve":     v.NoResolve,
			"preference":     v.Preference,
			"via":            v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Discard.Equal(other.Discard) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.NextQualified.Equal(other.NextQualified) {
		return false
	}

	if !v.NoResolve.Equal(other.NoResolve) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return ExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NextQualifiedType{}

type NextQualifiedType struct {
	basetypes.ObjectType
}

func (t NextQualifiedType) Equal(o attr.Type) bool {
	other, ok := o.(NextQualifiedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NextQualifiedType) String() string {
	return "NextQualifiedType"
}

func (t NextQualifiedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NextQualifiedValue{
		Metric:     metricVal,
		Preference: preferenceVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNextQualifiedValueNull() NextQualifiedValue {
	return NextQualifiedValue{
		state: attr.ValueStateNull,
	}
}

func NewNextQualifiedValueUnknown() NextQualifiedValue {
	return NextQualifiedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNextQualifiedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NextQualifiedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NextQualifiedValue Attribute Value",
				"While creating a NextQualifiedValue value, a missing attribute value was detected. "+
					"A NextQualifiedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NextQualifiedValue Attribute Type",
				"While creating a NextQualifiedValue value, an invalid attribute value was detected. "+
					"A NextQualifiedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NextQualifiedValue Attribute Value",
				"While creating a NextQualifiedValue value, an extra attribute value was detected. "+
					"A NextQualifiedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NextQualifiedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNextQualifiedValueUnknown(), diags
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewNextQualifiedValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewNextQualifiedValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	if diags.HasError() {
		return NewNextQualifiedValueUnknown(), diags
	}

	return NextQualifiedValue{
		Metric:     metricVal,
		Preference: preferenceVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNextQualifiedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NextQualifiedValue {
	object, diags := NewNextQualifiedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNextQualifiedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NextQualifiedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNextQualifiedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNextQualifiedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNextQualifiedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNextQualifiedValueMust(NextQualifiedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NextQualifiedType) ValueType(ctx context.Context) attr.Value {
	return NextQualifiedValue{}
}

var _ basetypes.ObjectValuable = NextQualifiedValue{}

type NextQualifiedValue struct {
	Metric     basetypes.Int64Value `tfsdk:"metric"`
	Preference basetypes.Int64Value `tfsdk:"preference"`
	state      attr.ValueState
}

func (v NextQualifiedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NextQualifiedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NextQualifiedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NextQualifiedValue) String() string {
	return "NextQualifiedValue"
}

func (v NextQualifiedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"metric":     basetypes.Int64Type{},
		"preference": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"metric":     v.Metric,
			"preference": v.Preference,
		})

	return objVal, diags
}

func (v NextQualifiedValue) Equal(o attr.Value) bool {
	other, ok := o.(NextQualifiedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	return true
}

func (v NextQualifiedValue) Type(ctx context.Context) attr.Type {
	return NextQualifiedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NextQualifiedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"metric":     basetypes.Int64Type{},
		"preference": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutes6Type{}

type ExtraRoutes6Type struct {
	basetypes.ObjectType
}

func (t ExtraRoutes6Type) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutes6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutes6Type) String() string {
	return "ExtraRoutes6Type"
}

func (t ExtraRoutes6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return nil, diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return nil, diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return nil, diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutes6Value{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutes6ValueNull() ExtraRoutes6Value {
	return ExtraRoutes6Value{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutes6ValueUnknown() ExtraRoutes6Value {
	return ExtraRoutes6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutes6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutes6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutes6Value Attribute Value",
				"While creating a ExtraRoutes6Value value, a missing attribute value was detected. "+
					"A ExtraRoutes6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutes6Value Attribute Type",
				"While creating a ExtraRoutes6Value value, an invalid attribute value was detected. "+
					"A ExtraRoutes6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutes6Value Attribute Value",
				"While creating a ExtraRoutes6Value value, an extra attribute value was detected. "+
					"A ExtraRoutes6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutes6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutes6ValueUnknown(), diags
	}

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutes6ValueUnknown(), diags
	}

	return ExtraRoutes6Value{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutes6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutes6Value {
	object, diags := NewExtraRoutes6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutes6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutes6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutes6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutes6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutes6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutes6ValueMust(ExtraRoutes6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutes6Type) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutes6Value{}
}

var _ basetypes.ObjectValuable = ExtraRoutes6Value{}

type ExtraRoutes6Value struct {
	Discard       basetypes.BoolValue   `tfsdk:"discard"`
	Metric        basetypes.Int64Value  `tfsdk:"metric"`
	NextQualified basetypes.MapValue    `tfsdk:"next_qualified"`
	NoResolve     basetypes.BoolValue   `tfsdk:"no_resolve"`
	Preference    basetypes.Int64Value  `tfsdk:"preference"`
	Via           basetypes.StringValue `tfsdk:"via"`
	state         attr.ValueState
}

func (v ExtraRoutes6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["discard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_qualified"] = basetypes.MapType{
		ElemType: NextQualifiedValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["no_resolve"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Discard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discard"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.NextQualified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_qualified"] = val

		val, err = v.NoResolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_resolve"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutes6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutes6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutes6Value) String() string {
	return "ExtraRoutes6Value"
}

func (v ExtraRoutes6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	nextQualified := types.MapValueMust(
		NextQualifiedType{
			basetypes.ObjectType{
				AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
			},
		},
		v.NextQualified.Elements(),
	)

	if v.NextQualified.IsNull() {
		nextQualified = types.MapNull(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NextQualified.IsUnknown() {
		nextQualified = types.MapUnknown(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"discard":        v.Discard,
			"metric":         v.Metric,
			"next_qualified": nextQualified,
			"no_resolve":     v.NoResolve,
			"preference":     v.Preference,
			"via":            v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutes6Value) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutes6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Discard.Equal(other.Discard) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.NextQualified.Equal(other.NextQualified) {
		return false
	}

	if !v.NoResolve.Equal(other.NoResolve) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutes6Value) Type(ctx context.Context) attr.Type {
	return ExtraRoutes6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutes6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NextQualifiedType{}

type NextQualifiedType struct {
	basetypes.ObjectType
}

func (t NextQualifiedType) Equal(o attr.Type) bool {
	other, ok := o.(NextQualifiedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NextQualifiedType) String() string {
	return "NextQualifiedType"
}

func (t NextQualifiedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NextQualifiedValue{
		Metric:     metricVal,
		Preference: preferenceVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNextQualifiedValueNull() NextQualifiedValue {
	return NextQualifiedValue{
		state: attr.ValueStateNull,
	}
}

func NewNextQualifiedValueUnknown() NextQualifiedValue {
	return NextQualifiedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNextQualifiedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NextQualifiedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NextQualifiedValue Attribute Value",
				"While creating a NextQualifiedValue value, a missing attribute value was detected. "+
					"A NextQualifiedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NextQualifiedValue Attribute Type",
				"While creating a NextQualifiedValue value, an invalid attribute value was detected. "+
					"A NextQualifiedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NextQualifiedValue Attribute Value",
				"While creating a NextQualifiedValue value, an extra attribute value was detected. "+
					"A NextQualifiedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NextQualifiedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNextQualifiedValueUnknown(), diags
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewNextQualifiedValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewNextQualifiedValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	if diags.HasError() {
		return NewNextQualifiedValueUnknown(), diags
	}

	return NextQualifiedValue{
		Metric:     metricVal,
		Preference: preferenceVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNextQualifiedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NextQualifiedValue {
	object, diags := NewNextQualifiedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNextQualifiedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NextQualifiedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNextQualifiedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNextQualifiedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNextQualifiedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNextQualifiedValueMust(NextQualifiedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NextQualifiedType) ValueType(ctx context.Context) attr.Value {
	return NextQualifiedValue{}
}

var _ basetypes.ObjectValuable = NextQualifiedValue{}

type NextQualifiedValue struct {
	Metric     basetypes.Int64Value `tfsdk:"metric"`
	Preference basetypes.Int64Value `tfsdk:"preference"`
	state      attr.ValueState
}

func (v NextQualifiedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NextQualifiedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NextQualifiedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NextQualifiedValue) String() string {
	return "NextQualifiedValue"
}

func (v NextQualifiedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"metric":     basetypes.Int64Type{},
		"preference": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"metric":     v.Metric,
			"preference": v.Preference,
		})

	return objVal, diags
}

func (v NextQualifiedValue) Equal(o attr.Value) bool {
	other, ok := o.(NextQualifiedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	return true
}

func (v NextQualifiedValue) Type(ctx context.Context) attr.Type {
	return NextQualifiedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NextQualifiedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"metric":     basetypes.Int64Type{},
		"preference": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpConfigType{}

type IpConfigType struct {
	basetypes.ObjectType
}

func (t IpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(IpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpConfigType) String() string {
	return "IpConfigType"
}

func (t IpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return nil, diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpConfigValue{
		Dns:          dnsVal,
		DnsSuffix:    dnsSuffixVal,
		Gateway:      gatewayVal,
		Ip:           ipVal,
		Netmask:      netmaskVal,
		Network:      networkVal,
		IpConfigType: typeVal,
		UseMgmtVrf:   useMgmtVrfVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueNull() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewIpConfigValueUnknown() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, a missing attribute value was detected. "+
					"A IpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpConfigValue Attribute Type",
				"While creating a IpConfigValue value, an invalid attribute value was detected. "+
					"A IpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, an extra attribute value was detected. "+
					"A IpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	return IpConfigValue{
		Dns:          dnsVal,
		DnsSuffix:    dnsSuffixVal,
		Gateway:      gatewayVal,
		Ip:           ipVal,
		Netmask:      netmaskVal,
		Network:      networkVal,
		IpConfigType: typeVal,
		UseMgmtVrf:   useMgmtVrfVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpConfigValue {
	object, diags := NewIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpConfigValueMust(IpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpConfigType) ValueType(ctx context.Context) attr.Value {
	return IpConfigValue{}
}

var _ basetypes.ObjectValuable = IpConfigValue{}

type IpConfigValue struct {
	Dns          basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix    basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway      basetypes.StringValue `tfsdk:"gateway"`
	Ip           basetypes.StringValue `tfsdk:"ip"`
	Netmask      basetypes.StringValue `tfsdk:"netmask"`
	Network      basetypes.StringValue `tfsdk:"network"`
	IpConfigType basetypes.StringValue `tfsdk:"type"`
	UseMgmtVrf   basetypes.BoolValue   `tfsdk:"use_mgmt_vrf"`
	state        attr.ValueState
}

func (v IpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.IpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UseMgmtVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpConfigValue) String() string {
	return "IpConfigValue"
}

func (v IpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":      basetypes.StringType{},
			"ip":           basetypes.StringType{},
			"netmask":      basetypes.StringType{},
			"network":      basetypes.StringType{},
			"type":         basetypes.StringType{},
			"use_mgmt_vrf": basetypes.BoolType{},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":      basetypes.StringType{},
			"ip":           basetypes.StringType{},
			"netmask":      basetypes.StringType{},
			"network":      basetypes.StringType{},
			"type":         basetypes.StringType{},
			"use_mgmt_vrf": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":      basetypes.StringType{},
		"ip":           basetypes.StringType{},
		"netmask":      basetypes.StringType{},
		"network":      basetypes.StringType{},
		"type":         basetypes.StringType{},
		"use_mgmt_vrf": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns":          dnsVal,
			"dns_suffix":   dnsSuffixVal,
			"gateway":      v.Gateway,
			"ip":           v.Ip,
			"netmask":      v.Netmask,
			"network":      v.Network,
			"type":         v.IpConfigType,
			"use_mgmt_vrf": v.UseMgmtVrf,
		})

	return objVal, diags
}

func (v IpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(IpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.IpConfigType.Equal(other.IpConfigType) {
		return false
	}

	if !v.UseMgmtVrf.Equal(other.UseMgmtVrf) {
		return false
	}

	return true
}

func (v IpConfigValue) Type(ctx context.Context) attr.Type {
	return IpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":      basetypes.StringType{},
		"ip":           basetypes.StringType{},
		"netmask":      basetypes.StringType{},
		"network":      basetypes.StringType{},
		"type":         basetypes.StringType{},
		"use_mgmt_vrf": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return nil, diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	isolationVlanIdAttribute, ok := attributes["isolation_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation_vlan_id is missing from object`)

		return nil, diags
	}

	isolationVlanIdVal, ok := isolationVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation_vlan_id expected to be basetypes.StringValue, was: %T`, isolationVlanIdAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		Isolation:       isolationVal,
		IsolationVlanId: isolationVlanIdVal,
		Subnet:          subnetVal,
		VlanId:          vlanIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	isolationVlanIdAttribute, ok := attributes["isolation_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation_vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	isolationVlanIdVal, ok := isolationVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation_vlan_id expected to be basetypes.StringValue, was: %T`, isolationVlanIdAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		Isolation:       isolationVal,
		IsolationVlanId: isolationVlanIdVal,
		Subnet:          subnetVal,
		VlanId:          vlanIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	Isolation       basetypes.BoolValue   `tfsdk:"isolation"`
	IsolationVlanId basetypes.StringValue `tfsdk:"isolation_vlan_id"`
	Subnet          basetypes.StringValue `tfsdk:"subnet"`
	VlanId          basetypes.Int64Value  `tfsdk:"vlan_id"`
	state           attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["isolation"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["isolation_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Isolation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolation"] = val

		val, err = v.IsolationVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolation_vlan_id"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"isolation":         basetypes.BoolType{},
		"isolation_vlan_id": basetypes.StringType{},
		"subnet":            basetypes.StringType{},
		"vlan_id":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"isolation":         v.Isolation,
			"isolation_vlan_id": v.IsolationVlanId,
			"subnet":            v.Subnet,
			"vlan_id":           v.VlanId,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Isolation.Equal(other.Isolation) {
		return false
	}

	if !v.IsolationVlanId.Equal(other.IsolationVlanId) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"isolation":         basetypes.BoolType{},
		"isolation_vlan_id": basetypes.StringType{},
		"subnet":            basetypes.StringType{},
		"vlan_id":           basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = OobIpConfigType{}

type OobIpConfigType struct {
	basetypes.ObjectType
}

func (t OobIpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(OobIpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OobIpConfigType) String() string {
	return "OobIpConfigType"
}

func (t OobIpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OobIpConfigValue{
		Ip:              ipVal,
		Netmask:         netmaskVal,
		Network:         networkVal,
		OobIpConfigType: typeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueNull() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewOobIpConfigValueUnknown() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOobIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OobIpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, a missing attribute value was detected. "+
					"A OobIpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OobIpConfigValue Attribute Type",
				"While creating a OobIpConfigValue value, an invalid attribute value was detected. "+
					"A OobIpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, an extra attribute value was detected. "+
					"A OobIpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OobIpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	return OobIpConfigValue{
		Ip:              ipVal,
		Netmask:         netmaskVal,
		Network:         networkVal,
		OobIpConfigType: typeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OobIpConfigValue {
	object, diags := NewOobIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOobIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OobIpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOobIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOobIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOobIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOobIpConfigValueMust(OobIpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OobIpConfigType) ValueType(ctx context.Context) attr.Value {
	return OobIpConfigValue{}
}

var _ basetypes.ObjectValuable = OobIpConfigValue{}

type OobIpConfigValue struct {
	Ip              basetypes.StringValue `tfsdk:"ip"`
	Netmask         basetypes.StringValue `tfsdk:"netmask"`
	Network         basetypes.StringValue `tfsdk:"network"`
	OobIpConfigType basetypes.StringValue `tfsdk:"type"`
	state           attr.ValueState
}

func (v OobIpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.OobIpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OobIpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OobIpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OobIpConfigValue) String() string {
	return "OobIpConfigValue"
}

func (v OobIpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"network": basetypes.StringType{},
		"type":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":      v.Ip,
			"netmask": v.Netmask,
			"network": v.Network,
			"type":    v.OobIpConfigType,
		})

	return objVal, diags
}

func (v OobIpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(OobIpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.OobIpConfigType.Equal(other.OobIpConfigType) {
		return false
	}

	return true
}

func (v OobIpConfigValue) Type(ctx context.Context) attr.Type {
	return OobIpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OobIpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"network": basetypes.StringType{},
		"type":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OspfConfigType{}

type OspfConfigType struct {
	basetypes.ObjectType
}

func (t OspfConfigType) Equal(o attr.Type) bool {
	other, ok := o.(OspfConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OspfConfigType) String() string {
	return "OspfConfigType"
}

func (t OspfConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	areasAttribute, ok := attributes["areas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`areas is missing from object`)

		return nil, diags
	}

	areasVal, ok := areasAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`areas expected to be basetypes.MapValue, was: %T`, areasAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	referenceBandwidthAttribute, ok := attributes["reference_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reference_bandwidth is missing from object`)

		return nil, diags
	}

	referenceBandwidthVal, ok := referenceBandwidthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reference_bandwidth expected to be basetypes.StringValue, was: %T`, referenceBandwidthAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OspfConfigValue{
		Areas:              areasVal,
		Enabled:            enabledVal,
		ReferenceBandwidth: referenceBandwidthVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOspfConfigValueNull() OspfConfigValue {
	return OspfConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewOspfConfigValueUnknown() OspfConfigValue {
	return OspfConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OspfConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OspfConfigValue Attribute Value",
				"While creating a OspfConfigValue value, a missing attribute value was detected. "+
					"A OspfConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OspfConfigValue Attribute Type",
				"While creating a OspfConfigValue value, an invalid attribute value was detected. "+
					"A OspfConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OspfConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OspfConfigValue Attribute Value",
				"While creating a OspfConfigValue value, an extra attribute value was detected. "+
					"A OspfConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OspfConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfConfigValueUnknown(), diags
	}

	areasAttribute, ok := attributes["areas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`areas is missing from object`)

		return NewOspfConfigValueUnknown(), diags
	}

	areasVal, ok := areasAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`areas expected to be basetypes.MapValue, was: %T`, areasAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewOspfConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	referenceBandwidthAttribute, ok := attributes["reference_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reference_bandwidth is missing from object`)

		return NewOspfConfigValueUnknown(), diags
	}

	referenceBandwidthVal, ok := referenceBandwidthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reference_bandwidth expected to be basetypes.StringValue, was: %T`, referenceBandwidthAttribute))
	}

	if diags.HasError() {
		return NewOspfConfigValueUnknown(), diags
	}

	return OspfConfigValue{
		Areas:              areasVal,
		Enabled:            enabledVal,
		ReferenceBandwidth: referenceBandwidthVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOspfConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OspfConfigValue {
	object, diags := NewOspfConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OspfConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfConfigValueMust(OspfConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OspfConfigType) ValueType(ctx context.Context) attr.Value {
	return OspfConfigValue{}
}

var _ basetypes.ObjectValuable = OspfConfigValue{}

type OspfConfigValue struct {
	Areas              basetypes.MapValue    `tfsdk:"areas"`
	Enabled            basetypes.BoolValue   `tfsdk:"enabled"`
	ReferenceBandwidth basetypes.StringValue `tfsdk:"reference_bandwidth"`
	state              attr.ValueState
}

func (v OspfConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["areas"] = basetypes.MapType{
		ElemType: AreasValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["reference_bandwidth"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Areas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["areas"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ReferenceBandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reference_bandwidth"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OspfConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OspfConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OspfConfigValue) String() string {
	return "OspfConfigValue"
}

func (v OspfConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	areas := types.MapValueMust(
		AreasType{
			basetypes.ObjectType{
				AttrTypes: AreasValue{}.AttributeTypes(ctx),
			},
		},
		v.Areas.Elements(),
	)

	if v.Areas.IsNull() {
		areas = types.MapNull(
			AreasType{
				basetypes.ObjectType{
					AttrTypes: AreasValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Areas.IsUnknown() {
		areas = types.MapUnknown(
			AreasType{
				basetypes.ObjectType{
					AttrTypes: AreasValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"areas": basetypes.MapType{
			ElemType: AreasValue{}.Type(ctx),
		},
		"enabled":             basetypes.BoolType{},
		"reference_bandwidth": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"areas":               areas,
			"enabled":             v.Enabled,
			"reference_bandwidth": v.ReferenceBandwidth,
		})

	return objVal, diags
}

func (v OspfConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(OspfConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Areas.Equal(other.Areas) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ReferenceBandwidth.Equal(other.ReferenceBandwidth) {
		return false
	}

	return true
}

func (v OspfConfigValue) Type(ctx context.Context) attr.Type {
	return OspfConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OspfConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"areas": basetypes.MapType{
			ElemType: AreasValue{}.Type(ctx),
		},
		"enabled":             basetypes.BoolType{},
		"reference_bandwidth": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AreasType{}

type AreasType struct {
	basetypes.ObjectType
}

func (t AreasType) Equal(o attr.Type) bool {
	other, ok := o.(AreasType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AreasType) String() string {
	return "AreasType"
}

func (t AreasType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	noSummaryAttribute, ok := attributes["no_summary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_summary is missing from object`)

		return nil, diags
	}

	noSummaryVal, ok := noSummaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_summary expected to be basetypes.BoolValue, was: %T`, noSummaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AreasValue{
		NoSummary: noSummaryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAreasValueNull() AreasValue {
	return AreasValue{
		state: attr.ValueStateNull,
	}
}

func NewAreasValueUnknown() AreasValue {
	return AreasValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAreasValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AreasValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AreasValue Attribute Value",
				"While creating a AreasValue value, a missing attribute value was detected. "+
					"A AreasValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AreasValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AreasValue Attribute Type",
				"While creating a AreasValue value, an invalid attribute value was detected. "+
					"A AreasValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AreasValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AreasValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AreasValue Attribute Value",
				"While creating a AreasValue value, an extra attribute value was detected. "+
					"A AreasValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AreasValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAreasValueUnknown(), diags
	}

	noSummaryAttribute, ok := attributes["no_summary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_summary is missing from object`)

		return NewAreasValueUnknown(), diags
	}

	noSummaryVal, ok := noSummaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_summary expected to be basetypes.BoolValue, was: %T`, noSummaryAttribute))
	}

	if diags.HasError() {
		return NewAreasValueUnknown(), diags
	}

	return AreasValue{
		NoSummary: noSummaryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAreasValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AreasValue {
	object, diags := NewAreasValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAreasValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AreasType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAreasValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAreasValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAreasValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAreasValueMust(AreasValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AreasType) ValueType(ctx context.Context) attr.Value {
	return AreasValue{}
}

var _ basetypes.ObjectValuable = AreasValue{}

type AreasValue struct {
	NoSummary basetypes.BoolValue `tfsdk:"no_summary"`
	state     attr.ValueState
}

func (v AreasValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["no_summary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.NoSummary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_summary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AreasValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AreasValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AreasValue) String() string {
	return "AreasValue"
}

func (v AreasValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"no_summary": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"no_summary": v.NoSummary,
		})

	return objVal, diags
}

func (v AreasValue) Equal(o attr.Value) bool {
	other, ok := o.(AreasValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NoSummary.Equal(other.NoSummary) {
		return false
	}

	return true
}

func (v AreasValue) Type(ctx context.Context) attr.Type {
	return AreasType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AreasValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"no_summary": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = OtherIpConfigsType{}

type OtherIpConfigsType struct {
	basetypes.ObjectType
}

func (t OtherIpConfigsType) Equal(o attr.Type) bool {
	other, ok := o.(OtherIpConfigsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OtherIpConfigsType) String() string {
	return "OtherIpConfigsType"
}

func (t OtherIpConfigsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	evpnAnycastAttribute, ok := attributes["evpn_anycast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_anycast is missing from object`)

		return nil, diags
	}

	evpnAnycastVal, ok := evpnAnycastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_anycast expected to be basetypes.BoolValue, was: %T`, evpnAnycastAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return nil, diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OtherIpConfigsValue{
		EvpnAnycast:        evpnAnycastVal,
		Gateway6:           gateway6Val,
		Ip:                 ipVal,
		Ip6:                ip6Val,
		Netmask:            netmaskVal,
		Netmask6:           netmask6Val,
		OtherIpConfigsType: typeVal,
		Type6:              type6Val,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOtherIpConfigsValueNull() OtherIpConfigsValue {
	return OtherIpConfigsValue{
		state: attr.ValueStateNull,
	}
}

func NewOtherIpConfigsValueUnknown() OtherIpConfigsValue {
	return OtherIpConfigsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOtherIpConfigsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OtherIpConfigsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OtherIpConfigsValue Attribute Value",
				"While creating a OtherIpConfigsValue value, a missing attribute value was detected. "+
					"A OtherIpConfigsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OtherIpConfigsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OtherIpConfigsValue Attribute Type",
				"While creating a OtherIpConfigsValue value, an invalid attribute value was detected. "+
					"A OtherIpConfigsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OtherIpConfigsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OtherIpConfigsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OtherIpConfigsValue Attribute Value",
				"While creating a OtherIpConfigsValue value, an extra attribute value was detected. "+
					"A OtherIpConfigsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OtherIpConfigsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOtherIpConfigsValueUnknown(), diags
	}

	evpnAnycastAttribute, ok := attributes["evpn_anycast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_anycast is missing from object`)

		return NewOtherIpConfigsValueUnknown(), diags
	}

	evpnAnycastVal, ok := evpnAnycastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_anycast expected to be basetypes.BoolValue, was: %T`, evpnAnycastAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewOtherIpConfigsValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewOtherIpConfigsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewOtherIpConfigsValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewOtherIpConfigsValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewOtherIpConfigsValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOtherIpConfigsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return NewOtherIpConfigsValueUnknown(), diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	if diags.HasError() {
		return NewOtherIpConfigsValueUnknown(), diags
	}

	return OtherIpConfigsValue{
		EvpnAnycast:        evpnAnycastVal,
		Gateway6:           gateway6Val,
		Ip:                 ipVal,
		Ip6:                ip6Val,
		Netmask:            netmaskVal,
		Netmask6:           netmask6Val,
		OtherIpConfigsType: typeVal,
		Type6:              type6Val,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOtherIpConfigsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OtherIpConfigsValue {
	object, diags := NewOtherIpConfigsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOtherIpConfigsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OtherIpConfigsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOtherIpConfigsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOtherIpConfigsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOtherIpConfigsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOtherIpConfigsValueMust(OtherIpConfigsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OtherIpConfigsType) ValueType(ctx context.Context) attr.Value {
	return OtherIpConfigsValue{}
}

var _ basetypes.ObjectValuable = OtherIpConfigsValue{}

type OtherIpConfigsValue struct {
	EvpnAnycast        basetypes.BoolValue   `tfsdk:"evpn_anycast"`
	Gateway6           basetypes.StringValue `tfsdk:"gateway6"`
	Ip                 basetypes.StringValue `tfsdk:"ip"`
	Ip6                basetypes.StringValue `tfsdk:"ip6"`
	Netmask            basetypes.StringValue `tfsdk:"netmask"`
	Netmask6           basetypes.StringValue `tfsdk:"netmask6"`
	OtherIpConfigsType basetypes.StringValue `tfsdk:"type"`
	Type6              basetypes.StringValue `tfsdk:"type6"`
	state              attr.ValueState
}

func (v OtherIpConfigsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["evpn_anycast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.EvpnAnycast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_anycast"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		val, err = v.OtherIpConfigsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Type6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OtherIpConfigsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OtherIpConfigsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OtherIpConfigsValue) String() string {
	return "OtherIpConfigsValue"
}

func (v OtherIpConfigsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"evpn_anycast": basetypes.BoolType{},
		"gateway6":     basetypes.StringType{},
		"ip":           basetypes.StringType{},
		"ip6":          basetypes.StringType{},
		"netmask":      basetypes.StringType{},
		"netmask6":     basetypes.StringType{},
		"type":         basetypes.StringType{},
		"type6":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"evpn_anycast": v.EvpnAnycast,
			"gateway6":     v.Gateway6,
			"ip":           v.Ip,
			"ip6":          v.Ip6,
			"netmask":      v.Netmask,
			"netmask6":     v.Netmask6,
			"type":         v.OtherIpConfigsType,
			"type6":        v.Type6,
		})

	return objVal, diags
}

func (v OtherIpConfigsValue) Equal(o attr.Value) bool {
	other, ok := o.(OtherIpConfigsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EvpnAnycast.Equal(other.EvpnAnycast) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	if !v.OtherIpConfigsType.Equal(other.OtherIpConfigsType) {
		return false
	}

	if !v.Type6.Equal(other.Type6) {
		return false
	}

	return true
}

func (v OtherIpConfigsValue) Type(ctx context.Context) attr.Type {
	return OtherIpConfigsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OtherIpConfigsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"evpn_anycast": basetypes.BoolType{},
		"gateway6":     basetypes.StringType{},
		"ip":           basetypes.StringType{},
		"ip6":          basetypes.StringType{},
		"netmask":      basetypes.StringType{},
		"netmask6":     basetypes.StringType{},
		"type":         basetypes.StringType{},
		"type6":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortConfigType{}

type PortConfigType struct {
	basetypes.ObjectType
}

func (t PortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortConfigType) String() string {
	return "PortConfigType"
}

func (t PortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return nil, diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return nil, diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.Int64Value, was: %T`, aeIdxAttribute))
	}

	aeLacpSlowAttribute, ok := attributes["ae_lacp_slow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_slow is missing from object`)

		return nil, diags
	}

	aeLacpSlowVal, ok := aeLacpSlowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_slow expected to be basetypes.BoolValue, was: %T`, aeLacpSlowAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return nil, diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicUsageAttribute, ok := attributes["dynamic_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_usage is missing from object`)

		return nil, diags
	}

	dynamicUsageVal, ok := dynamicUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_usage expected to be basetypes.StringValue, was: %T`, dynamicUsageAttribute))
	}

	esilagAttribute, ok := attributes["esilag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esilag is missing from object`)

		return nil, diags
	}

	esilagVal, ok := esilagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esilag expected to be basetypes.BoolValue, was: %T`, esilagAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	noLocalOverwriteAttribute, ok := attributes["no_local_overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_local_overwrite is missing from object`)

		return nil, diags
	}

	noLocalOverwriteVal, ok := noLocalOverwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_local_overwrite expected to be basetypes.BoolValue, was: %T`, noLocalOverwriteAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpSlow:       aeLacpSlowVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Duplex:           duplexVal,
		DynamicUsage:     dynamicUsageVal,
		Esilag:           esilagVal,
		Mtu:              mtuVal,
		NoLocalOverwrite: noLocalOverwriteVal,
		PoeDisabled:      poeDisabledVal,
		Speed:            speedVal,
		Usage:            usageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueNull() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortConfigValueUnknown() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, a missing attribute value was detected. "+
					"A PortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortConfigValue Attribute Type",
				"While creating a PortConfigValue value, an invalid attribute value was detected. "+
					"A PortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, an extra attribute value was detected. "+
					"A PortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.Int64Value, was: %T`, aeIdxAttribute))
	}

	aeLacpSlowAttribute, ok := attributes["ae_lacp_slow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_slow is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeLacpSlowVal, ok := aeLacpSlowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_slow expected to be basetypes.BoolValue, was: %T`, aeLacpSlowAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicUsageAttribute, ok := attributes["dynamic_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dynamicUsageVal, ok := dynamicUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_usage expected to be basetypes.StringValue, was: %T`, dynamicUsageAttribute))
	}

	esilagAttribute, ok := attributes["esilag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esilag is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	esilagVal, ok := esilagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esilag expected to be basetypes.BoolValue, was: %T`, esilagAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	noLocalOverwriteAttribute, ok := attributes["no_local_overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_local_overwrite is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	noLocalOverwriteVal, ok := noLocalOverwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_local_overwrite expected to be basetypes.BoolValue, was: %T`, noLocalOverwriteAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpSlow:       aeLacpSlowVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Duplex:           duplexVal,
		DynamicUsage:     dynamicUsageVal,
		Esilag:           esilagVal,
		Mtu:              mtuVal,
		NoLocalOverwrite: noLocalOverwriteVal,
		PoeDisabled:      poeDisabledVal,
		Speed:            speedVal,
		Usage:            usageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortConfigValue {
	object, diags := NewPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortConfigValueMust(PortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortConfigType) ValueType(ctx context.Context) attr.Value {
	return PortConfigValue{}
}

var _ basetypes.ObjectValuable = PortConfigValue{}

type PortConfigValue struct {
	AeDisableLacp    basetypes.BoolValue   `tfsdk:"ae_disable_lacp"`
	AeIdx            basetypes.Int64Value  `tfsdk:"ae_idx"`
	AeLacpSlow       basetypes.BoolValue   `tfsdk:"ae_lacp_slow"`
	Aggregated       basetypes.BoolValue   `tfsdk:"aggregated"`
	Critical         basetypes.BoolValue   `tfsdk:"critical"`
	Description      basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg   basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Duplex           basetypes.StringValue `tfsdk:"duplex"`
	DynamicUsage     basetypes.StringValue `tfsdk:"dynamic_usage"`
	Esilag           basetypes.BoolValue   `tfsdk:"esilag"`
	Mtu              basetypes.Int64Value  `tfsdk:"mtu"`
	NoLocalOverwrite basetypes.BoolValue   `tfsdk:"no_local_overwrite"`
	PoeDisabled      basetypes.BoolValue   `tfsdk:"poe_disabled"`
	Speed            basetypes.StringValue `tfsdk:"speed"`
	Usage            basetypes.StringValue `tfsdk:"usage"`
	state            attr.ValueState
}

func (v PortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["ae_disable_lacp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ae_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ae_lacp_slow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aggregated"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["critical"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["esilag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["no_local_overwrite"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.AeDisableLacp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_disable_lacp"] = val

		val, err = v.AeIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_idx"] = val

		val, err = v.AeLacpSlow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_lacp_slow"] = val

		val, err = v.Aggregated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregated"] = val

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.DynamicUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_usage"] = val

		val, err = v.Esilag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["esilag"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.NoLocalOverwrite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_local_overwrite"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortConfigValue) String() string {
	return "PortConfigValue"
}

func (v PortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ae_disable_lacp":    basetypes.BoolType{},
		"ae_idx":             basetypes.Int64Type{},
		"ae_lacp_slow":       basetypes.BoolType{},
		"aggregated":         basetypes.BoolType{},
		"critical":           basetypes.BoolType{},
		"description":        basetypes.StringType{},
		"disable_autoneg":    basetypes.BoolType{},
		"duplex":             basetypes.StringType{},
		"dynamic_usage":      basetypes.StringType{},
		"esilag":             basetypes.BoolType{},
		"mtu":                basetypes.Int64Type{},
		"no_local_overwrite": basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"speed":              basetypes.StringType{},
		"usage":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ae_disable_lacp":    v.AeDisableLacp,
			"ae_idx":             v.AeIdx,
			"ae_lacp_slow":       v.AeLacpSlow,
			"aggregated":         v.Aggregated,
			"critical":           v.Critical,
			"description":        v.Description,
			"disable_autoneg":    v.DisableAutoneg,
			"duplex":             v.Duplex,
			"dynamic_usage":      v.DynamicUsage,
			"esilag":             v.Esilag,
			"mtu":                v.Mtu,
			"no_local_overwrite": v.NoLocalOverwrite,
			"poe_disabled":       v.PoeDisabled,
			"speed":              v.Speed,
			"usage":              v.Usage,
		})

	return objVal, diags
}

func (v PortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AeDisableLacp.Equal(other.AeDisableLacp) {
		return false
	}

	if !v.AeIdx.Equal(other.AeIdx) {
		return false
	}

	if !v.AeLacpSlow.Equal(other.AeLacpSlow) {
		return false
	}

	if !v.Aggregated.Equal(other.Aggregated) {
		return false
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.DynamicUsage.Equal(other.DynamicUsage) {
		return false
	}

	if !v.Esilag.Equal(other.Esilag) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.NoLocalOverwrite.Equal(other.NoLocalOverwrite) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v PortConfigValue) Type(ctx context.Context) attr.Type {
	return PortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ae_disable_lacp":    basetypes.BoolType{},
		"ae_idx":             basetypes.Int64Type{},
		"ae_lacp_slow":       basetypes.BoolType{},
		"aggregated":         basetypes.BoolType{},
		"critical":           basetypes.BoolType{},
		"description":        basetypes.StringType{},
		"disable_autoneg":    basetypes.BoolType{},
		"duplex":             basetypes.StringType{},
		"dynamic_usage":      basetypes.StringType{},
		"esilag":             basetypes.BoolType{},
		"mtu":                basetypes.Int64Type{},
		"no_local_overwrite": basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"speed":              basetypes.StringType{},
		"usage":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortMirroringType{}

type PortMirroringType struct {
	basetypes.ObjectType
}

func (t PortMirroringType) Equal(o attr.Type) bool {
	other, ok := o.(PortMirroringType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMirroringType) String() string {
	return "PortMirroringType"
}

func (t PortMirroringType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	inputNetworksIngressAttribute, ok := attributes["input_networks_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_networks_ingress is missing from object`)

		return nil, diags
	}

	inputNetworksIngressVal, ok := inputNetworksIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_networks_ingress expected to be basetypes.ListValue, was: %T`, inputNetworksIngressAttribute))
	}

	inputPortIdsEgressAttribute, ok := attributes["input_port_ids_egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_egress is missing from object`)

		return nil, diags
	}

	inputPortIdsEgressVal, ok := inputPortIdsEgressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_egress expected to be basetypes.ListValue, was: %T`, inputPortIdsEgressAttribute))
	}

	inputPortIdsIngressAttribute, ok := attributes["input_port_ids_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_ingress is missing from object`)

		return nil, diags
	}

	inputPortIdsIngressVal, ok := inputPortIdsIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_ingress expected to be basetypes.ListValue, was: %T`, inputPortIdsIngressAttribute))
	}

	outputNetworkAttribute, ok := attributes["output_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_network is missing from object`)

		return nil, diags
	}

	outputNetworkVal, ok := outputNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_network expected to be basetypes.StringValue, was: %T`, outputNetworkAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return nil, diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortMirroringValue{
		InputNetworksIngress: inputNetworksIngressVal,
		InputPortIdsEgress:   inputPortIdsEgressVal,
		InputPortIdsIngress:  inputPortIdsIngressVal,
		OutputNetwork:        outputNetworkVal,
		OutputPortId:         outputPortIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueNull() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMirroringValueUnknown() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMirroringValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMirroringValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, a missing attribute value was detected. "+
					"A PortMirroringValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMirroringValue Attribute Type",
				"While creating a PortMirroringValue value, an invalid attribute value was detected. "+
					"A PortMirroringValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, an extra attribute value was detected. "+
					"A PortMirroringValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMirroringValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	inputNetworksIngressAttribute, ok := attributes["input_networks_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_networks_ingress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputNetworksIngressVal, ok := inputNetworksIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_networks_ingress expected to be basetypes.ListValue, was: %T`, inputNetworksIngressAttribute))
	}

	inputPortIdsEgressAttribute, ok := attributes["input_port_ids_egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_egress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputPortIdsEgressVal, ok := inputPortIdsEgressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_egress expected to be basetypes.ListValue, was: %T`, inputPortIdsEgressAttribute))
	}

	inputPortIdsIngressAttribute, ok := attributes["input_port_ids_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_ingress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputPortIdsIngressVal, ok := inputPortIdsIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_ingress expected to be basetypes.ListValue, was: %T`, inputPortIdsIngressAttribute))
	}

	outputNetworkAttribute, ok := attributes["output_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_network is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	outputNetworkVal, ok := outputNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_network expected to be basetypes.StringValue, was: %T`, outputNetworkAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	return PortMirroringValue{
		InputNetworksIngress: inputNetworksIngressVal,
		InputPortIdsEgress:   inputPortIdsEgressVal,
		InputPortIdsIngress:  inputPortIdsIngressVal,
		OutputNetwork:        outputNetworkVal,
		OutputPortId:         outputPortIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMirroringValue {
	object, diags := NewPortMirroringValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMirroringValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMirroringType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMirroringValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMirroringValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMirroringValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMirroringValueMust(PortMirroringValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMirroringType) ValueType(ctx context.Context) attr.Value {
	return PortMirroringValue{}
}

var _ basetypes.ObjectValuable = PortMirroringValue{}

type PortMirroringValue struct {
	InputNetworksIngress basetypes.ListValue   `tfsdk:"input_networks_ingress"`
	InputPortIdsEgress   basetypes.ListValue   `tfsdk:"input_port_ids_egress"`
	InputPortIdsIngress  basetypes.ListValue   `tfsdk:"input_port_ids_ingress"`
	OutputNetwork        basetypes.StringValue `tfsdk:"output_network"`
	OutputPortId         basetypes.StringValue `tfsdk:"output_port_id"`
	state                attr.ValueState
}

func (v PortMirroringValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["input_networks_ingress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["input_port_ids_egress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["input_port_ids_ingress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["output_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["output_port_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.InputNetworksIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_networks_ingress"] = val

		val, err = v.InputPortIdsEgress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_port_ids_egress"] = val

		val, err = v.InputPortIdsIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_port_ids_ingress"] = val

		val, err = v.OutputNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_network"] = val

		val, err = v.OutputPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_port_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMirroringValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMirroringValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMirroringValue) String() string {
	return "PortMirroringValue"
}

func (v PortMirroringValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	inputNetworksIngressVal, d := types.ListValue(types.StringType, v.InputNetworksIngress.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_network": basetypes.StringType{},
			"output_port_id": basetypes.StringType{},
		}), diags
	}

	inputPortIdsEgressVal, d := types.ListValue(types.StringType, v.InputPortIdsEgress.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_network": basetypes.StringType{},
			"output_port_id": basetypes.StringType{},
		}), diags
	}

	inputPortIdsIngressVal, d := types.ListValue(types.StringType, v.InputPortIdsIngress.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_network": basetypes.StringType{},
			"output_port_id": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"input_networks_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_egress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_network": basetypes.StringType{},
		"output_port_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"input_networks_ingress": inputNetworksIngressVal,
			"input_port_ids_egress":  inputPortIdsEgressVal,
			"input_port_ids_ingress": inputPortIdsIngressVal,
			"output_network":         v.OutputNetwork,
			"output_port_id":         v.OutputPortId,
		})

	return objVal, diags
}

func (v PortMirroringValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMirroringValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InputNetworksIngress.Equal(other.InputNetworksIngress) {
		return false
	}

	if !v.InputPortIdsEgress.Equal(other.InputPortIdsEgress) {
		return false
	}

	if !v.InputPortIdsIngress.Equal(other.InputPortIdsIngress) {
		return false
	}

	if !v.OutputNetwork.Equal(other.OutputNetwork) {
		return false
	}

	if !v.OutputPortId.Equal(other.OutputPortId) {
		return false
	}

	return true
}

func (v PortMirroringValue) Type(ctx context.Context) attr.Type {
	return PortMirroringType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMirroringValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"input_networks_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_egress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_network": basetypes.StringType{},
		"output_port_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortUsagesType{}

type PortUsagesType struct {
	basetypes.ObjectType
}

func (t PortUsagesType) Equal(o attr.Type) bool {
	other, ok := o.(PortUsagesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortUsagesType) String() string {
	return "PortUsagesType"
}

func (t PortUsagesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return nil, diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return nil, diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return nil, diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnkonwnClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unkonwn_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unkonwn_client is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownForUnkonwnClientVal, ok := bypassAuthWhenServerDownForUnkonwnClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unkonwn_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnkonwnClientAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return nil, diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return nil, diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return nil, diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return nil, diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	interSwitchLinkAttribute, ok := attributes["inter_switch_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_link is missing from object`)

		return nil, diags
	}

	interSwitchLinkVal, ok := interSwitchLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_link expected to be basetypes.BoolValue, was: %T`, interSwitchLinkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return nil, diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return nil, diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return nil, diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return nil, diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return nil, diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return nil, diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return nil, diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.Int64Value, was: %T`, reauthIntervalAttribute))
	}

	rejectedNetworkAttribute, ok := attributes["rejected_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejected_network is missing from object`)

		return nil, diags
	}

	rejectedNetworkVal, ok := rejectedNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejected_network expected to be basetypes.StringValue, was: %T`, rejectedNetworkAttribute))
	}

	resetDefaultWhenAttribute, ok := attributes["reset_default_when"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reset_default_when is missing from object`)

		return nil, diags
	}

	resetDefaultWhenVal, ok := resetDefaultWhenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reset_default_when expected to be basetypes.StringValue, was: %T`, resetDefaultWhenAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return nil, diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return nil, diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return nil, diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnkonwnClient: bypassAuthWhenServerDownForUnkonwnClientVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		InterSwitchLink:                          interSwitchLinkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		RejectedNetwork:                          rejectedNetworkVal,
		ResetDefaultWhen:                         resetDefaultWhenVal,
		Rules:                                    rulesVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpEdge:                                  stpEdgeVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueNull() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateNull,
	}
}

func NewPortUsagesValueUnknown() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortUsagesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortUsagesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, a missing attribute value was detected. "+
					"A PortUsagesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortUsagesValue Attribute Type",
				"While creating a PortUsagesValue value, an invalid attribute value was detected. "+
					"A PortUsagesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, an extra attribute value was detected. "+
					"A PortUsagesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortUsagesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnkonwnClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unkonwn_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unkonwn_client is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownForUnkonwnClientVal, ok := bypassAuthWhenServerDownForUnkonwnClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unkonwn_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnkonwnClientAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	interSwitchLinkAttribute, ok := attributes["inter_switch_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_link is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	interSwitchLinkVal, ok := interSwitchLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_link expected to be basetypes.BoolValue, was: %T`, interSwitchLinkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.Int64Value, was: %T`, reauthIntervalAttribute))
	}

	rejectedNetworkAttribute, ok := attributes["rejected_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejected_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	rejectedNetworkVal, ok := rejectedNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejected_network expected to be basetypes.StringValue, was: %T`, rejectedNetworkAttribute))
	}

	resetDefaultWhenAttribute, ok := attributes["reset_default_when"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reset_default_when is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	resetDefaultWhenVal, ok := resetDefaultWhenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reset_default_when expected to be basetypes.StringValue, was: %T`, resetDefaultWhenAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnkonwnClient: bypassAuthWhenServerDownForUnkonwnClientVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		InterSwitchLink:                          interSwitchLinkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		RejectedNetwork:                          rejectedNetworkVal,
		ResetDefaultWhen:                         resetDefaultWhenVal,
		Rules:                                    rulesVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpEdge:                                  stpEdgeVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortUsagesValue {
	object, diags := NewPortUsagesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortUsagesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortUsagesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortUsagesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortUsagesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortUsagesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortUsagesValueMust(PortUsagesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortUsagesType) ValueType(ctx context.Context) attr.Value {
	return PortUsagesValue{}
}

var _ basetypes.ObjectValuable = PortUsagesValue{}

type PortUsagesValue struct {
	AllNetworks                              basetypes.BoolValue   `tfsdk:"all_networks"`
	AllowDhcpd                               basetypes.BoolValue   `tfsdk:"allow_dhcpd"`
	AllowMultipleSupplicants                 basetypes.BoolValue   `tfsdk:"allow_multiple_supplicants"`
	BypassAuthWhenServerDown                 basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down"`
	BypassAuthWhenServerDownForUnkonwnClient basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down_for_unkonwn_client"`
	Description                              basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg                           basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Disabled                                 basetypes.BoolValue   `tfsdk:"disabled"`
	Duplex                                   basetypes.StringValue `tfsdk:"duplex"`
	DynamicVlanNetworks                      basetypes.ListValue   `tfsdk:"dynamic_vlan_networks"`
	EnableMacAuth                            basetypes.BoolValue   `tfsdk:"enable_mac_auth"`
	EnableQos                                basetypes.BoolValue   `tfsdk:"enable_qos"`
	GuestNetwork                             basetypes.StringValue `tfsdk:"guest_network"`
	InterSwitchLink                          basetypes.BoolValue   `tfsdk:"inter_switch_link"`
	MacAuthOnly                              basetypes.BoolValue   `tfsdk:"mac_auth_only"`
	MacAuthProtocol                          basetypes.StringValue `tfsdk:"mac_auth_protocol"`
	MacLimit                                 basetypes.Int64Value  `tfsdk:"mac_limit"`
	Mode                                     basetypes.StringValue `tfsdk:"mode"`
	Mtu                                      basetypes.Int64Value  `tfsdk:"mtu"`
	Networks                                 basetypes.ListValue   `tfsdk:"networks"`
	PersistMac                               basetypes.BoolValue   `tfsdk:"persist_mac"`
	PoeDisabled                              basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PortAuth                                 basetypes.StringValue `tfsdk:"port_auth"`
	PortNetwork                              basetypes.StringValue `tfsdk:"port_network"`
	ReauthInterval                           basetypes.Int64Value  `tfsdk:"reauth_interval"`
	RejectedNetwork                          basetypes.StringValue `tfsdk:"rejected_network"`
	ResetDefaultWhen                         basetypes.StringValue `tfsdk:"reset_default_when"`
	Rules                                    basetypes.ListValue   `tfsdk:"rules"`
	Speed                                    basetypes.StringValue `tfsdk:"speed"`
	StormControl                             basetypes.ObjectValue `tfsdk:"storm_control"`
	StpEdge                                  basetypes.BoolValue   `tfsdk:"stp_edge"`
	VoipNetwork                              basetypes.StringValue `tfsdk:"voip_network"`
	state                                    attr.ValueState
}

func (v PortUsagesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 32)

	var val tftypes.Value
	var err error

	attrTypes["all_networks"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_dhcpd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_multiple_supplicants"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down_for_unkonwn_client"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_vlan_networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enable_mac_auth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_qos"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["guest_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["inter_switch_link"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["persist_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reauth_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rejected_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reset_default_when"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: RulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storm_control"] = basetypes.ObjectType{
		AttrTypes: StormControlValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["stp_edge"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["voip_network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 32)

		val, err = v.AllNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["all_networks"] = val

		val, err = v.AllowDhcpd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_dhcpd"] = val

		val, err = v.AllowMultipleSupplicants.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_multiple_supplicants"] = val

		val, err = v.BypassAuthWhenServerDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down"] = val

		val, err = v.BypassAuthWhenServerDownForUnkonwnClient.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down_for_unkonwn_client"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.DynamicVlanNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_vlan_networks"] = val

		val, err = v.EnableMacAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_mac_auth"] = val

		val, err = v.EnableQos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_qos"] = val

		val, err = v.GuestNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["guest_network"] = val

		val, err = v.InterSwitchLink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inter_switch_link"] = val

		val, err = v.MacAuthOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_only"] = val

		val, err = v.MacAuthProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_protocol"] = val

		val, err = v.MacLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_limit"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.PersistMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["persist_mac"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PortAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_auth"] = val

		val, err = v.PortNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_network"] = val

		val, err = v.ReauthInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reauth_interval"] = val

		val, err = v.RejectedNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rejected_network"] = val

		val, err = v.ResetDefaultWhen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reset_default_when"] = val

		val, err = v.Rules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.StormControl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storm_control"] = val

		val, err = v.StpEdge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_edge"] = val

		val, err = v.VoipNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["voip_network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortUsagesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortUsagesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortUsagesValue) String() string {
	return "PortUsagesValue"
}

func (v PortUsagesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	rules := types.ListValueMust(
		RulesType{
			basetypes.ObjectType{
				AttrTypes: RulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Rules.Elements(),
	)

	if v.Rules.IsNull() {
		rules = types.ListNull(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Rules.IsUnknown() {
		rules = types.ListUnknown(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var stormControl basetypes.ObjectValue

	if v.StormControl.IsNull() {
		stormControl = types.ObjectNull(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if v.StormControl.IsUnknown() {
		stormControl = types.ObjectUnknown(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StormControl.IsNull() && !v.StormControl.IsUnknown() {
		stormControl = types.ObjectValueMust(
			StormControlValue{}.AttributeTypes(ctx),
			v.StormControl.Attributes(),
		)
	}

	dynamicVlanNetworksVal, d := types.ListValue(types.StringType, v.DynamicVlanNetworks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":   basetypes.BoolType{},
			"enable_qos":        basetypes.BoolType{},
			"guest_network":     basetypes.StringType{},
			"inter_switch_link": basetypes.BoolType{},
			"mac_auth_only":     basetypes.BoolType{},
			"mac_auth_protocol": basetypes.StringType{},
			"mac_limit":         basetypes.Int64Type{},
			"mode":              basetypes.StringType{},
			"mtu":               basetypes.Int64Type{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":        basetypes.BoolType{},
			"poe_disabled":       basetypes.BoolType{},
			"port_auth":          basetypes.StringType{},
			"port_network":       basetypes.StringType{},
			"reauth_interval":    basetypes.Int64Type{},
			"rejected_network":   basetypes.StringType{},
			"reset_default_when": basetypes.StringType{},
			"rules": basetypes.ListType{
				ElemType: RulesValue{}.Type(ctx),
			},
			"speed": basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_edge":     basetypes.BoolType{},
			"voip_network": basetypes.StringType{},
		}), diags
	}

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":   basetypes.BoolType{},
			"enable_qos":        basetypes.BoolType{},
			"guest_network":     basetypes.StringType{},
			"inter_switch_link": basetypes.BoolType{},
			"mac_auth_only":     basetypes.BoolType{},
			"mac_auth_protocol": basetypes.StringType{},
			"mac_limit":         basetypes.Int64Type{},
			"mode":              basetypes.StringType{},
			"mtu":               basetypes.Int64Type{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":        basetypes.BoolType{},
			"poe_disabled":       basetypes.BoolType{},
			"port_auth":          basetypes.StringType{},
			"port_network":       basetypes.StringType{},
			"reauth_interval":    basetypes.Int64Type{},
			"rejected_network":   basetypes.StringType{},
			"reset_default_when": basetypes.StringType{},
			"rules": basetypes.ListType{
				ElemType: RulesValue{}.Type(ctx),
			},
			"speed": basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_edge":     basetypes.BoolType{},
			"voip_network": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":   basetypes.BoolType{},
		"enable_qos":        basetypes.BoolType{},
		"guest_network":     basetypes.StringType{},
		"inter_switch_link": basetypes.BoolType{},
		"mac_auth_only":     basetypes.BoolType{},
		"mac_auth_protocol": basetypes.StringType{},
		"mac_limit":         basetypes.Int64Type{},
		"mode":              basetypes.StringType{},
		"mtu":               basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":        basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"port_auth":          basetypes.StringType{},
		"port_network":       basetypes.StringType{},
		"reauth_interval":    basetypes.Int64Type{},
		"rejected_network":   basetypes.StringType{},
		"reset_default_when": basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"speed": basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_edge":     basetypes.BoolType{},
		"voip_network": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"all_networks":                                    v.AllNetworks,
			"allow_dhcpd":                                     v.AllowDhcpd,
			"allow_multiple_supplicants":                      v.AllowMultipleSupplicants,
			"bypass_auth_when_server_down":                    v.BypassAuthWhenServerDown,
			"bypass_auth_when_server_down_for_unkonwn_client": v.BypassAuthWhenServerDownForUnkonwnClient,
			"description":                                     v.Description,
			"disable_autoneg":                                 v.DisableAutoneg,
			"disabled":                                        v.Disabled,
			"duplex":                                          v.Duplex,
			"dynamic_vlan_networks":                           dynamicVlanNetworksVal,
			"enable_mac_auth":                                 v.EnableMacAuth,
			"enable_qos":                                      v.EnableQos,
			"guest_network":                                   v.GuestNetwork,
			"inter_switch_link":                               v.InterSwitchLink,
			"mac_auth_only":                                   v.MacAuthOnly,
			"mac_auth_protocol":                               v.MacAuthProtocol,
			"mac_limit":                                       v.MacLimit,
			"mode":                                            v.Mode,
			"mtu":                                             v.Mtu,
			"networks":                                        networksVal,
			"persist_mac":                                     v.PersistMac,
			"poe_disabled":                                    v.PoeDisabled,
			"port_auth":                                       v.PortAuth,
			"port_network":                                    v.PortNetwork,
			"reauth_interval":                                 v.ReauthInterval,
			"rejected_network":                                v.RejectedNetwork,
			"reset_default_when":                              v.ResetDefaultWhen,
			"rules":                                           rules,
			"speed":                                           v.Speed,
			"storm_control":                                   stormControl,
			"stp_edge":                                        v.StpEdge,
			"voip_network":                                    v.VoipNetwork,
		})

	return objVal, diags
}

func (v PortUsagesValue) Equal(o attr.Value) bool {
	other, ok := o.(PortUsagesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllNetworks.Equal(other.AllNetworks) {
		return false
	}

	if !v.AllowDhcpd.Equal(other.AllowDhcpd) {
		return false
	}

	if !v.AllowMultipleSupplicants.Equal(other.AllowMultipleSupplicants) {
		return false
	}

	if !v.BypassAuthWhenServerDown.Equal(other.BypassAuthWhenServerDown) {
		return false
	}

	if !v.BypassAuthWhenServerDownForUnkonwnClient.Equal(other.BypassAuthWhenServerDownForUnkonwnClient) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.DynamicVlanNetworks.Equal(other.DynamicVlanNetworks) {
		return false
	}

	if !v.EnableMacAuth.Equal(other.EnableMacAuth) {
		return false
	}

	if !v.EnableQos.Equal(other.EnableQos) {
		return false
	}

	if !v.GuestNetwork.Equal(other.GuestNetwork) {
		return false
	}

	if !v.InterSwitchLink.Equal(other.InterSwitchLink) {
		return false
	}

	if !v.MacAuthOnly.Equal(other.MacAuthOnly) {
		return false
	}

	if !v.MacAuthProtocol.Equal(other.MacAuthProtocol) {
		return false
	}

	if !v.MacLimit.Equal(other.MacLimit) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.PersistMac.Equal(other.PersistMac) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PortAuth.Equal(other.PortAuth) {
		return false
	}

	if !v.PortNetwork.Equal(other.PortNetwork) {
		return false
	}

	if !v.ReauthInterval.Equal(other.ReauthInterval) {
		return false
	}

	if !v.RejectedNetwork.Equal(other.RejectedNetwork) {
		return false
	}

	if !v.ResetDefaultWhen.Equal(other.ResetDefaultWhen) {
		return false
	}

	if !v.Rules.Equal(other.Rules) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.StormControl.Equal(other.StormControl) {
		return false
	}

	if !v.StpEdge.Equal(other.StpEdge) {
		return false
	}

	if !v.VoipNetwork.Equal(other.VoipNetwork) {
		return false
	}

	return true
}

func (v PortUsagesValue) Type(ctx context.Context) attr.Type {
	return PortUsagesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortUsagesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":   basetypes.BoolType{},
		"enable_qos":        basetypes.BoolType{},
		"guest_network":     basetypes.StringType{},
		"inter_switch_link": basetypes.BoolType{},
		"mac_auth_only":     basetypes.BoolType{},
		"mac_auth_protocol": basetypes.StringType{},
		"mac_limit":         basetypes.Int64Type{},
		"mode":              basetypes.StringType{},
		"mtu":               basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":        basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"port_auth":          basetypes.StringType{},
		"port_network":       basetypes.StringType{},
		"reauth_interval":    basetypes.Int64Type{},
		"rejected_network":   basetypes.StringType{},
		"reset_default_when": basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"speed": basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_edge":     basetypes.BoolType{},
		"voip_network": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RulesType{}

type RulesType struct {
	basetypes.ObjectType
}

func (t RulesType) Equal(o attr.Type) bool {
	other, ok := o.(RulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RulesType) String() string {
	return "RulesType"
}

func (t RulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	equalsAttribute, ok := attributes["equals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals is missing from object`)

		return nil, diags
	}

	equalsVal, ok := equalsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals expected to be basetypes.StringValue, was: %T`, equalsAttribute))
	}

	equalsAnyAttribute, ok := attributes["equals_any"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals_any is missing from object`)

		return nil, diags
	}

	equalsAnyVal, ok := equalsAnyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals_any expected to be basetypes.ListValue, was: %T`, equalsAnyAttribute))
	}

	expressionAttribute, ok := attributes["expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expression is missing from object`)

		return nil, diags
	}

	expressionVal, ok := expressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expression expected to be basetypes.StringValue, was: %T`, expressionAttribute))
	}

	srcAttribute, ok := attributes["src"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src is missing from object`)

		return nil, diags
	}

	srcVal, ok := srcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src expected to be basetypes.StringValue, was: %T`, srcAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RulesValue{
		Equals:     equalsVal,
		EqualsAny:  equalsAnyVal,
		Expression: expressionVal,
		Src:        srcVal,
		Usage:      usageVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewRulesValueNull() RulesValue {
	return RulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRulesValueUnknown() RulesValue {
	return RulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RulesValue Attribute Value",
				"While creating a RulesValue value, a missing attribute value was detected. "+
					"A RulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RulesValue Attribute Type",
				"While creating a RulesValue value, an invalid attribute value was detected. "+
					"A RulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RulesValue Attribute Value",
				"While creating a RulesValue value, an extra attribute value was detected. "+
					"A RulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	equalsAttribute, ok := attributes["equals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	equalsVal, ok := equalsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals expected to be basetypes.StringValue, was: %T`, equalsAttribute))
	}

	equalsAnyAttribute, ok := attributes["equals_any"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals_any is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	equalsAnyVal, ok := equalsAnyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals_any expected to be basetypes.ListValue, was: %T`, equalsAnyAttribute))
	}

	expressionAttribute, ok := attributes["expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expression is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	expressionVal, ok := expressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expression expected to be basetypes.StringValue, was: %T`, expressionAttribute))
	}

	srcAttribute, ok := attributes["src"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	srcVal, ok := srcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src expected to be basetypes.StringValue, was: %T`, srcAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	return RulesValue{
		Equals:     equalsVal,
		EqualsAny:  equalsAnyVal,
		Expression: expressionVal,
		Src:        srcVal,
		Usage:      usageVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RulesValue {
	object, diags := NewRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRulesValueMust(RulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RulesType) ValueType(ctx context.Context) attr.Value {
	return RulesValue{}
}

var _ basetypes.ObjectValuable = RulesValue{}

type RulesValue struct {
	Equals     basetypes.StringValue `tfsdk:"equals"`
	EqualsAny  basetypes.ListValue   `tfsdk:"equals_any"`
	Expression basetypes.StringValue `tfsdk:"expression"`
	Src        basetypes.StringValue `tfsdk:"src"`
	Usage      basetypes.StringValue `tfsdk:"usage"`
	state      attr.ValueState
}

func (v RulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["equals"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["equals_any"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["expression"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Equals.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["equals"] = val

		val, err = v.EqualsAny.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["equals_any"] = val

		val, err = v.Expression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expression"] = val

		val, err = v.Src.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RulesValue) String() string {
	return "RulesValue"
}

func (v RulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	equalsAnyVal, d := types.ListValue(types.StringType, v.EqualsAny.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"equals": basetypes.StringType{},
			"equals_any": basetypes.ListType{
				ElemType: types.StringType,
			},
			"expression": basetypes.StringType{},
			"src":        basetypes.StringType{},
			"usage":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"equals": basetypes.StringType{},
		"equals_any": basetypes.ListType{
			ElemType: types.StringType,
		},
		"expression": basetypes.StringType{},
		"src":        basetypes.StringType{},
		"usage":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"equals":     v.Equals,
			"equals_any": equalsAnyVal,
			"expression": v.Expression,
			"src":        v.Src,
			"usage":      v.Usage,
		})

	return objVal, diags
}

func (v RulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Equals.Equal(other.Equals) {
		return false
	}

	if !v.EqualsAny.Equal(other.EqualsAny) {
		return false
	}

	if !v.Expression.Equal(other.Expression) {
		return false
	}

	if !v.Src.Equal(other.Src) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v RulesValue) Type(ctx context.Context) attr.Type {
	return RulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"equals": basetypes.StringType{},
		"equals_any": basetypes.ListType{
			ElemType: types.StringType,
		},
		"expression": basetypes.StringType{},
		"src":        basetypes.StringType{},
		"usage":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StormControlType{}

type StormControlType struct {
	basetypes.ObjectType
}

func (t StormControlType) Equal(o attr.Type) bool {
	other, ok := o.(StormControlType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StormControlType) String() string {
	return "StormControlType"
}

func (t StormControlType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return nil, diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return nil, diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return nil, diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return nil, diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return nil, diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StormControlValue{
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueNull() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateNull,
	}
}

func NewStormControlValueUnknown() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStormControlValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StormControlValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StormControlValue Attribute Value",
				"While creating a StormControlValue value, a missing attribute value was detected. "+
					"A StormControlValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StormControlValue Attribute Type",
				"While creating a StormControlValue value, an invalid attribute value was detected. "+
					"A StormControlValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StormControlValue Attribute Value",
				"While creating a StormControlValue value, an extra attribute value was detected. "+
					"A StormControlValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StormControlValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	return StormControlValue{
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StormControlValue {
	object, diags := NewStormControlValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStormControlValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StormControlType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStormControlValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStormControlValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStormControlValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStormControlValueMust(StormControlValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StormControlType) ValueType(ctx context.Context) attr.Value {
	return StormControlValue{}
}

var _ basetypes.ObjectValuable = StormControlValue{}

type StormControlValue struct {
	NoBroadcast           basetypes.BoolValue  `tfsdk:"no_broadcast"`
	NoMulticast           basetypes.BoolValue  `tfsdk:"no_multicast"`
	NoRegisteredMulticast basetypes.BoolValue  `tfsdk:"no_registered_multicast"`
	NoUnknownUnicast      basetypes.BoolValue  `tfsdk:"no_unknown_unicast"`
	Percentage            basetypes.Int64Value `tfsdk:"percentage"`
	state                 attr.ValueState
}

func (v StormControlValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["no_broadcast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_registered_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_unknown_unicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["percentage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.NoBroadcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_broadcast"] = val

		val, err = v.NoMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_multicast"] = val

		val, err = v.NoRegisteredMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_registered_multicast"] = val

		val, err = v.NoUnknownUnicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_unknown_unicast"] = val

		val, err = v.Percentage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["percentage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StormControlValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StormControlValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StormControlValue) String() string {
	return "StormControlValue"
}

func (v StormControlValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"no_broadcast":            v.NoBroadcast,
			"no_multicast":            v.NoMulticast,
			"no_registered_multicast": v.NoRegisteredMulticast,
			"no_unknown_unicast":      v.NoUnknownUnicast,
			"percentage":              v.Percentage,
		})

	return objVal, diags
}

func (v StormControlValue) Equal(o attr.Value) bool {
	other, ok := o.(StormControlValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NoBroadcast.Equal(other.NoBroadcast) {
		return false
	}

	if !v.NoMulticast.Equal(other.NoMulticast) {
		return false
	}

	if !v.NoRegisteredMulticast.Equal(other.NoRegisteredMulticast) {
		return false
	}

	if !v.NoUnknownUnicast.Equal(other.NoUnknownUnicast) {
		return false
	}

	if !v.Percentage.Equal(other.Percentage) {
		return false
	}

	return true
}

func (v StormControlValue) Type(ctx context.Context) attr.Type {
	return StormControlType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StormControlValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RadiusConfigType{}

type RadiusConfigType struct {
	basetypes.ObjectType
}

func (t RadiusConfigType) Equal(o attr.Type) bool {
	other, ok := o.(RadiusConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadiusConfigType) String() string {
	return "RadiusConfigType"
}

func (t RadiusConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return nil, diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return nil, diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return nil, diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return nil, diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return nil, diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return nil, diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return nil, diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueNull() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewRadiusConfigValueUnknown() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadiusConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadiusConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, a missing attribute value was detected. "+
					"A RadiusConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadiusConfigValue Attribute Type",
				"While creating a RadiusConfigValue value, an invalid attribute value was detected. "+
					"A RadiusConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, an extra attribute value was detected. "+
					"A RadiusConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadiusConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadiusConfigValue {
	object, diags := NewRadiusConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadiusConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadiusConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadiusConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadiusConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadiusConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadiusConfigValueMust(RadiusConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadiusConfigType) ValueType(ctx context.Context) attr.Value {
	return RadiusConfigValue{}
}

var _ basetypes.ObjectValuable = RadiusConfigValue{}

type RadiusConfigValue struct {
	AcctInterimInterval basetypes.Int64Value  `tfsdk:"acct_interim_interval"`
	AcctServers         basetypes.ListValue   `tfsdk:"acct_servers"`
	AuthServers         basetypes.ListValue   `tfsdk:"auth_servers"`
	AuthServersRetries  basetypes.Int64Value  `tfsdk:"auth_servers_retries"`
	AuthServersTimeout  basetypes.Int64Value  `tfsdk:"auth_servers_timeout"`
	CoaEnabled          basetypes.BoolValue   `tfsdk:"coa_enabled"`
	CoaPort             basetypes.Int64Value  `tfsdk:"coa_port"`
	Network             basetypes.StringValue `tfsdk:"network"`
	SourceIp            basetypes.StringValue `tfsdk:"source_ip"`
	state               attr.ValueState
}

func (v RadiusConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["acct_interim_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: AcctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers"] = basetypes.ListType{
		ElemType: AuthServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth_servers_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["coa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["coa_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AcctInterimInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_interim_interval"] = val

		val, err = v.AcctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.AuthServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers"] = val

		val, err = v.AuthServersRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_retries"] = val

		val, err = v.AuthServersTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_timeout"] = val

		val, err = v.CoaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_enabled"] = val

		val, err = v.CoaPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_port"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.SourceIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadiusConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadiusConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadiusConfigValue) String() string {
	return "RadiusConfigValue"
}

func (v RadiusConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acctServers := types.ListValueMust(
		AcctServersType{
			basetypes.ObjectType{
				AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AcctServers.Elements(),
	)

	if v.AcctServers.IsNull() {
		acctServers = types.ListNull(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AcctServers.IsUnknown() {
		acctServers = types.ListUnknown(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	authServers := types.ListValueMust(
		AuthServersType{
			basetypes.ObjectType{
				AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AuthServers.Elements(),
	)

	if v.AuthServers.IsNull() {
		authServers = types.ListNull(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AuthServers.IsUnknown() {
		authServers = types.ListUnknown(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acct_interim_interval": v.AcctInterimInterval,
			"acct_servers":          acctServers,
			"auth_servers":          authServers,
			"auth_servers_retries":  v.AuthServersRetries,
			"auth_servers_timeout":  v.AuthServersTimeout,
			"coa_enabled":           v.CoaEnabled,
			"coa_port":              v.CoaPort,
			"network":               v.Network,
			"source_ip":             v.SourceIp,
		})

	return objVal, diags
}

func (v RadiusConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(RadiusConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AcctInterimInterval.Equal(other.AcctInterimInterval) {
		return false
	}

	if !v.AcctServers.Equal(other.AcctServers) {
		return false
	}

	if !v.AuthServers.Equal(other.AuthServers) {
		return false
	}

	if !v.AuthServersRetries.Equal(other.AuthServersRetries) {
		return false
	}

	if !v.AuthServersTimeout.Equal(other.AuthServersTimeout) {
		return false
	}

	if !v.CoaEnabled.Equal(other.CoaEnabled) {
		return false
	}

	if !v.CoaPort.Equal(other.CoaPort) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.SourceIp.Equal(other.SourceIp) {
		return false
	}

	return true
}

func (v RadiusConfigValue) Type(ctx context.Context) attr.Type {
	return RadiusConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadiusConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AcctServersType{}

type AcctServersType struct {
	basetypes.ObjectType
}

func (t AcctServersType) Equal(o attr.Type) bool {
	other, ok := o.(AcctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AcctServersType) String() string {
	return "AcctServersType"
}

func (t AcctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueNull() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAcctServersValueUnknown() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAcctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AcctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, a missing attribute value was detected. "+
					"A AcctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AcctServersValue Attribute Type",
				"While creating a AcctServersValue value, an invalid attribute value was detected. "+
					"A AcctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, an extra attribute value was detected. "+
					"A AcctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AcctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AcctServersValue {
	object, diags := NewAcctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAcctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AcctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAcctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAcctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAcctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAcctServersValueMust(AcctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AcctServersType) ValueType(ctx context.Context) attr.Value {
	return AcctServersValue{}
}

var _ basetypes.ObjectValuable = AcctServersValue{}

type AcctServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AcctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AcctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AcctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AcctServersValue) String() string {
	return "AcctServersValue"
}

func (v AcctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AcctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AcctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AcctServersValue) Type(ctx context.Context) attr.Type {
	return AcctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AcctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthServersType{}

type AuthServersType struct {
	basetypes.ObjectType
}

func (t AuthServersType) Equal(o attr.Type) bool {
	other, ok := o.(AuthServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthServersType) String() string {
	return "AuthServersType"
}

func (t AuthServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueNull() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthServersValueUnknown() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, a missing attribute value was detected. "+
					"A AuthServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthServersValue Attribute Type",
				"While creating a AuthServersValue value, an invalid attribute value was detected. "+
					"A AuthServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, an extra attribute value was detected. "+
					"A AuthServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthServersValue {
	object, diags := NewAuthServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthServersValueMust(AuthServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthServersType) ValueType(ctx context.Context) attr.Value {
	return AuthServersValue{}
}

var _ basetypes.ObjectValuable = AuthServersValue{}

type AuthServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AuthServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthServersValue) String() string {
	return "AuthServersValue"
}

func (v AuthServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AuthServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AuthServersValue) Type(ctx context.Context) attr.Type {
	return AuthServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StpConfigType{}

type StpConfigType struct {
	basetypes.ObjectType
}

func (t StpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(StpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StpConfigType) String() string {
	return "StpConfigType"
}

func (t StpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StpConfigValue{
		StpConfigType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewStpConfigValueNull() StpConfigValue {
	return StpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewStpConfigValueUnknown() StpConfigValue {
	return StpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StpConfigValue Attribute Value",
				"While creating a StpConfigValue value, a missing attribute value was detected. "+
					"A StpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StpConfigValue Attribute Type",
				"While creating a StpConfigValue value, an invalid attribute value was detected. "+
					"A StpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StpConfigValue Attribute Value",
				"While creating a StpConfigValue value, an extra attribute value was detected. "+
					"A StpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStpConfigValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewStpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewStpConfigValueUnknown(), diags
	}

	return StpConfigValue{
		StpConfigType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewStpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StpConfigValue {
	object, diags := NewStpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStpConfigValueMust(StpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StpConfigType) ValueType(ctx context.Context) attr.Value {
	return StpConfigValue{}
}

var _ basetypes.ObjectValuable = StpConfigValue{}

type StpConfigValue struct {
	StpConfigType basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v StpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.StpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StpConfigValue) String() string {
	return "StpConfigValue"
}

func (v StpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type": v.StpConfigType,
		})

	return objVal, diags
}

func (v StpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(StpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.StpConfigType.Equal(other.StpConfigType) {
		return false
	}

	return true
}

func (v StpConfigValue) Type(ctx context.Context) attr.Type {
	return StpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SwitchMgmtType{}

type SwitchMgmtType struct {
	basetypes.ObjectType
}

func (t SwitchMgmtType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchMgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchMgmtType) String() string {
	return "SwitchMgmtType"
}

func (t SwitchMgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configRevertTimerAttribute, ok := attributes["config_revert_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_revert_timer is missing from object`)

		return nil, diags
	}

	configRevertTimerVal, ok := configRevertTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_revert_timer expected to be basetypes.Int64Value, was: %T`, configRevertTimerAttribute))
	}

	protectReAttribute, ok := attributes["protect_re"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protect_re is missing from object`)

		return nil, diags
	}

	protectReVal, ok := protectReAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protect_re expected to be basetypes.ObjectValue, was: %T`, protectReAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchMgmtValue{
		ConfigRevertTimer: configRevertTimerVal,
		ProtectRe:         protectReVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueNull() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchMgmtValueUnknown() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchMgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, a missing attribute value was detected. "+
					"A SwitchMgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchMgmtValue Attribute Type",
				"While creating a SwitchMgmtValue value, an invalid attribute value was detected. "+
					"A SwitchMgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, an extra attribute value was detected. "+
					"A SwitchMgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchMgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	configRevertTimerAttribute, ok := attributes["config_revert_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_revert_timer is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	configRevertTimerVal, ok := configRevertTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_revert_timer expected to be basetypes.Int64Value, was: %T`, configRevertTimerAttribute))
	}

	protectReAttribute, ok := attributes["protect_re"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protect_re is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	protectReVal, ok := protectReAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protect_re expected to be basetypes.ObjectValue, was: %T`, protectReAttribute))
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	return SwitchMgmtValue{
		ConfigRevertTimer: configRevertTimerVal,
		ProtectRe:         protectReVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchMgmtValue {
	object, diags := NewSwitchMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchMgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchMgmtValueMust(SwitchMgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchMgmtType) ValueType(ctx context.Context) attr.Value {
	return SwitchMgmtValue{}
}

var _ basetypes.ObjectValuable = SwitchMgmtValue{}

type SwitchMgmtValue struct {
	ConfigRevertTimer basetypes.Int64Value  `tfsdk:"config_revert_timer"`
	ProtectRe         basetypes.ObjectValue `tfsdk:"protect_re"`
	state             attr.ValueState
}

func (v SwitchMgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["config_revert_timer"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protect_re"] = basetypes.ObjectType{
		AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ConfigRevertTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_revert_timer"] = val

		val, err = v.ProtectRe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protect_re"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchMgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchMgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchMgmtValue) String() string {
	return "SwitchMgmtValue"
}

func (v SwitchMgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var protectRe basetypes.ObjectValue

	if v.ProtectRe.IsNull() {
		protectRe = types.ObjectNull(
			ProtectReValue{}.AttributeTypes(ctx),
		)
	}

	if v.ProtectRe.IsUnknown() {
		protectRe = types.ObjectUnknown(
			ProtectReValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ProtectRe.IsNull() && !v.ProtectRe.IsUnknown() {
		protectRe = types.ObjectValueMust(
			ProtectReValue{}.AttributeTypes(ctx),
			v.ProtectRe.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"config_revert_timer": basetypes.Int64Type{},
		"protect_re": basetypes.ObjectType{
			AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"config_revert_timer": v.ConfigRevertTimer,
			"protect_re":          protectRe,
		})

	return objVal, diags
}

func (v SwitchMgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchMgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfigRevertTimer.Equal(other.ConfigRevertTimer) {
		return false
	}

	if !v.ProtectRe.Equal(other.ProtectRe) {
		return false
	}

	return true
}

func (v SwitchMgmtValue) Type(ctx context.Context) attr.Type {
	return SwitchMgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchMgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config_revert_timer": basetypes.Int64Type{},
		"protect_re": basetypes.ObjectType{
			AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ProtectReType{}

type ProtectReType struct {
	basetypes.ObjectType
}

func (t ProtectReType) Equal(o attr.Type) bool {
	other, ok := o.(ProtectReType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProtectReType) String() string {
	return "ProtectReType"
}

func (t ProtectReType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedServicesAttribute, ok := attributes["allowed_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_services is missing from object`)

		return nil, diags
	}

	allowedServicesVal, ok := allowedServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_services expected to be basetypes.ListValue, was: %T`, allowedServicesAttribute))
	}

	customAttribute, ok := attributes["custom"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom is missing from object`)

		return nil, diags
	}

	customVal, ok := customAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom expected to be basetypes.ListValue, was: %T`, customAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	trustedHostsAttribute, ok := attributes["trusted_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted_hosts is missing from object`)

		return nil, diags
	}

	trustedHostsVal, ok := trustedHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted_hosts expected to be basetypes.ListValue, was: %T`, trustedHostsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProtectReValue{
		AllowedServices: allowedServicesVal,
		Custom:          customVal,
		Enabled:         enabledVal,
		TrustedHosts:    trustedHostsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtectReValueNull() ProtectReValue {
	return ProtectReValue{
		state: attr.ValueStateNull,
	}
}

func NewProtectReValueUnknown() ProtectReValue {
	return ProtectReValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProtectReValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProtectReValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProtectReValue Attribute Value",
				"While creating a ProtectReValue value, a missing attribute value was detected. "+
					"A ProtectReValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProtectReValue Attribute Type",
				"While creating a ProtectReValue value, an invalid attribute value was detected. "+
					"A ProtectReValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProtectReValue Attribute Value",
				"While creating a ProtectReValue value, an extra attribute value was detected. "+
					"A ProtectReValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProtectReValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProtectReValueUnknown(), diags
	}

	allowedServicesAttribute, ok := attributes["allowed_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_services is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	allowedServicesVal, ok := allowedServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_services expected to be basetypes.ListValue, was: %T`, allowedServicesAttribute))
	}

	customAttribute, ok := attributes["custom"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	customVal, ok := customAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom expected to be basetypes.ListValue, was: %T`, customAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	trustedHostsAttribute, ok := attributes["trusted_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted_hosts is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	trustedHostsVal, ok := trustedHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted_hosts expected to be basetypes.ListValue, was: %T`, trustedHostsAttribute))
	}

	if diags.HasError() {
		return NewProtectReValueUnknown(), diags
	}

	return ProtectReValue{
		AllowedServices: allowedServicesVal,
		Custom:          customVal,
		Enabled:         enabledVal,
		TrustedHosts:    trustedHostsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtectReValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProtectReValue {
	object, diags := NewProtectReValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProtectReValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProtectReType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProtectReValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProtectReValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProtectReValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProtectReValueMust(ProtectReValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProtectReType) ValueType(ctx context.Context) attr.Value {
	return ProtectReValue{}
}

var _ basetypes.ObjectValuable = ProtectReValue{}

type ProtectReValue struct {
	AllowedServices basetypes.ListValue `tfsdk:"allowed_services"`
	Custom          basetypes.ListValue `tfsdk:"custom"`
	Enabled         basetypes.BoolValue `tfsdk:"enabled"`
	TrustedHosts    basetypes.ListValue `tfsdk:"trusted_hosts"`
	state           attr.ValueState
}

func (v ProtectReValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["allowed_services"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["custom"] = basetypes.ListType{
		ElemType: CustomValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["trusted_hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AllowedServices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_services"] = val

		val, err = v.Custom.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.TrustedHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trusted_hosts"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProtectReValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProtectReValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProtectReValue) String() string {
	return "ProtectReValue"
}

func (v ProtectReValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	custom := types.ListValueMust(
		CustomType{
			basetypes.ObjectType{
				AttrTypes: CustomValue{}.AttributeTypes(ctx),
			},
		},
		v.Custom.Elements(),
	)

	if v.Custom.IsNull() {
		custom = types.ListNull(
			CustomType{
				basetypes.ObjectType{
					AttrTypes: CustomValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Custom.IsUnknown() {
		custom = types.ListUnknown(
			CustomType{
				basetypes.ObjectType{
					AttrTypes: CustomValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	allowedServicesVal, d := types.ListValue(types.StringType, v.AllowedServices.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom": basetypes.ListType{
				ElemType: CustomValue{}.Type(ctx),
			},
			"enabled": basetypes.BoolType{},
			"trusted_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	trustedHostsVal, d := types.ListValue(types.StringType, v.TrustedHosts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom": basetypes.ListType{
				ElemType: CustomValue{}.Type(ctx),
			},
			"enabled": basetypes.BoolType{},
			"trusted_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allowed_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"custom": basetypes.ListType{
			ElemType: CustomValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"trusted_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_services": allowedServicesVal,
			"custom":           custom,
			"enabled":          v.Enabled,
			"trusted_hosts":    trustedHostsVal,
		})

	return objVal, diags
}

func (v ProtectReValue) Equal(o attr.Value) bool {
	other, ok := o.(ProtectReValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedServices.Equal(other.AllowedServices) {
		return false
	}

	if !v.Custom.Equal(other.Custom) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.TrustedHosts.Equal(other.TrustedHosts) {
		return false
	}

	return true
}

func (v ProtectReValue) Type(ctx context.Context) attr.Type {
	return ProtectReType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProtectReValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"custom": basetypes.ListType{
			ElemType: CustomValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"trusted_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = CustomType{}

type CustomType struct {
	basetypes.ObjectType
}

func (t CustomType) Equal(o attr.Type) bool {
	other, ok := o.(CustomType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomType) String() string {
	return "CustomType"
}

func (t CustomType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return nil, diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.ListValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		Subnet:    subnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCustomValueNull() CustomValue {
	return CustomValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomValueUnknown() CustomValue {
	return CustomValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomValue Attribute Value",
				"While creating a CustomValue value, a missing attribute value was detected. "+
					"A CustomValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomValue Attribute Type",
				"While creating a CustomValue value, an invalid attribute value was detected. "+
					"A CustomValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomValue Attribute Value",
				"While creating a CustomValue value, an extra attribute value was detected. "+
					"A CustomValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.ListValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	return CustomValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		Subnet:    subnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCustomValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomValue {
	object, diags := NewCustomValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomValueMust(CustomValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomType) ValueType(ctx context.Context) attr.Value {
	return CustomValue{}
}

var _ basetypes.ObjectValuable = CustomValue{}

type CustomValue struct {
	PortRange basetypes.StringValue `tfsdk:"port_range"`
	Protocol  basetypes.StringValue `tfsdk:"protocol"`
	Subnet    basetypes.ListValue   `tfsdk:"subnet"`
	state     attr.ValueState
}

func (v CustomValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.PortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomValue) String() string {
	return "CustomValue"
}

func (v CustomValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subnetVal, d := types.ListValue(types.StringType, v.Subnet.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"port_range": basetypes.StringType{},
			"protocol":   basetypes.StringType{},
			"subnet": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_range": v.PortRange,
			"protocol":   v.Protocol,
			"subnet":     subnetVal,
		})

	return objVal, diags
}

func (v CustomValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortRange.Equal(other.PortRange) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	return true
}

func (v CustomValue) Type(ctx context.Context) attr.Type {
	return CustomType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = VirtualChassisType{}

type VirtualChassisType struct {
	basetypes.ObjectType
}

func (t VirtualChassisType) Equal(o attr.Type) bool {
	other, ok := o.(VirtualChassisType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VirtualChassisType) String() string {
	return "VirtualChassisType"
}

func (t VirtualChassisType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	membersAttribute, ok := attributes["members"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members is missing from object`)

		return nil, diags
	}

	membersVal, ok := membersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members expected to be basetypes.ListValue, was: %T`, membersAttribute))
	}

	preprovisionedAttribute, ok := attributes["preprovisioned"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preprovisioned is missing from object`)

		return nil, diags
	}

	preprovisionedVal, ok := preprovisionedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preprovisioned expected to be basetypes.BoolValue, was: %T`, preprovisionedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VirtualChassisValue{
		Members:        membersVal,
		Preprovisioned: preprovisionedVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVirtualChassisValueNull() VirtualChassisValue {
	return VirtualChassisValue{
		state: attr.ValueStateNull,
	}
}

func NewVirtualChassisValueUnknown() VirtualChassisValue {
	return VirtualChassisValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVirtualChassisValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VirtualChassisValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VirtualChassisValue Attribute Value",
				"While creating a VirtualChassisValue value, a missing attribute value was detected. "+
					"A VirtualChassisValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualChassisValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VirtualChassisValue Attribute Type",
				"While creating a VirtualChassisValue value, an invalid attribute value was detected. "+
					"A VirtualChassisValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualChassisValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VirtualChassisValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VirtualChassisValue Attribute Value",
				"While creating a VirtualChassisValue value, an extra attribute value was detected. "+
					"A VirtualChassisValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VirtualChassisValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVirtualChassisValueUnknown(), diags
	}

	membersAttribute, ok := attributes["members"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members is missing from object`)

		return NewVirtualChassisValueUnknown(), diags
	}

	membersVal, ok := membersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members expected to be basetypes.ListValue, was: %T`, membersAttribute))
	}

	preprovisionedAttribute, ok := attributes["preprovisioned"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preprovisioned is missing from object`)

		return NewVirtualChassisValueUnknown(), diags
	}

	preprovisionedVal, ok := preprovisionedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preprovisioned expected to be basetypes.BoolValue, was: %T`, preprovisionedAttribute))
	}

	if diags.HasError() {
		return NewVirtualChassisValueUnknown(), diags
	}

	return VirtualChassisValue{
		Members:        membersVal,
		Preprovisioned: preprovisionedVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVirtualChassisValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VirtualChassisValue {
	object, diags := NewVirtualChassisValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVirtualChassisValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VirtualChassisType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVirtualChassisValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVirtualChassisValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVirtualChassisValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVirtualChassisValueMust(VirtualChassisValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VirtualChassisType) ValueType(ctx context.Context) attr.Value {
	return VirtualChassisValue{}
}

var _ basetypes.ObjectValuable = VirtualChassisValue{}

type VirtualChassisValue struct {
	Members        basetypes.ListValue `tfsdk:"members"`
	Preprovisioned basetypes.BoolValue `tfsdk:"preprovisioned"`
	state          attr.ValueState
}

func (v VirtualChassisValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["members"] = basetypes.ListType{
		ElemType: MembersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["preprovisioned"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Members.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["members"] = val

		val, err = v.Preprovisioned.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preprovisioned"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VirtualChassisValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VirtualChassisValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VirtualChassisValue) String() string {
	return "VirtualChassisValue"
}

func (v VirtualChassisValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	members := types.ListValueMust(
		MembersType{
			basetypes.ObjectType{
				AttrTypes: MembersValue{}.AttributeTypes(ctx),
			},
		},
		v.Members.Elements(),
	)

	if v.Members.IsNull() {
		members = types.ListNull(
			MembersType{
				basetypes.ObjectType{
					AttrTypes: MembersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Members.IsUnknown() {
		members = types.ListUnknown(
			MembersType{
				basetypes.ObjectType{
					AttrTypes: MembersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"members": basetypes.ListType{
			ElemType: MembersValue{}.Type(ctx),
		},
		"preprovisioned": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"members":        members,
			"preprovisioned": v.Preprovisioned,
		})

	return objVal, diags
}

func (v VirtualChassisValue) Equal(o attr.Value) bool {
	other, ok := o.(VirtualChassisValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Members.Equal(other.Members) {
		return false
	}

	if !v.Preprovisioned.Equal(other.Preprovisioned) {
		return false
	}

	return true
}

func (v VirtualChassisValue) Type(ctx context.Context) attr.Type {
	return VirtualChassisType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VirtualChassisValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"members": basetypes.ListType{
			ElemType: MembersValue{}.Type(ctx),
		},
		"preprovisioned": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MembersType{}

type MembersType struct {
	basetypes.ObjectType
}

func (t MembersType) Equal(o attr.Type) bool {
	other, ok := o.(MembersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MembersType) String() string {
	return "MembersType"
}

func (t MembersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	vcRoleAttribute, ok := attributes["vc_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_role is missing from object`)

		return nil, diags
	}

	vcRoleVal, ok := vcRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_role expected to be basetypes.StringValue, was: %T`, vcRoleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MembersValue{
		Mac:    macVal,
		VcRole: vcRoleVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewMembersValueNull() MembersValue {
	return MembersValue{
		state: attr.ValueStateNull,
	}
}

func NewMembersValueUnknown() MembersValue {
	return MembersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMembersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MembersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MembersValue Attribute Value",
				"While creating a MembersValue value, a missing attribute value was detected. "+
					"A MembersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MembersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MembersValue Attribute Type",
				"While creating a MembersValue value, an invalid attribute value was detected. "+
					"A MembersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MembersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MembersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MembersValue Attribute Value",
				"While creating a MembersValue value, an extra attribute value was detected. "+
					"A MembersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MembersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMembersValueUnknown(), diags
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewMembersValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	vcRoleAttribute, ok := attributes["vc_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_role is missing from object`)

		return NewMembersValueUnknown(), diags
	}

	vcRoleVal, ok := vcRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_role expected to be basetypes.StringValue, was: %T`, vcRoleAttribute))
	}

	if diags.HasError() {
		return NewMembersValueUnknown(), diags
	}

	return MembersValue{
		Mac:    macVal,
		VcRole: vcRoleVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewMembersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MembersValue {
	object, diags := NewMembersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMembersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MembersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMembersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMembersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMembersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMembersValueMust(MembersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MembersType) ValueType(ctx context.Context) attr.Value {
	return MembersValue{}
}

var _ basetypes.ObjectValuable = MembersValue{}

type MembersValue struct {
	Mac    basetypes.StringValue `tfsdk:"mac"`
	VcRole basetypes.StringValue `tfsdk:"vc_role"`
	state  attr.ValueState
}

func (v MembersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vc_role"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.VcRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_role"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MembersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MembersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MembersValue) String() string {
	return "MembersValue"
}

func (v MembersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mac":     basetypes.StringType{},
		"vc_role": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mac":     v.Mac,
			"vc_role": v.VcRole,
		})

	return objVal, diags
}

func (v MembersValue) Equal(o attr.Value) bool {
	other, ok := o.(MembersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.VcRole.Equal(other.VcRole) {
		return false
	}

	return true
}

func (v MembersValue) Type(ctx context.Context) attr.Type {
	return MembersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MembersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mac":     basetypes.StringType{},
		"vc_role": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VrfConfigType{}

type VrfConfigType struct {
	basetypes.ObjectType
}

func (t VrfConfigType) Equal(o attr.Type) bool {
	other, ok := o.(VrfConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfConfigType) String() string {
	return "VrfConfigType"
}

func (t VrfConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueNull() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfConfigValueUnknown() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, a missing attribute value was detected. "+
					"A VrfConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfConfigValue Attribute Type",
				"While creating a VrfConfigValue value, an invalid attribute value was detected. "+
					"A VrfConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, an extra attribute value was detected. "+
					"A VrfConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewVrfConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfConfigValue {
	object, diags := NewVrfConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfConfigValueMust(VrfConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfConfigType) ValueType(ctx context.Context) attr.Value {
	return VrfConfigValue{}
}

var _ basetypes.ObjectValuable = VrfConfigValue{}

type VrfConfigValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v VrfConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfConfigValue) String() string {
	return "VrfConfigValue"
}

func (v VrfConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v VrfConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v VrfConfigValue) Type(ctx context.Context) attr.Type {
	return VrfConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VrrpConfigType{}

type VrrpConfigType struct {
	basetypes.ObjectType
}

func (t VrrpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(VrrpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrrpConfigType) String() string {
	return "VrrpConfigType"
}

func (t VrrpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupsAttribute, ok := attributes["groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`groups is missing from object`)

		return nil, diags
	}

	groupsVal, ok := groupsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`groups expected to be basetypes.MapValue, was: %T`, groupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrrpConfigValue{
		Enabled: enabledVal,
		Groups:  groupsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrrpConfigValueNull() VrrpConfigValue {
	return VrrpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewVrrpConfigValueUnknown() VrrpConfigValue {
	return VrrpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrrpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrrpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrrpConfigValue Attribute Value",
				"While creating a VrrpConfigValue value, a missing attribute value was detected. "+
					"A VrrpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrrpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrrpConfigValue Attribute Type",
				"While creating a VrrpConfigValue value, an invalid attribute value was detected. "+
					"A VrrpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrrpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrrpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrrpConfigValue Attribute Value",
				"While creating a VrrpConfigValue value, an extra attribute value was detected. "+
					"A VrrpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrrpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrrpConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewVrrpConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupsAttribute, ok := attributes["groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`groups is missing from object`)

		return NewVrrpConfigValueUnknown(), diags
	}

	groupsVal, ok := groupsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`groups expected to be basetypes.MapValue, was: %T`, groupsAttribute))
	}

	if diags.HasError() {
		return NewVrrpConfigValueUnknown(), diags
	}

	return VrrpConfigValue{
		Enabled: enabledVal,
		Groups:  groupsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrrpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrrpConfigValue {
	object, diags := NewVrrpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrrpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrrpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrrpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrrpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrrpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrrpConfigValueMust(VrrpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrrpConfigType) ValueType(ctx context.Context) attr.Value {
	return VrrpConfigValue{}
}

var _ basetypes.ObjectValuable = VrrpConfigValue{}

type VrrpConfigValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Groups  basetypes.MapValue  `tfsdk:"groups"`
	state   attr.ValueState
}

func (v VrrpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["groups"] = basetypes.MapType{
		ElemType: GroupsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Groups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["groups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrrpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrrpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrrpConfigValue) String() string {
	return "VrrpConfigValue"
}

func (v VrrpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	groups := types.MapValueMust(
		GroupsType{
			basetypes.ObjectType{
				AttrTypes: GroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.Groups.Elements(),
	)

	if v.Groups.IsNull() {
		groups = types.MapNull(
			GroupsType{
				basetypes.ObjectType{
					AttrTypes: GroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Groups.IsUnknown() {
		groups = types.MapUnknown(
			GroupsType{
				basetypes.ObjectType{
					AttrTypes: GroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"groups": basetypes.MapType{
			ElemType: GroupsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"groups":  groups,
		})

	return objVal, diags
}

func (v VrrpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(VrrpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Groups.Equal(other.Groups) {
		return false
	}

	return true
}

func (v VrrpConfigValue) Type(ctx context.Context) attr.Type {
	return VrrpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrrpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"groups": basetypes.MapType{
			ElemType: GroupsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = GroupsType{}

type GroupsType struct {
	basetypes.ObjectType
}

func (t GroupsType) Equal(o attr.Type) bool {
	other, ok := o.(GroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GroupsType) String() string {
	return "GroupsType"
}

func (t GroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return nil, diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.Int64Value, was: %T`, priorityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GroupsValue{
		Priority: priorityVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewGroupsValueNull() GroupsValue {
	return GroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewGroupsValueUnknown() GroupsValue {
	return GroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GroupsValue Attribute Value",
				"While creating a GroupsValue value, a missing attribute value was detected. "+
					"A GroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GroupsValue Attribute Type",
				"While creating a GroupsValue value, an invalid attribute value was detected. "+
					"A GroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GroupsValue Attribute Value",
				"While creating a GroupsValue value, an extra attribute value was detected. "+
					"A GroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGroupsValueUnknown(), diags
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return NewGroupsValueUnknown(), diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.Int64Value, was: %T`, priorityAttribute))
	}

	if diags.HasError() {
		return NewGroupsValueUnknown(), diags
	}

	return GroupsValue{
		Priority: priorityVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GroupsValue {
	object, diags := NewGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGroupsValueMust(GroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GroupsType) ValueType(ctx context.Context) attr.Value {
	return GroupsValue{}
}

var _ basetypes.ObjectValuable = GroupsValue{}

type GroupsValue struct {
	Priority basetypes.Int64Value `tfsdk:"priority"`
	state    attr.ValueState
}

func (v GroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["priority"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Priority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["priority"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GroupsValue) String() string {
	return "GroupsValue"
}

func (v GroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"priority": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"priority": v.Priority,
		})

	return objVal, diags
}

func (v GroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(GroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Priority.Equal(other.Priority) {
		return false
	}

	return true
}

func (v GroupsValue) Type(ctx context.Context) attr.Type {
	return GroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"priority": basetypes.Int64Type{},
	}
}
