// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_device_gateway

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DeviceGatewayResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"additional_config_cmds": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
				MarkdownDescription: "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
			},
			"device_id": schema.StringAttribute{
				Computed: true,
			},
			"deviceprofile_id": schema.StringAttribute{
				Optional: true,
			},
			"dhcpd_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"config": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"dns_servers": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "if `type`==`local` - optional, if not defined, system one will be used",
									MarkdownDescription: "if `type`==`local` - optional, if not defined, system one will be used",
								},
								"dns_suffix": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`local` - optional, if not defined, system one will be used",
									MarkdownDescription: "if `type`==`local` - optional, if not defined, system one will be used",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"fixed_bindings": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ip": schema.StringAttribute{
												Optional: true,
											},
											"name": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: FixedBindingsType{
											ObjectType: types.ObjectType{
												AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key is the MAC Address",
									MarkdownDescription: "Property key is the MAC Address",
								},
								"gateway": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type`==`local` - optional, `ip` will be used if not provided",
									MarkdownDescription: "if `type`==`local` - optional, `ip` will be used if not provided",
								},
								"ip_end": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type`==`local`",
									MarkdownDescription: "if `type`==`local`",
								},
								"ip_end6": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type6`==`local`",
									MarkdownDescription: "if `type6`==`local`",
								},
								"ip_start": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type`==`local`",
									MarkdownDescription: "if `type`==`local`",
								},
								"ip_start6": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type6`==`local`",
									MarkdownDescription: "if `type6`==`local`",
								},
								"lease_time": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]",
									MarkdownDescription: "in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]",
									Validators: []validator.Int64{
										int64validator.Between(3600, 604800),
									},
									Default: int64default.StaticInt64(86400),
								},
								"options": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"string",
														"boolean",
														"ip",
														"hex",
														"int16",
														"int32",
														"uint16",
														"uint32",
													),
												},
											},
											"value": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: OptionsType{
											ObjectType: types.ObjectType{
												AttrTypes: OptionsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key is the DHCP option number",
									MarkdownDescription: "Property key is the DHCP option number",
								},
								"server_id_override": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "`server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, \nshould overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.",
									MarkdownDescription: "`server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, \nshould overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.",
									Default:             booldefault.StaticBool(false),
								},
								"servers": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`relay`",
									MarkdownDescription: "if `type`==`relay`",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"servers6": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type6`==`relay`",
									MarkdownDescription: "if `type6`==`relay`",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "DHCP Server (local) or DHCP Relay (relay)",
									MarkdownDescription: "DHCP Server (local) or DHCP Relay (relay)",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"local",
											"relay",
											"none",
										),
									},
									Default: stringdefault.StaticString("local"),
								},
								"type6": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "DHCP Server (local) or DHCP Relay (relay)",
									MarkdownDescription: "DHCP Server (local) or DHCP Relay (relay)",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"local",
											"relay",
											"none",
										),
									},
									Default: stringdefault.StaticString("none"),
								},
								"vendor_encapulated": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"string",
														"boolean",
														"ip",
														"hex",
														"int16",
														"int32",
														"uint16",
														"uint32",
													),
												},
											},
											"value": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: VendorEncapulatedType{
											ObjectType: types.ObjectType{
												AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key is <enterprise number>:<sub option code>, with\n* enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)\n* sub option code: 1-255, sub-option code",
									MarkdownDescription: "Property key is <enterprise number>:<sub option code>, with\n* enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)\n* sub option code: 1-255, sub-option code",
								},
							},
							CustomType: ConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "if set to `true`, disable the DHCP server",
						MarkdownDescription: "if set to `true`, disable the DHCP server",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: DhcpdConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: DhcpdConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"extra_routes": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"via": schema.StringAttribute{
							Optional: true,
						},
					},
					CustomType: ExtraRoutesType{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"image1_url": schema.StringAttribute{
				Optional: true,
			},
			"image2_url": schema.StringAttribute{
				Optional: true,
			},
			"image3_url": schema.StringAttribute{
				Optional: true,
			},
			"ip_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ip": schema.StringAttribute{
							Optional: true,
						},
						"netmask": schema.StringAttribute{
							Optional: true,
						},
						"secondary_ips": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "optional list of secondary IPs in CIDR format",
							MarkdownDescription: "optional list of secondary IPs in CIDR format",
						},
					},
					CustomType: IpConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the network name",
				MarkdownDescription: "Property key is the network name",
			},
			"managed": schema.BoolAttribute{
				Optional: true,
			},
			"map_id": schema.StringAttribute{
				Optional:            true,
				Description:         "map where the device belongs to",
				MarkdownDescription: "map where the device belongs to",
			},
			"msp_id": schema.StringAttribute{
				Optional: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"networks": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"vlan_id": schema.Int64Attribute{
							Optional: true,
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the network name or a CIDR",
				MarkdownDescription: "Property key is the network name or a CIDR",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(0),
				},
			},
			"ntp_servers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"oob_ip_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"ip": schema.StringAttribute{
						Optional: true,
					},
					"netmask": schema.StringAttribute{
						Optional:            true,
						Description:         "used only if `subnet` is not specified in `networks`",
						MarkdownDescription: "used only if `subnet` is not specified in `networks`",
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Description:         "optional, the network to be used for mgmt",
						MarkdownDescription: "optional, the network to be used for mgmt",
					},
					"node1": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"ip": schema.StringAttribute{
								Optional: true,
							},
							"netmask": schema.StringAttribute{
								Optional:            true,
								Description:         "used only if `subnet` is not specified in `networks`",
								MarkdownDescription: "used only if `subnet` is not specified in `networks`",
							},
							"network": schema.StringAttribute{
								Optional:            true,
								Description:         "optional, the network to be used for mgmt",
								MarkdownDescription: "optional, the network to be used for mgmt",
							},
							"type": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"static",
										"dynamic",
									),
								},
								Default: stringdefault.StaticString("dynamic"),
							},
							"use_mgmt_vrf": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "if supported on the platform. If enabled, DNS will be using this routing-instance, too",
								MarkdownDescription: "if supported on the platform. If enabled, DNS will be using this routing-instance, too",
								Default:             booldefault.StaticBool(false),
							},
							"use_mgmt_vrf_for_host_out": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
								MarkdownDescription: "whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
								Default:             booldefault.StaticBool(false),
							},
						},
						CustomType: Node1Type{
							ObjectType: types.ObjectType{
								AttrTypes: Node1Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "for HA Cluster, node1 can have different IP Config",
						MarkdownDescription: "for HA Cluster, node1 can have different IP Config",
					},
					"type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"static",
								"dynamic",
							),
						},
						Default: stringdefault.StaticString("dynamic"),
					},
					"use_mgmt_vrf": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "f supported on the platform. If enabled, DNS will be using this routing-instance, too",
						MarkdownDescription: "f supported on the platform. If enabled, DNS will be using this routing-instance, too",
						Default:             booldefault.StaticBool(false),
					},
					"use_mgmt_vrf_for_host_out": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,",
						MarkdownDescription: "for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: OobIpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "out-of-band (vme/em0/fxp0) IP config",
				MarkdownDescription: "out-of-band (vme/em0/fxp0) IP config",
			},
			"org_id": schema.StringAttribute{
				Computed: true,
			},
			"port_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Optional: true,
						},
						"disable_autoneg": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "port admin up (true) / down (false)",
							MarkdownDescription: "port admin up (true) / down (false)",
							Default:             booldefault.StaticBool(false),
						},
						"dsl_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"vdsl",
									"adsl",
								),
							},
							Default: stringdefault.StaticString("vdsl"),
						},
						"dsl_vci": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`dsl`\n16 bit int",
							MarkdownDescription: "if `wan_type`==`dsl`\n16 bit int",
							Default:             int64default.StaticInt64(35),
						},
						"dsl_vpi": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`dsl`\n8 bit int",
							MarkdownDescription: "if `wan_type`==`dsl`\n8 bit int",
							Default:             int64default.StaticInt64(0),
						},
						"duplex": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"half",
									"full",
									"auto",
								),
							},
							Default: stringdefault.StaticString("auto"),
						},
						"ip_config": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dns": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "except for out-of_band interface (vme/em0/fxp0)",
									MarkdownDescription: "except for out-of_band interface (vme/em0/fxp0)",
								},
								"dns_suffix": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "except for out-of_band interface (vme/em0/fxp0)",
									MarkdownDescription: "except for out-of_band interface (vme/em0/fxp0)",
								},
								"gateway": schema.StringAttribute{
									Optional:            true,
									Description:         "except for out-of_band interface (vme/em0/fxp0)",
									MarkdownDescription: "except for out-of_band interface (vme/em0/fxp0)",
								},
								"ip": schema.StringAttribute{
									Optional: true,
								},
								"netmask": schema.StringAttribute{
									Optional:            true,
									Description:         "used only if `subnet` is not specified in `networks`",
									MarkdownDescription: "used only if `subnet` is not specified in `networks`",
								},
								"network": schema.StringAttribute{
									Optional:            true,
									Description:         "optional, the network to be used for mgmt",
									MarkdownDescription: "optional, the network to be used for mgmt",
								},
								"poser_password": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type`==`pppoe`",
									MarkdownDescription: "if `type`==`pppoe`",
								},
								"pppoe_auth": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`pppoe`",
									MarkdownDescription: "if `type`==`pppoe`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"none",
											"chap",
											"pap",
										),
									},
									Default: stringdefault.StaticString("none"),
								},
								"pppoe_username": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type`==`pppoe`",
									MarkdownDescription: "if `type`==`pppoe`",
								},
								"type": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"dhcp",
											"static",
											"pppoe",
										),
									},
									Default: stringdefault.StaticString("dhcp"),
								},
							},
							CustomType: IpConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Junos IP Config",
							MarkdownDescription: "Junos IP Config",
						},
						"lte_apn": schema.StringAttribute{
							Optional:            true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
						},
						"lte_auth": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"none",
									"chap",
									"pap",
								),
							},
							Default: stringdefault.StaticString("none"),
						},
						"lte_backup": schema.BoolAttribute{
							Optional: true,
						},
						"lte_password": schema.StringAttribute{
							Optional:            true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
						},
						"lte_username": schema.StringAttribute{
							Optional:            true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
						},
						"mtu": schema.Int64Attribute{
							Optional: true,
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Description:         "name that we'll use to derive config",
							MarkdownDescription: "name that we'll use to derive config",
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "if `usage`==`lan`",
							MarkdownDescription: "if `usage`==`lan`",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"outer_vlan_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "for Q-in-Q",
							MarkdownDescription: "for Q-in-Q",
						},
						"poe_disabled": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"port_network": schema.StringAttribute{
							Optional:            true,
							Description:         "if `usage`==`lan`",
							MarkdownDescription: "if `usage`==`lan`",
						},
						"preserve_dscp": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether to preserve dscp when sending traffic over VPN (SSR-only)",
							MarkdownDescription: "whether to preserve dscp when sending traffic over VPN (SSR-only)",
							Default:             booldefault.StaticBool(true),
						},
						"redundant": schema.BoolAttribute{
							Optional:            true,
							Description:         "if HA mode",
							MarkdownDescription: "if HA mode",
						},
						"reth_idx": schema.Int64Attribute{
							Optional:            true,
							Description:         "if HA mode",
							MarkdownDescription: "if HA mode",
						},
						"reth_node": schema.StringAttribute{
							Optional:            true,
							Description:         "if HA mode",
							MarkdownDescription: "if HA mode",
						},
						"reth_nodes": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "SSR only - supporting vlan-based redundancy (matching the size of `networks`)",
							MarkdownDescription: "SSR only - supporting vlan-based redundancy (matching the size of `networks`)",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"speed": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Default:  stringdefault.StaticString("auto"),
						},
						"ssr_no_virtual_mac": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "when SSR is running as VM, this is required on certain hosting platforms",
							MarkdownDescription: "when SSR is running as VM, this is required on certain hosting platforms",
							Default:             booldefault.StaticBool(false),
						},
						"svr_port_range": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "for SSR only",
							MarkdownDescription: "for SSR only",
							Default:             stringdefault.StaticString("none"),
						},
						"traffic_shaping": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"class_percentages": schema.ListAttribute{
									ElementType:         types.Int64Type,
									Optional:            true,
									Description:         "percentages for differet class of traffic: high / medium / low / best-effort\nsum must be equal to 100",
									MarkdownDescription: "percentages for differet class of traffic: high / medium / low / best-effort\nsum must be equal to 100",
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
							},
							CustomType: TrafficShapingType{
								ObjectType: types.ObjectType{
									AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"usage": schema.StringAttribute{
							Required:            true,
							Description:         "port usage name",
							MarkdownDescription: "port usage name",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"lan",
									"wan",
									"ha_data",
									"ha_control",
								),
							},
						},
						"vlan_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "if WAN interface is on a VLAN",
							MarkdownDescription: "if WAN interface is on a VLAN",
						},
						"vpn_paths": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"bfd_profile": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"lte",
												"broadband",
											),
										},
										Default: stringdefault.StaticString("broadband"),
									},
									"bfd_use_tunnel_mode": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "whether to use tunnel mode. SSR only",
										MarkdownDescription: "whether to use tunnel mode. SSR only",
										Default:             booldefault.StaticBool(false),
									},
									"preference": schema.Int64Attribute{
										Optional:            true,
										Description:         "for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)",
										MarkdownDescription: "for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)",
									},
									"role": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"spoke",
												"hub",
											),
										},
										Default: stringdefault.StaticString("spoke"),
									},
									"traffic_shaping": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"class_percentages": schema.ListAttribute{
												ElementType:         types.Int64Type,
												Optional:            true,
												Description:         "percentages for differet class of traffic: high / medium / low / best-effort\nsum must be equal to 100",
												MarkdownDescription: "percentages for differet class of traffic: high / medium / low / best-effort\nsum must be equal to 100",
											},
											"enabled": schema.BoolAttribute{
												Optional: true,
												Computed: true,
												Default:  booldefault.StaticBool(false),
											},
										},
										CustomType: TrafficShapingType{
											ObjectType: types.ObjectType{
												AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: VpnPathsType{
									ObjectType: types.ObjectType{
										AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
						"wan_arp_policer": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "when `wan_type`==`broadband`",
							MarkdownDescription: "when `wan_type`==`broadband`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"recommended",
									"default",
									"max",
								),
							},
							Default: stringdefault.StaticString("recommended"),
						},
						"wan_ext_ip": schema.StringAttribute{
							Optional:            true,
							Description:         "optional, if spoke should reach this port by a different IP",
							MarkdownDescription: "optional, if spoke should reach this port by a different IP",
						},
						"wan_source_nat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"disabled": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "or to disable the source-nat",
									MarkdownDescription: "or to disable the source-nat",
									Default:             booldefault.StaticBool(false),
								},
								"nat_pool": schema.StringAttribute{
									Optional:            true,
									Description:         "if alternative nat_pool is desired",
									MarkdownDescription: "if alternative nat_pool is desired",
								},
							},
							CustomType: WanSourceNatType{
								ObjectType: types.ObjectType{
									AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "optional, by default, source-NAT is performed on all WAN Ports using the interface-ip",
							MarkdownDescription: "optional, by default, source-NAT is performed on all WAN Ports using the interface-ip",
						},
						"wan_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `usage`==`wan`",
							MarkdownDescription: "if `usage`==`wan`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"broadband",
									"dsl",
									"lte",
								),
							},
							Default: stringdefault.StaticString("broadband"),
						},
					},
					CustomType: PortConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the port name or range (e.g. \"ge-0/0/0-10\")",
				MarkdownDescription: "Property key is the port name or range (e.g. \"ge-0/0/0-10\")",
			},
			"port_mirroring": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"port_mirror": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"family_type": schema.StringAttribute{
								Optional: true,
							},
							"ingress_port_ids": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
							},
							"output_port_id": schema.StringAttribute{
								Optional: true,
							},
							"rate": schema.Int64Attribute{
								Optional: true,
							},
							"run_length": schema.Int64Attribute{
								Optional: true,
								Validators: []validator.Int64{
									int64validator.AtLeast(0),
								},
							},
						},
						CustomType: PortMirrorType{
							ObjectType: types.ObjectType{
								AttrTypes: PortMirrorValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: PortMirroringType{
					ObjectType: types.ObjectType{
						AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"site_id": schema.StringAttribute{
				Required: true,
			},
			"vars": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "a dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
				MarkdownDescription: "a dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
			},
			"x": schema.Float64Attribute{
				Optional:            true,
				Description:         "x in pixel",
				MarkdownDescription: "x in pixel",
			},
			"y": schema.Float64Attribute{
				Optional:            true,
				Description:         "y in pixel",
				MarkdownDescription: "y in pixel",
			},
		},
	}
}

type DeviceGatewayModel struct {
	AdditionalConfigCmds types.List         `tfsdk:"additional_config_cmds"`
	DeviceId             types.String       `tfsdk:"device_id"`
	DeviceprofileId      types.String       `tfsdk:"deviceprofile_id"`
	DhcpdConfig          DhcpdConfigValue   `tfsdk:"dhcpd_config"`
	ExtraRoutes          types.Map          `tfsdk:"extra_routes"`
	Image1Url            types.String       `tfsdk:"image1_url"`
	Image2Url            types.String       `tfsdk:"image2_url"`
	Image3Url            types.String       `tfsdk:"image3_url"`
	IpConfig             types.Map          `tfsdk:"ip_config"`
	Managed              types.Bool         `tfsdk:"managed"`
	MapId                types.String       `tfsdk:"map_id"`
	MspId                types.String       `tfsdk:"msp_id"`
	Name                 types.String       `tfsdk:"name"`
	Networks             types.Map          `tfsdk:"networks"`
	NtpServers           types.List         `tfsdk:"ntp_servers"`
	OobIpConfig          OobIpConfigValue   `tfsdk:"oob_ip_config"`
	OrgId                types.String       `tfsdk:"org_id"`
	PortConfig           types.Map          `tfsdk:"port_config"`
	PortMirroring        PortMirroringValue `tfsdk:"port_mirroring"`
	SiteId               types.String       `tfsdk:"site_id"`
	Vars                 types.Map          `tfsdk:"vars"`
	X                    types.Float64      `tfsdk:"x"`
	Y                    types.Float64      `tfsdk:"y"`
}

var _ basetypes.ObjectTypable = DhcpdConfigType{}

type DhcpdConfigType struct {
	basetypes.ObjectType
}

func (t DhcpdConfigType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpdConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpdConfigType) String() string {
	return "DhcpdConfigType"
}

func (t DhcpdConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return nil, diags
	}

	configVal, ok := configAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.MapValue, was: %T`, configAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpdConfigValue{
		Config:  configVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpdConfigValueNull() DhcpdConfigValue {
	return DhcpdConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpdConfigValueUnknown() DhcpdConfigValue {
	return DhcpdConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpdConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpdConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpdConfigValue Attribute Value",
				"While creating a DhcpdConfigValue value, a missing attribute value was detected. "+
					"A DhcpdConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpdConfigValue Attribute Type",
				"While creating a DhcpdConfigValue value, an invalid attribute value was detected. "+
					"A DhcpdConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpdConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpdConfigValue Attribute Value",
				"While creating a DhcpdConfigValue value, an extra attribute value was detected. "+
					"A DhcpdConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpdConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpdConfigValueUnknown(), diags
	}

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return NewDhcpdConfigValueUnknown(), diags
	}

	configVal, ok := configAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.MapValue, was: %T`, configAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDhcpdConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewDhcpdConfigValueUnknown(), diags
	}

	return DhcpdConfigValue{
		Config:  configVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpdConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpdConfigValue {
	object, diags := NewDhcpdConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpdConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpdConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpdConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpdConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpdConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpdConfigValueMust(DhcpdConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpdConfigType) ValueType(ctx context.Context) attr.Value {
	return DhcpdConfigValue{}
}

var _ basetypes.ObjectValuable = DhcpdConfigValue{}

type DhcpdConfigValue struct {
	Config  basetypes.MapValue  `tfsdk:"config"`
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v DhcpdConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["config"] = basetypes.MapType{
		ElemType: ConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Config.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpdConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpdConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpdConfigValue) String() string {
	return "DhcpdConfigValue"
}

func (v DhcpdConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	config := types.MapValueMust(
		ConfigType{
			basetypes.ObjectType{
				AttrTypes: ConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.Config.Elements(),
	)

	if v.Config.IsNull() {
		config = types.MapNull(
			ConfigType{
				basetypes.ObjectType{
					AttrTypes: ConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Config.IsUnknown() {
		config = types.MapUnknown(
			ConfigType{
				basetypes.ObjectType{
					AttrTypes: ConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"config": basetypes.MapType{
			ElemType: ConfigValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"config":  config,
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v DhcpdConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpdConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Config.Equal(other.Config) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v DhcpdConfigValue) Type(ctx context.Context) attr.Type {
	return DhcpdConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpdConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config": basetypes.MapType{
			ElemType: ConfigValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ConfigType{}

type ConfigType struct {
	basetypes.ObjectType
}

func (t ConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigType) String() string {
	return "ConfigType"
}

func (t ConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsServersAttribute, ok := attributes["dns_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_servers is missing from object`)

		return nil, diags
	}

	dnsServersVal, ok := dnsServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_servers expected to be basetypes.ListValue, was: %T`, dnsServersAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	fixedBindingsAttribute, ok := attributes["fixed_bindings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_bindings is missing from object`)

		return nil, diags
	}

	fixedBindingsVal, ok := fixedBindingsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_bindings expected to be basetypes.MapValue, was: %T`, fixedBindingsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipEnd4Attribute, ok := attributes["ip_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end is missing from object`)

		return nil, diags
	}

	ipEnd4Val, ok := ipEnd4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end expected to be basetypes.StringValue, was: %T`, ipEnd4Attribute))
	}

	ipEnd6Attribute, ok := attributes["ip_end6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end6 is missing from object`)

		return nil, diags
	}

	ipEnd6Val, ok := ipEnd6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end6 expected to be basetypes.StringValue, was: %T`, ipEnd6Attribute))
	}

	ipStart4Attribute, ok := attributes["ip_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start is missing from object`)

		return nil, diags
	}

	ipStart4Val, ok := ipStart4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start expected to be basetypes.StringValue, was: %T`, ipStart4Attribute))
	}

	ipStart6Attribute, ok := attributes["ip_start6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start6 is missing from object`)

		return nil, diags
	}

	ipStart6Val, ok := ipStart6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start6 expected to be basetypes.StringValue, was: %T`, ipStart6Attribute))
	}

	leaseTimeAttribute, ok := attributes["lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lease_time is missing from object`)

		return nil, diags
	}

	leaseTimeVal, ok := leaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lease_time expected to be basetypes.Int64Value, was: %T`, leaseTimeAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return nil, diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	serverIdOverrideAttribute, ok := attributes["server_id_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id_override is missing from object`)

		return nil, diags
	}

	serverIdOverrideVal, ok := serverIdOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id_override expected to be basetypes.BoolValue, was: %T`, serverIdOverrideAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	servers6Attribute, ok := attributes["servers6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers6 is missing from object`)

		return nil, diags
	}

	servers6Val, ok := servers6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers6 expected to be basetypes.ListValue, was: %T`, servers6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return nil, diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vendorEncapulatedAttribute, ok := attributes["vendor_encapulated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_encapulated is missing from object`)

		return nil, diags
	}

	vendorEncapulatedVal, ok := vendorEncapulatedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_encapulated expected to be basetypes.MapValue, was: %T`, vendorEncapulatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigValue{
		DnsServers:        dnsServersVal,
		DnsSuffix:         dnsSuffixVal,
		FixedBindings:     fixedBindingsVal,
		Gateway:           gatewayVal,
		IpEnd4:            ipEnd4Val,
		IpEnd6:            ipEnd6Val,
		IpStart4:          ipStart4Val,
		IpStart6:          ipStart6Val,
		LeaseTime:         leaseTimeVal,
		Options:           optionsVal,
		ServerIdOverride:  serverIdOverrideVal,
		Servers4:          serversVal,
		Servers6:          servers6Val,
		Type4:             typeVal,
		Type6:             type6Val,
		VendorEncapulated: vendorEncapulatedVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewConfigValueNull() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigValueUnknown() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigValue Attribute Value",
				"While creating a ConfigValue value, a missing attribute value was detected. "+
					"A ConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigValue Attribute Type",
				"While creating a ConfigValue value, an invalid attribute value was detected. "+
					"A ConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigValue Attribute Value",
				"While creating a ConfigValue value, an extra attribute value was detected. "+
					"A ConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	dnsServersAttribute, ok := attributes["dns_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_servers is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dnsServersVal, ok := dnsServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_servers expected to be basetypes.ListValue, was: %T`, dnsServersAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	fixedBindingsAttribute, ok := attributes["fixed_bindings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_bindings is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	fixedBindingsVal, ok := fixedBindingsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_bindings expected to be basetypes.MapValue, was: %T`, fixedBindingsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipEnd4Attribute, ok := attributes["ip_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipEnd4Val, ok := ipEnd4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end expected to be basetypes.StringValue, was: %T`, ipEnd4Attribute))
	}

	ipEnd6Attribute, ok := attributes["ip_end6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipEnd6Val, ok := ipEnd6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end6 expected to be basetypes.StringValue, was: %T`, ipEnd6Attribute))
	}

	ipStart4Attribute, ok := attributes["ip_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipStart4Val, ok := ipStart4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start expected to be basetypes.StringValue, was: %T`, ipStart4Attribute))
	}

	ipStart6Attribute, ok := attributes["ip_start6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipStart6Val, ok := ipStart6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start6 expected to be basetypes.StringValue, was: %T`, ipStart6Attribute))
	}

	leaseTimeAttribute, ok := attributes["lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lease_time is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	leaseTimeVal, ok := leaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lease_time expected to be basetypes.Int64Value, was: %T`, leaseTimeAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	serverIdOverrideAttribute, ok := attributes["server_id_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id_override is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	serverIdOverrideVal, ok := serverIdOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id_override expected to be basetypes.BoolValue, was: %T`, serverIdOverrideAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	servers6Attribute, ok := attributes["servers6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	servers6Val, ok := servers6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers6 expected to be basetypes.ListValue, was: %T`, servers6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vendorEncapulatedAttribute, ok := attributes["vendor_encapulated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_encapulated is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	vendorEncapulatedVal, ok := vendorEncapulatedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_encapulated expected to be basetypes.MapValue, was: %T`, vendorEncapulatedAttribute))
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	return ConfigValue{
		DnsServers:        dnsServersVal,
		DnsSuffix:         dnsSuffixVal,
		FixedBindings:     fixedBindingsVal,
		Gateway:           gatewayVal,
		IpEnd4:            ipEnd4Val,
		IpEnd6:            ipEnd6Val,
		IpStart4:          ipStart4Val,
		IpStart6:          ipStart6Val,
		LeaseTime:         leaseTimeVal,
		Options:           optionsVal,
		ServerIdOverride:  serverIdOverrideVal,
		Servers4:          serversVal,
		Servers6:          servers6Val,
		Type4:             typeVal,
		Type6:             type6Val,
		VendorEncapulated: vendorEncapulatedVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigValue {
	object, diags := NewConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigValueMust(ConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigType) ValueType(ctx context.Context) attr.Value {
	return ConfigValue{}
}

var _ basetypes.ObjectValuable = ConfigValue{}

type ConfigValue struct {
	DnsServers        basetypes.ListValue   `tfsdk:"dns_servers"`
	DnsSuffix         basetypes.ListValue   `tfsdk:"dns_suffix"`
	FixedBindings     basetypes.MapValue    `tfsdk:"fixed_bindings"`
	Gateway           basetypes.StringValue `tfsdk:"gateway"`
	IpEnd4            basetypes.StringValue `tfsdk:"ip_end"`
	IpEnd6            basetypes.StringValue `tfsdk:"ip_end6"`
	IpStart4          basetypes.StringValue `tfsdk:"ip_start"`
	IpStart6          basetypes.StringValue `tfsdk:"ip_start6"`
	LeaseTime         basetypes.Int64Value  `tfsdk:"lease_time"`
	Options           basetypes.MapValue    `tfsdk:"options"`
	ServerIdOverride  basetypes.BoolValue   `tfsdk:"server_id_override"`
	Servers4          basetypes.ListValue   `tfsdk:"servers"`
	Servers6          basetypes.ListValue   `tfsdk:"servers6"`
	Type4             basetypes.StringValue `tfsdk:"type"`
	Type6             basetypes.StringValue `tfsdk:"type6"`
	VendorEncapulated basetypes.MapValue    `tfsdk:"vendor_encapulated"`
	state             attr.ValueState
}

func (v ConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["dns_servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["fixed_bindings"] = basetypes.MapType{
		ElemType: FixedBindingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_end"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_end6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_start"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_start6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lease_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["options"] = basetypes.MapType{
		ElemType: OptionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["server_id_override"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["servers6"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vendor_encapulated"] = basetypes.MapType{
		ElemType: VendorEncapulatedValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.DnsServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_servers"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.FixedBindings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_bindings"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.IpEnd4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_end"] = val

		val, err = v.IpEnd6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_end6"] = val

		val, err = v.IpStart4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_start"] = val

		val, err = v.IpStart6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_start6"] = val

		val, err = v.LeaseTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lease_time"] = val

		val, err = v.Options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options"] = val

		val, err = v.ServerIdOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_id_override"] = val

		val, err = v.Servers4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.Servers6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers6"] = val

		val, err = v.Type4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Type6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type6"] = val

		val, err = v.VendorEncapulated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vendor_encapulated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigValue) String() string {
	return "ConfigValue"
}

func (v ConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	fixedBindings := types.MapValueMust(
		FixedBindingsType{
			basetypes.ObjectType{
				AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
			},
		},
		v.FixedBindings.Elements(),
	)

	if v.FixedBindings.IsNull() {
		fixedBindings = types.MapNull(
			FixedBindingsType{
				basetypes.ObjectType{
					AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FixedBindings.IsUnknown() {
		fixedBindings = types.MapUnknown(
			FixedBindingsType{
				basetypes.ObjectType{
					AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	options := types.MapValueMust(
		OptionsType{
			basetypes.ObjectType{
				AttrTypes: OptionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Options.Elements(),
	)

	if v.Options.IsNull() {
		options = types.MapNull(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Options.IsUnknown() {
		options = types.MapUnknown(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vendorEncapulated := types.MapValueMust(
		VendorEncapulatedType{
			basetypes.ObjectType{
				AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
			},
		},
		v.VendorEncapulated.Elements(),
	)

	if v.VendorEncapulated.IsNull() {
		vendorEncapulated = types.MapNull(
			VendorEncapulatedType{
				basetypes.ObjectType{
					AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VendorEncapulated.IsUnknown() {
		vendorEncapulated = types.MapUnknown(
			VendorEncapulatedType{
				basetypes.ObjectType{
					AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	dnsServersVal, d := types.ListValue(types.StringType, v.DnsServers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":    basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":  basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":    basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":  basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	serversVal, d := types.ListValue(types.StringType, v.Servers4.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":    basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":  basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	servers6Val, d := types.ListValue(types.StringType, v.Servers6.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":    basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":  basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"fixed_bindings": basetypes.MapType{
			ElemType: FixedBindingsValue{}.Type(ctx),
		},
		"gateway":    basetypes.StringType{},
		"ip_end":    basetypes.StringType{},
		"ip_end6":    basetypes.StringType{},
		"ip_start":  basetypes.StringType{},
		"ip_start6":  basetypes.StringType{},
		"lease_time": basetypes.Int64Type{},
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"server_id_override": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"servers6": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
		"type6": basetypes.StringType{},
		"vendor_encapulated": basetypes.MapType{
			ElemType: VendorEncapulatedValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns_servers":        dnsServersVal,
			"dns_suffix":         dnsSuffixVal,
			"fixed_bindings":     fixedBindings,
			"gateway":            v.Gateway,
			"ip_end":            v.IpEnd4,
			"ip_end6":            v.IpEnd6,
			"ip_start":          v.IpStart4,
			"ip_start6":          v.IpStart6,
			"lease_time":         v.LeaseTime,
			"options":            options,
			"server_id_override": v.ServerIdOverride,
			"servers":           serversVal,
			"servers6":           servers6Val,
			"type":              v.Type4,
			"type6":              v.Type6,
			"vendor_encapulated": vendorEncapulated,
		})

	return objVal, diags
}

func (v ConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DnsServers.Equal(other.DnsServers) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.FixedBindings.Equal(other.FixedBindings) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.IpEnd4.Equal(other.IpEnd4) {
		return false
	}

	if !v.IpEnd6.Equal(other.IpEnd6) {
		return false
	}

	if !v.IpStart4.Equal(other.IpStart4) {
		return false
	}

	if !v.IpStart6.Equal(other.IpStart6) {
		return false
	}

	if !v.LeaseTime.Equal(other.LeaseTime) {
		return false
	}

	if !v.Options.Equal(other.Options) {
		return false
	}

	if !v.ServerIdOverride.Equal(other.ServerIdOverride) {
		return false
	}

	if !v.Servers4.Equal(other.Servers4) {
		return false
	}

	if !v.Servers6.Equal(other.Servers6) {
		return false
	}

	if !v.Type4.Equal(other.Type4) {
		return false
	}

	if !v.Type6.Equal(other.Type6) {
		return false
	}

	if !v.VendorEncapulated.Equal(other.VendorEncapulated) {
		return false
	}

	return true
}

func (v ConfigValue) Type(ctx context.Context) attr.Type {
	return ConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"fixed_bindings": basetypes.MapType{
			ElemType: FixedBindingsValue{}.Type(ctx),
		},
		"gateway":    basetypes.StringType{},
		"ip_end":    basetypes.StringType{},
		"ip_end6":    basetypes.StringType{},
		"ip_start":  basetypes.StringType{},
		"ip_start6":  basetypes.StringType{},
		"lease_time": basetypes.Int64Type{},
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"server_id_override": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"servers6": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
		"type6": basetypes.StringType{},
		"vendor_encapulated": basetypes.MapType{
			ElemType: VendorEncapulatedValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = FixedBindingsType{}

type FixedBindingsType struct {
	basetypes.ObjectType
}

func (t FixedBindingsType) Equal(o attr.Type) bool {
	other, ok := o.(FixedBindingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FixedBindingsType) String() string {
	return "FixedBindingsType"
}

func (t FixedBindingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FixedBindingsValue{
		Ip:    ipVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewFixedBindingsValueNull() FixedBindingsValue {
	return FixedBindingsValue{
		state: attr.ValueStateNull,
	}
}

func NewFixedBindingsValueUnknown() FixedBindingsValue {
	return FixedBindingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFixedBindingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FixedBindingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FixedBindingsValue Attribute Value",
				"While creating a FixedBindingsValue value, a missing attribute value was detected. "+
					"A FixedBindingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FixedBindingsValue Attribute Type",
				"While creating a FixedBindingsValue value, an invalid attribute value was detected. "+
					"A FixedBindingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FixedBindingsValue Attribute Value",
				"While creating a FixedBindingsValue value, an extra attribute value was detected. "+
					"A FixedBindingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FixedBindingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFixedBindingsValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewFixedBindingsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFixedBindingsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewFixedBindingsValueUnknown(), diags
	}

	return FixedBindingsValue{
		Ip:    ipVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewFixedBindingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FixedBindingsValue {
	object, diags := NewFixedBindingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFixedBindingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FixedBindingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFixedBindingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFixedBindingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFixedBindingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFixedBindingsValueMust(FixedBindingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FixedBindingsType) ValueType(ctx context.Context) attr.Value {
	return FixedBindingsValue{}
}

var _ basetypes.ObjectValuable = FixedBindingsValue{}

type FixedBindingsValue struct {
	Ip    basetypes.StringValue `tfsdk:"ip"`
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v FixedBindingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FixedBindingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FixedBindingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FixedBindingsValue) String() string {
	return "FixedBindingsValue"
}

func (v FixedBindingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":   v.Ip,
			"name": v.Name,
		})

	return objVal, diags
}

func (v FixedBindingsValue) Equal(o attr.Value) bool {
	other, ok := o.(FixedBindingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v FixedBindingsValue) Type(ctx context.Context) attr.Type {
	return FixedBindingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FixedBindingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		OptionsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		OptionsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	OptionsType basetypes.StringValue `tfsdk:"type"`
	Value       basetypes.StringValue `tfsdk:"value"`
	state       attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.OptionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":  v.OptionsType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OptionsType.Equal(other.OptionsType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VendorEncapulatedType{}

type VendorEncapulatedType struct {
	basetypes.ObjectType
}

func (t VendorEncapulatedType) Equal(o attr.Type) bool {
	other, ok := o.(VendorEncapulatedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VendorEncapulatedType) String() string {
	return "VendorEncapulatedType"
}

func (t VendorEncapulatedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VendorEncapulatedValue{
		VendorEncapulatedType: typeVal,
		Value:                 valueVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVendorEncapulatedValueNull() VendorEncapulatedValue {
	return VendorEncapulatedValue{
		state: attr.ValueStateNull,
	}
}

func NewVendorEncapulatedValueUnknown() VendorEncapulatedValue {
	return VendorEncapulatedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVendorEncapulatedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VendorEncapulatedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VendorEncapulatedValue Attribute Value",
				"While creating a VendorEncapulatedValue value, a missing attribute value was detected. "+
					"A VendorEncapulatedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VendorEncapulatedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VendorEncapulatedValue Attribute Type",
				"While creating a VendorEncapulatedValue value, an invalid attribute value was detected. "+
					"A VendorEncapulatedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VendorEncapulatedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VendorEncapulatedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VendorEncapulatedValue Attribute Value",
				"While creating a VendorEncapulatedValue value, an extra attribute value was detected. "+
					"A VendorEncapulatedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VendorEncapulatedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVendorEncapulatedValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewVendorEncapulatedValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewVendorEncapulatedValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewVendorEncapulatedValueUnknown(), diags
	}

	return VendorEncapulatedValue{
		VendorEncapulatedType: typeVal,
		Value:                 valueVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVendorEncapulatedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VendorEncapulatedValue {
	object, diags := NewVendorEncapulatedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVendorEncapulatedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VendorEncapulatedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVendorEncapulatedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVendorEncapulatedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVendorEncapulatedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVendorEncapulatedValueMust(VendorEncapulatedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VendorEncapulatedType) ValueType(ctx context.Context) attr.Value {
	return VendorEncapulatedValue{}
}

var _ basetypes.ObjectValuable = VendorEncapulatedValue{}

type VendorEncapulatedValue struct {
	VendorEncapulatedType basetypes.StringValue `tfsdk:"type"`
	Value                 basetypes.StringValue `tfsdk:"value"`
	state                 attr.ValueState
}

func (v VendorEncapulatedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.VendorEncapulatedType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VendorEncapulatedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VendorEncapulatedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VendorEncapulatedValue) String() string {
	return "VendorEncapulatedValue"
}

func (v VendorEncapulatedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":  v.VendorEncapulatedType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v VendorEncapulatedValue) Equal(o attr.Value) bool {
	other, ok := o.(VendorEncapulatedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VendorEncapulatedType.Equal(other.VendorEncapulatedType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v VendorEncapulatedValue) Type(ctx context.Context) attr.Type {
	return VendorEncapulatedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VendorEncapulatedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutesType{}

type ExtraRoutesType struct {
	basetypes.ObjectType
}

func (t ExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutesType) String() string {
	return "ExtraRoutesType"
}

func (t ExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueNull() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutesValueUnknown() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, a missing attribute value was detected. "+
					"A ExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutesValue Attribute Type",
				"While creating a ExtraRoutesValue value, an invalid attribute value was detected. "+
					"A ExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, an extra attribute value was detected. "+
					"A ExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	return ExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutesValue {
	object, diags := NewExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutesValueMust(ExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = ExtraRoutesValue{}

type ExtraRoutesValue struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v ExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutesValue) String() string {
	return "ExtraRoutesValue"
}

func (v ExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return ExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IpConfigType{}

type IpConfigType struct {
	basetypes.ObjectType
}

func (t IpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(IpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpConfigType) String() string {
	return "IpConfigType"
}

func (t IpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	secondaryIpsAttribute, ok := attributes["secondary_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_ips is missing from object`)

		return nil, diags
	}

	secondaryIpsVal, ok := secondaryIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_ips expected to be basetypes.ListValue, was: %T`, secondaryIpsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpConfigValue{
		Ip:           ipVal,
		Netmask:      netmaskVal,
		SecondaryIps: secondaryIpsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueNull() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewIpConfigValueUnknown() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, a missing attribute value was detected. "+
					"A IpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpConfigValue Attribute Type",
				"While creating a IpConfigValue value, an invalid attribute value was detected. "+
					"A IpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, an extra attribute value was detected. "+
					"A IpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	secondaryIpsAttribute, ok := attributes["secondary_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_ips is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	secondaryIpsVal, ok := secondaryIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_ips expected to be basetypes.ListValue, was: %T`, secondaryIpsAttribute))
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	return IpConfigValue{
		Ip:           ipVal,
		Netmask:      netmaskVal,
		SecondaryIps: secondaryIpsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpConfigValue {
	object, diags := NewIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpConfigValueMust(IpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpConfigType) ValueType(ctx context.Context) attr.Value {
	return IpConfigValue{}
}

var _ basetypes.ObjectValuable = IpConfigValue{}

type IpConfigValue struct {
	Ip           basetypes.StringValue `tfsdk:"ip"`
	Netmask      basetypes.StringValue `tfsdk:"netmask"`
	SecondaryIps basetypes.ListValue   `tfsdk:"secondary_ips"`
	state        attr.ValueState
}

func (v IpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secondary_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.SecondaryIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_ips"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpConfigValue) String() string {
	return "IpConfigValue"
}

func (v IpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	secondaryIpsVal, d := types.ListValue(types.StringType, v.SecondaryIps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ip":      basetypes.StringType{},
			"netmask": basetypes.StringType{},
			"secondary_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"secondary_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":            v.Ip,
			"netmask":       v.Netmask,
			"secondary_ips": secondaryIpsVal,
		})

	return objVal, diags
}

func (v IpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(IpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.SecondaryIps.Equal(other.SecondaryIps) {
		return false
	}

	return true
}

func (v IpConfigValue) Type(ctx context.Context) attr.Type {
	return IpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"secondary_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		VlanId: vlanIdVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		VlanId: vlanIdVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	VlanId basetypes.Int64Value `tfsdk:"vlan_id"`
	state  attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"vlan_id": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"vlan_id": v.VlanId,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"vlan_id": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = OobIpConfigType{}

type OobIpConfigType struct {
	basetypes.ObjectType
}

func (t OobIpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(OobIpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OobIpConfigType) String() string {
	return "OobIpConfigType"
}

func (t OobIpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	node1Attribute, ok := attributes["node1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node1 is missing from object`)

		return nil, diags
	}

	node1Val, ok := node1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node1 expected to be basetypes.ObjectValue, was: %T`, node1Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return nil, diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return nil, diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OobIpConfigValue{
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Network:              networkVal,
		Node1:                node1Val,
		OobIpConfigType:      typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueNull() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewOobIpConfigValueUnknown() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOobIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OobIpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, a missing attribute value was detected. "+
					"A OobIpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OobIpConfigValue Attribute Type",
				"While creating a OobIpConfigValue value, an invalid attribute value was detected. "+
					"A OobIpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, an extra attribute value was detected. "+
					"A OobIpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OobIpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	node1Attribute, ok := attributes["node1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node1 is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	node1Val, ok := node1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node1 expected to be basetypes.ObjectValue, was: %T`, node1Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	return OobIpConfigValue{
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Network:              networkVal,
		Node1:                node1Val,
		OobIpConfigType:      typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OobIpConfigValue {
	object, diags := NewOobIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOobIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OobIpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOobIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOobIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOobIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOobIpConfigValueMust(OobIpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OobIpConfigType) ValueType(ctx context.Context) attr.Value {
	return OobIpConfigValue{}
}

var _ basetypes.ObjectValuable = OobIpConfigValue{}

type OobIpConfigValue struct {
	Ip                   basetypes.StringValue `tfsdk:"ip"`
	Netmask              basetypes.StringValue `tfsdk:"netmask"`
	Network              basetypes.StringValue `tfsdk:"network"`
	Node1                basetypes.ObjectValue `tfsdk:"node1"`
	OobIpConfigType      basetypes.StringValue `tfsdk:"type"`
	UseMgmtVrf           basetypes.BoolValue   `tfsdk:"use_mgmt_vrf"`
	UseMgmtVrfForHostOut basetypes.BoolValue   `tfsdk:"use_mgmt_vrf_for_host_out"`
	state                attr.ValueState
}

func (v OobIpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node1"] = basetypes.ObjectType{
		AttrTypes: Node1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf_for_host_out"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.Node1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node1"] = val

		val, err = v.OobIpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UseMgmtVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf"] = val

		val, err = v.UseMgmtVrfForHostOut.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf_for_host_out"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OobIpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OobIpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OobIpConfigValue) String() string {
	return "OobIpConfigValue"
}

func (v OobIpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var node1 basetypes.ObjectValue

	if v.Node1.IsNull() {
		node1 = types.ObjectNull(
			Node1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Node1.IsUnknown() {
		node1 = types.ObjectUnknown(
			Node1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Node1.IsNull() && !v.Node1.IsUnknown() {
		node1 = types.ObjectValueMust(
			Node1Value{}.AttributeTypes(ctx),
			v.Node1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"network": basetypes.StringType{},
		"node1": basetypes.ObjectType{
			AttrTypes: Node1Value{}.AttributeTypes(ctx),
		},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":                        v.Ip,
			"netmask":                   v.Netmask,
			"network":                   v.Network,
			"node1":                     node1,
			"type":                      v.OobIpConfigType,
			"use_mgmt_vrf":              v.UseMgmtVrf,
			"use_mgmt_vrf_for_host_out": v.UseMgmtVrfForHostOut,
		})

	return objVal, diags
}

func (v OobIpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(OobIpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.Node1.Equal(other.Node1) {
		return false
	}

	if !v.OobIpConfigType.Equal(other.OobIpConfigType) {
		return false
	}

	if !v.UseMgmtVrf.Equal(other.UseMgmtVrf) {
		return false
	}

	if !v.UseMgmtVrfForHostOut.Equal(other.UseMgmtVrfForHostOut) {
		return false
	}

	return true
}

func (v OobIpConfigValue) Type(ctx context.Context) attr.Type {
	return OobIpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OobIpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"network": basetypes.StringType{},
		"node1": basetypes.ObjectType{
			AttrTypes: Node1Value{}.AttributeTypes(ctx),
		},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Node1Type{}

type Node1Type struct {
	basetypes.ObjectType
}

func (t Node1Type) Equal(o attr.Type) bool {
	other, ok := o.(Node1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Node1Type) String() string {
	return "Node1Type"
}

func (t Node1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return nil, diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return nil, diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Node1Value{
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Network:              networkVal,
		Node1Type:            typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNode1ValueNull() Node1Value {
	return Node1Value{
		state: attr.ValueStateNull,
	}
}

func NewNode1ValueUnknown() Node1Value {
	return Node1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewNode1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Node1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Node1Value Attribute Value",
				"While creating a Node1Value value, a missing attribute value was detected. "+
					"A Node1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Node1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Node1Value Attribute Type",
				"While creating a Node1Value value, an invalid attribute value was detected. "+
					"A Node1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Node1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Node1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Node1Value Attribute Value",
				"While creating a Node1Value value, an extra attribute value was detected. "+
					"A Node1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Node1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNode1ValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return NewNode1ValueUnknown(), diags
	}

	return Node1Value{
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Network:              networkVal,
		Node1Type:            typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNode1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Node1Value {
	object, diags := NewNode1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNode1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Node1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNode1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNode1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNode1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNode1ValueMust(Node1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Node1Type) ValueType(ctx context.Context) attr.Value {
	return Node1Value{}
}

var _ basetypes.ObjectValuable = Node1Value{}

type Node1Value struct {
	Ip                   basetypes.StringValue `tfsdk:"ip"`
	Netmask              basetypes.StringValue `tfsdk:"netmask"`
	Network              basetypes.StringValue `tfsdk:"network"`
	Node1Type            basetypes.StringValue `tfsdk:"type"`
	UseMgmtVrf           basetypes.BoolValue   `tfsdk:"use_mgmt_vrf"`
	UseMgmtVrfForHostOut basetypes.BoolValue   `tfsdk:"use_mgmt_vrf_for_host_out"`
	state                attr.ValueState
}

func (v Node1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf_for_host_out"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.Node1Type.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UseMgmtVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf"] = val

		val, err = v.UseMgmtVrfForHostOut.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf_for_host_out"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Node1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Node1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Node1Value) String() string {
	return "Node1Value"
}

func (v Node1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip":                        basetypes.StringType{},
		"netmask":                   basetypes.StringType{},
		"network":                   basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":                        v.Ip,
			"netmask":                   v.Netmask,
			"network":                   v.Network,
			"type":                      v.Node1Type,
			"use_mgmt_vrf":              v.UseMgmtVrf,
			"use_mgmt_vrf_for_host_out": v.UseMgmtVrfForHostOut,
		})

	return objVal, diags
}

func (v Node1Value) Equal(o attr.Value) bool {
	other, ok := o.(Node1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.Node1Type.Equal(other.Node1Type) {
		return false
	}

	if !v.UseMgmtVrf.Equal(other.UseMgmtVrf) {
		return false
	}

	if !v.UseMgmtVrfForHostOut.Equal(other.UseMgmtVrfForHostOut) {
		return false
	}

	return true
}

func (v Node1Value) Type(ctx context.Context) attr.Type {
	return Node1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Node1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":                        basetypes.StringType{},
		"netmask":                   basetypes.StringType{},
		"network":                   basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PortConfigType{}

type PortConfigType struct {
	basetypes.ObjectType
}

func (t PortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortConfigType) String() string {
	return "PortConfigType"
}

func (t PortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	dslTypeAttribute, ok := attributes["dsl_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_type is missing from object`)

		return nil, diags
	}

	dslTypeVal, ok := dslTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_type expected to be basetypes.StringValue, was: %T`, dslTypeAttribute))
	}

	dslVciAttribute, ok := attributes["dsl_vci"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vci is missing from object`)

		return nil, diags
	}

	dslVciVal, ok := dslVciAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vci expected to be basetypes.Int64Value, was: %T`, dslVciAttribute))
	}

	dslVpiAttribute, ok := attributes["dsl_vpi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vpi is missing from object`)

		return nil, diags
	}

	dslVpiVal, ok := dslVpiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vpi expected to be basetypes.Int64Value, was: %T`, dslVpiAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	ipConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return nil, diags
	}

	ipConfigVal, ok := ipConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, ipConfigAttribute))
	}

	lteApnAttribute, ok := attributes["lte_apn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_apn is missing from object`)

		return nil, diags
	}

	lteApnVal, ok := lteApnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_apn expected to be basetypes.StringValue, was: %T`, lteApnAttribute))
	}

	lteAuthAttribute, ok := attributes["lte_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_auth is missing from object`)

		return nil, diags
	}

	lteAuthVal, ok := lteAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_auth expected to be basetypes.StringValue, was: %T`, lteAuthAttribute))
	}

	lteBackupAttribute, ok := attributes["lte_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_backup is missing from object`)

		return nil, diags
	}

	lteBackupVal, ok := lteBackupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_backup expected to be basetypes.BoolValue, was: %T`, lteBackupAttribute))
	}

	ltePasswordAttribute, ok := attributes["lte_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_password is missing from object`)

		return nil, diags
	}

	ltePasswordVal, ok := ltePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_password expected to be basetypes.StringValue, was: %T`, ltePasswordAttribute))
	}

	lteUsernameAttribute, ok := attributes["lte_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_username is missing from object`)

		return nil, diags
	}

	lteUsernameVal, ok := lteUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_username expected to be basetypes.StringValue, was: %T`, lteUsernameAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	outerVlanIdAttribute, ok := attributes["outer_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlan_id is missing from object`)

		return nil, diags
	}

	outerVlanIdVal, ok := outerVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlan_id expected to be basetypes.Int64Value, was: %T`, outerVlanIdAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return nil, diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	preserveDscpAttribute, ok := attributes["preserve_dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preserve_dscp is missing from object`)

		return nil, diags
	}

	preserveDscpVal, ok := preserveDscpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preserve_dscp expected to be basetypes.BoolValue, was: %T`, preserveDscpAttribute))
	}

	redundantAttribute, ok := attributes["redundant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundant is missing from object`)

		return nil, diags
	}

	redundantVal, ok := redundantAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundant expected to be basetypes.BoolValue, was: %T`, redundantAttribute))
	}

	rethIdxAttribute, ok := attributes["reth_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_idx is missing from object`)

		return nil, diags
	}

	rethIdxVal, ok := rethIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_idx expected to be basetypes.Int64Value, was: %T`, rethIdxAttribute))
	}

	rethNodeAttribute, ok := attributes["reth_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_node is missing from object`)

		return nil, diags
	}

	rethNodeVal, ok := rethNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_node expected to be basetypes.StringValue, was: %T`, rethNodeAttribute))
	}

	rethNodesAttribute, ok := attributes["reth_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_nodes is missing from object`)

		return nil, diags
	}

	rethNodesVal, ok := rethNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_nodes expected to be basetypes.ListValue, was: %T`, rethNodesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	ssrNoVirtualMacAttribute, ok := attributes["ssr_no_virtual_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssr_no_virtual_mac is missing from object`)

		return nil, diags
	}

	ssrNoVirtualMacVal, ok := ssrNoVirtualMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssr_no_virtual_mac expected to be basetypes.BoolValue, was: %T`, ssrNoVirtualMacAttribute))
	}

	svrPortRangeAttribute, ok := attributes["svr_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`svr_port_range is missing from object`)

		return nil, diags
	}

	svrPortRangeVal, ok := svrPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`svr_port_range expected to be basetypes.StringValue, was: %T`, svrPortRangeAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return nil, diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vpnPathsAttribute, ok := attributes["vpn_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_paths is missing from object`)

		return nil, diags
	}

	vpnPathsVal, ok := vpnPathsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_paths expected to be basetypes.MapValue, was: %T`, vpnPathsAttribute))
	}

	wanArpPolicerAttribute, ok := attributes["wan_arp_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_arp_policer is missing from object`)

		return nil, diags
	}

	wanArpPolicerVal, ok := wanArpPolicerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_arp_policer expected to be basetypes.StringValue, was: %T`, wanArpPolicerAttribute))
	}

	wanExtIpAttribute, ok := attributes["wan_ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ext_ip is missing from object`)

		return nil, diags
	}

	wanExtIpVal, ok := wanExtIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ext_ip expected to be basetypes.StringValue, was: %T`, wanExtIpAttribute))
	}

	wanSourceNatAttribute, ok := attributes["wan_source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_source_nat is missing from object`)

		return nil, diags
	}

	wanSourceNatVal, ok := wanSourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_source_nat expected to be basetypes.ObjectValue, was: %T`, wanSourceNatAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return nil, diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortConfigValue{
		Description:     descriptionVal,
		DisableAutoneg:  disableAutonegVal,
		Disabled:        disabledVal,
		DslType:         dslTypeVal,
		DslVci:          dslVciVal,
		DslVpi:          dslVpiVal,
		Duplex:          duplexVal,
		IpConfig:        ipConfigVal,
		LteApn:          lteApnVal,
		LteAuth:         lteAuthVal,
		LteBackup:       lteBackupVal,
		LtePassword:     ltePasswordVal,
		LteUsername:     lteUsernameVal,
		Mtu:             mtuVal,
		Name:            nameVal,
		Networks:        networksVal,
		OuterVlanId:     outerVlanIdVal,
		PoeDisabled:     poeDisabledVal,
		PortNetwork:     portNetworkVal,
		PreserveDscp:    preserveDscpVal,
		Redundant:       redundantVal,
		RethIdx:         rethIdxVal,
		RethNode:        rethNodeVal,
		RethNodes:       rethNodesVal,
		Speed:           speedVal,
		SsrNoVirtualMac: ssrNoVirtualMacVal,
		SvrPortRange:    svrPortRangeVal,
		TrafficShaping:  trafficShapingVal,
		Usage:           usageVal,
		VlanId:          vlanIdVal,
		VpnPaths:        vpnPathsVal,
		WanArpPolicer:   wanArpPolicerVal,
		WanExtIp:        wanExtIpVal,
		WanSourceNat:    wanSourceNatVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueNull() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortConfigValueUnknown() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, a missing attribute value was detected. "+
					"A PortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortConfigValue Attribute Type",
				"While creating a PortConfigValue value, an invalid attribute value was detected. "+
					"A PortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, an extra attribute value was detected. "+
					"A PortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	dslTypeAttribute, ok := attributes["dsl_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_type is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dslTypeVal, ok := dslTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_type expected to be basetypes.StringValue, was: %T`, dslTypeAttribute))
	}

	dslVciAttribute, ok := attributes["dsl_vci"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vci is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dslVciVal, ok := dslVciAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vci expected to be basetypes.Int64Value, was: %T`, dslVciAttribute))
	}

	dslVpiAttribute, ok := attributes["dsl_vpi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vpi is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dslVpiVal, ok := dslVpiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vpi expected to be basetypes.Int64Value, was: %T`, dslVpiAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	ipConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	ipConfigVal, ok := ipConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, ipConfigAttribute))
	}

	lteApnAttribute, ok := attributes["lte_apn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_apn is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteApnVal, ok := lteApnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_apn expected to be basetypes.StringValue, was: %T`, lteApnAttribute))
	}

	lteAuthAttribute, ok := attributes["lte_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_auth is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteAuthVal, ok := lteAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_auth expected to be basetypes.StringValue, was: %T`, lteAuthAttribute))
	}

	lteBackupAttribute, ok := attributes["lte_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_backup is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteBackupVal, ok := lteBackupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_backup expected to be basetypes.BoolValue, was: %T`, lteBackupAttribute))
	}

	ltePasswordAttribute, ok := attributes["lte_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_password is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	ltePasswordVal, ok := ltePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_password expected to be basetypes.StringValue, was: %T`, ltePasswordAttribute))
	}

	lteUsernameAttribute, ok := attributes["lte_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_username is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteUsernameVal, ok := lteUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_username expected to be basetypes.StringValue, was: %T`, lteUsernameAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	outerVlanIdAttribute, ok := attributes["outer_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlan_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	outerVlanIdVal, ok := outerVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlan_id expected to be basetypes.Int64Value, was: %T`, outerVlanIdAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	preserveDscpAttribute, ok := attributes["preserve_dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preserve_dscp is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	preserveDscpVal, ok := preserveDscpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preserve_dscp expected to be basetypes.BoolValue, was: %T`, preserveDscpAttribute))
	}

	redundantAttribute, ok := attributes["redundant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundant is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	redundantVal, ok := redundantAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundant expected to be basetypes.BoolValue, was: %T`, redundantAttribute))
	}

	rethIdxAttribute, ok := attributes["reth_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_idx is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	rethIdxVal, ok := rethIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_idx expected to be basetypes.Int64Value, was: %T`, rethIdxAttribute))
	}

	rethNodeAttribute, ok := attributes["reth_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_node is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	rethNodeVal, ok := rethNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_node expected to be basetypes.StringValue, was: %T`, rethNodeAttribute))
	}

	rethNodesAttribute, ok := attributes["reth_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_nodes is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	rethNodesVal, ok := rethNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_nodes expected to be basetypes.ListValue, was: %T`, rethNodesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	ssrNoVirtualMacAttribute, ok := attributes["ssr_no_virtual_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssr_no_virtual_mac is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	ssrNoVirtualMacVal, ok := ssrNoVirtualMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssr_no_virtual_mac expected to be basetypes.BoolValue, was: %T`, ssrNoVirtualMacAttribute))
	}

	svrPortRangeAttribute, ok := attributes["svr_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`svr_port_range is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	svrPortRangeVal, ok := svrPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`svr_port_range expected to be basetypes.StringValue, was: %T`, svrPortRangeAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vpnPathsAttribute, ok := attributes["vpn_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_paths is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	vpnPathsVal, ok := vpnPathsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_paths expected to be basetypes.MapValue, was: %T`, vpnPathsAttribute))
	}

	wanArpPolicerAttribute, ok := attributes["wan_arp_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_arp_policer is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanArpPolicerVal, ok := wanArpPolicerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_arp_policer expected to be basetypes.StringValue, was: %T`, wanArpPolicerAttribute))
	}

	wanExtIpAttribute, ok := attributes["wan_ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ext_ip is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanExtIpVal, ok := wanExtIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ext_ip expected to be basetypes.StringValue, was: %T`, wanExtIpAttribute))
	}

	wanSourceNatAttribute, ok := attributes["wan_source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_source_nat is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanSourceNatVal, ok := wanSourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_source_nat expected to be basetypes.ObjectValue, was: %T`, wanSourceNatAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	return PortConfigValue{
		Description:     descriptionVal,
		DisableAutoneg:  disableAutonegVal,
		Disabled:        disabledVal,
		DslType:         dslTypeVal,
		DslVci:          dslVciVal,
		DslVpi:          dslVpiVal,
		Duplex:          duplexVal,
		IpConfig:        ipConfigVal,
		LteApn:          lteApnVal,
		LteAuth:         lteAuthVal,
		LteBackup:       lteBackupVal,
		LtePassword:     ltePasswordVal,
		LteUsername:     lteUsernameVal,
		Mtu:             mtuVal,
		Name:            nameVal,
		Networks:        networksVal,
		OuterVlanId:     outerVlanIdVal,
		PoeDisabled:     poeDisabledVal,
		PortNetwork:     portNetworkVal,
		PreserveDscp:    preserveDscpVal,
		Redundant:       redundantVal,
		RethIdx:         rethIdxVal,
		RethNode:        rethNodeVal,
		RethNodes:       rethNodesVal,
		Speed:           speedVal,
		SsrNoVirtualMac: ssrNoVirtualMacVal,
		SvrPortRange:    svrPortRangeVal,
		TrafficShaping:  trafficShapingVal,
		Usage:           usageVal,
		VlanId:          vlanIdVal,
		VpnPaths:        vpnPathsVal,
		WanArpPolicer:   wanArpPolicerVal,
		WanExtIp:        wanExtIpVal,
		WanSourceNat:    wanSourceNatVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortConfigValue {
	object, diags := NewPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortConfigValueMust(PortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortConfigType) ValueType(ctx context.Context) attr.Value {
	return PortConfigValue{}
}

var _ basetypes.ObjectValuable = PortConfigValue{}

type PortConfigValue struct {
	Description     basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg  basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	DslType         basetypes.StringValue `tfsdk:"dsl_type"`
	DslVci          basetypes.Int64Value  `tfsdk:"dsl_vci"`
	DslVpi          basetypes.Int64Value  `tfsdk:"dsl_vpi"`
	Duplex          basetypes.StringValue `tfsdk:"duplex"`
	IpConfig        basetypes.ObjectValue `tfsdk:"ip_config"`
	LteApn          basetypes.StringValue `tfsdk:"lte_apn"`
	LteAuth         basetypes.StringValue `tfsdk:"lte_auth"`
	LteBackup       basetypes.BoolValue   `tfsdk:"lte_backup"`
	LtePassword     basetypes.StringValue `tfsdk:"lte_password"`
	LteUsername     basetypes.StringValue `tfsdk:"lte_username"`
	Mtu             basetypes.Int64Value  `tfsdk:"mtu"`
	Name            basetypes.StringValue `tfsdk:"name"`
	Networks        basetypes.ListValue   `tfsdk:"networks"`
	OuterVlanId     basetypes.Int64Value  `tfsdk:"outer_vlan_id"`
	PoeDisabled     basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PortNetwork     basetypes.StringValue `tfsdk:"port_network"`
	PreserveDscp    basetypes.BoolValue   `tfsdk:"preserve_dscp"`
	Redundant       basetypes.BoolValue   `tfsdk:"redundant"`
	RethIdx         basetypes.Int64Value  `tfsdk:"reth_idx"`
	RethNode        basetypes.StringValue `tfsdk:"reth_node"`
	RethNodes       basetypes.ListValue   `tfsdk:"reth_nodes"`
	Speed           basetypes.StringValue `tfsdk:"speed"`
	SsrNoVirtualMac basetypes.BoolValue   `tfsdk:"ssr_no_virtual_mac"`
	SvrPortRange    basetypes.StringValue `tfsdk:"svr_port_range"`
	TrafficShaping  basetypes.ObjectValue `tfsdk:"traffic_shaping"`
	Usage           basetypes.StringValue `tfsdk:"usage"`
	VlanId          basetypes.Int64Value  `tfsdk:"vlan_id"`
	VpnPaths        basetypes.MapValue    `tfsdk:"vpn_paths"`
	WanArpPolicer   basetypes.StringValue `tfsdk:"wan_arp_policer"`
	WanExtIp        basetypes.StringValue `tfsdk:"wan_ext_ip"`
	WanSourceNat    basetypes.ObjectValue `tfsdk:"wan_source_nat"`
	WanType         basetypes.StringValue `tfsdk:"wan_type"`
	state           attr.ValueState
}

func (v PortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 35)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dsl_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dsl_vci"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dsl_vpi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_config"] = basetypes.ObjectType{
		AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["lte_apn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_backup"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["lte_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["outer_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preserve_dscp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["redundant"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["reth_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["reth_node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reth_nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ssr_no_virtual_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["svr_port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["traffic_shaping"] = basetypes.ObjectType{
		AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vpn_paths"] = basetypes.MapType{
		ElemType: VpnPathsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_arp_policer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_ext_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_source_nat"] = basetypes.ObjectType{
		AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 35)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.DslType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dsl_type"] = val

		val, err = v.DslVci.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dsl_vci"] = val

		val, err = v.DslVpi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dsl_vpi"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.IpConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_config"] = val

		val, err = v.LteApn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_apn"] = val

		val, err = v.LteAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_auth"] = val

		val, err = v.LteBackup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_backup"] = val

		val, err = v.LtePassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_password"] = val

		val, err = v.LteUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_username"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.OuterVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["outer_vlan_id"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PortNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_network"] = val

		val, err = v.PreserveDscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preserve_dscp"] = val

		val, err = v.Redundant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redundant"] = val

		val, err = v.RethIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reth_idx"] = val

		val, err = v.RethNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reth_node"] = val

		val, err = v.RethNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reth_nodes"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.SsrNoVirtualMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssr_no_virtual_mac"] = val

		val, err = v.SvrPortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["svr_port_range"] = val

		val, err = v.TrafficShaping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["traffic_shaping"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VpnPaths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_paths"] = val

		val, err = v.WanArpPolicer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_arp_policer"] = val

		val, err = v.WanExtIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_ext_ip"] = val

		val, err = v.WanSourceNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_source_nat"] = val

		val, err = v.WanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortConfigValue) String() string {
	return "PortConfigValue"
}

func (v PortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipConfig basetypes.ObjectValue

	if v.IpConfig.IsNull() {
		ipConfig = types.ObjectNull(
			IpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpConfig.IsUnknown() {
		ipConfig = types.ObjectUnknown(
			IpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpConfig.IsNull() && !v.IpConfig.IsUnknown() {
		ipConfig = types.ObjectValueMust(
			IpConfigValue{}.AttributeTypes(ctx),
			v.IpConfig.Attributes(),
		)
	}

	var trafficShaping basetypes.ObjectValue

	if v.TrafficShaping.IsNull() {
		trafficShaping = types.ObjectNull(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectUnknown(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.TrafficShaping.IsNull() && !v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectValueMust(
			TrafficShapingValue{}.AttributeTypes(ctx),
			v.TrafficShaping.Attributes(),
		)
	}

	vpnPaths := types.MapValueMust(
		VpnPathsType{
			basetypes.ObjectType{
				AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
			},
		},
		v.VpnPaths.Elements(),
	)

	if v.VpnPaths.IsNull() {
		vpnPaths = types.MapNull(
			VpnPathsType{
				basetypes.ObjectType{
					AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VpnPaths.IsUnknown() {
		vpnPaths = types.MapUnknown(
			VpnPathsType{
				basetypes.ObjectType{
					AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var wanSourceNat basetypes.ObjectValue

	if v.WanSourceNat.IsNull() {
		wanSourceNat = types.ObjectNull(
			WanSourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if v.WanSourceNat.IsUnknown() {
		wanSourceNat = types.ObjectUnknown(
			WanSourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.WanSourceNat.IsNull() && !v.WanSourceNat.IsUnknown() {
		wanSourceNat = types.ObjectValueMust(
			WanSourceNatValue{}.AttributeTypes(ctx),
			v.WanSourceNat.Attributes(),
		)
	}

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"description":     basetypes.StringType{},
			"disable_autoneg": basetypes.BoolType{},
			"disabled":        basetypes.BoolType{},
			"dsl_type":        basetypes.StringType{},
			"dsl_vci":         basetypes.Int64Type{},
			"dsl_vpi":         basetypes.Int64Type{},
			"duplex":          basetypes.StringType{},
			"ip_config": basetypes.ObjectType{
				AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
			},
			"lte_apn":      basetypes.StringType{},
			"lte_auth":     basetypes.StringType{},
			"lte_backup":   basetypes.BoolType{},
			"lte_password": basetypes.StringType{},
			"lte_username": basetypes.StringType{},
			"mtu":          basetypes.Int64Type{},
			"name":         basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"outer_vlan_id": basetypes.Int64Type{},
			"poe_disabled":  basetypes.BoolType{},
			"port_network":  basetypes.StringType{},
			"preserve_dscp": basetypes.BoolType{},
			"redundant":     basetypes.BoolType{},
			"reth_idx":      basetypes.Int64Type{},
			"reth_node":     basetypes.StringType{},
			"reth_nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":              basetypes.StringType{},
			"ssr_no_virtual_mac": basetypes.BoolType{},
			"svr_port_range":     basetypes.StringType{},
			"traffic_shaping": basetypes.ObjectType{
				AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
			},
			"usage":   basetypes.StringType{},
			"vlan_id": basetypes.Int64Type{},
			"vpn_paths": basetypes.MapType{
				ElemType: VpnPathsValue{}.Type(ctx),
			},
			"wan_arp_policer": basetypes.StringType{},
			"wan_ext_ip":      basetypes.StringType{},
			"wan_source_nat": basetypes.ObjectType{
				AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
			},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	rethNodesVal, d := types.ListValue(types.StringType, v.RethNodes.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"description":     basetypes.StringType{},
			"disable_autoneg": basetypes.BoolType{},
			"disabled":        basetypes.BoolType{},
			"dsl_type":        basetypes.StringType{},
			"dsl_vci":         basetypes.Int64Type{},
			"dsl_vpi":         basetypes.Int64Type{},
			"duplex":          basetypes.StringType{},
			"ip_config": basetypes.ObjectType{
				AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
			},
			"lte_apn":      basetypes.StringType{},
			"lte_auth":     basetypes.StringType{},
			"lte_backup":   basetypes.BoolType{},
			"lte_password": basetypes.StringType{},
			"lte_username": basetypes.StringType{},
			"mtu":          basetypes.Int64Type{},
			"name":         basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"outer_vlan_id": basetypes.Int64Type{},
			"poe_disabled":  basetypes.BoolType{},
			"port_network":  basetypes.StringType{},
			"preserve_dscp": basetypes.BoolType{},
			"redundant":     basetypes.BoolType{},
			"reth_idx":      basetypes.Int64Type{},
			"reth_node":     basetypes.StringType{},
			"reth_nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":              basetypes.StringType{},
			"ssr_no_virtual_mac": basetypes.BoolType{},
			"svr_port_range":     basetypes.StringType{},
			"traffic_shaping": basetypes.ObjectType{
				AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
			},
			"usage":   basetypes.StringType{},
			"vlan_id": basetypes.Int64Type{},
			"vpn_paths": basetypes.MapType{
				ElemType: VpnPathsValue{}.Type(ctx),
			},
			"wan_arp_policer": basetypes.StringType{},
			"wan_ext_ip":      basetypes.StringType{},
			"wan_source_nat": basetypes.ObjectType{
				AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
			},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"description":     basetypes.StringType{},
		"disable_autoneg": basetypes.BoolType{},
		"disabled":        basetypes.BoolType{},
		"dsl_type":        basetypes.StringType{},
		"dsl_vci":         basetypes.Int64Type{},
		"dsl_vpi":         basetypes.Int64Type{},
		"duplex":          basetypes.StringType{},
		"ip_config": basetypes.ObjectType{
			AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
		},
		"lte_apn":      basetypes.StringType{},
		"lte_auth":     basetypes.StringType{},
		"lte_backup":   basetypes.BoolType{},
		"lte_password": basetypes.StringType{},
		"lte_username": basetypes.StringType{},
		"mtu":          basetypes.Int64Type{},
		"name":         basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"outer_vlan_id": basetypes.Int64Type{},
		"poe_disabled":  basetypes.BoolType{},
		"port_network":  basetypes.StringType{},
		"preserve_dscp": basetypes.BoolType{},
		"redundant":     basetypes.BoolType{},
		"reth_idx":      basetypes.Int64Type{},
		"reth_node":     basetypes.StringType{},
		"reth_nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"speed":              basetypes.StringType{},
		"ssr_no_virtual_mac": basetypes.BoolType{},
		"svr_port_range":     basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
		"usage":   basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
		"vpn_paths": basetypes.MapType{
			ElemType: VpnPathsValue{}.Type(ctx),
		},
		"wan_arp_policer": basetypes.StringType{},
		"wan_ext_ip":      basetypes.StringType{},
		"wan_source_nat": basetypes.ObjectType{
			AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
		},
		"wan_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description":        v.Description,
			"disable_autoneg":    v.DisableAutoneg,
			"disabled":           v.Disabled,
			"dsl_type":           v.DslType,
			"dsl_vci":            v.DslVci,
			"dsl_vpi":            v.DslVpi,
			"duplex":             v.Duplex,
			"ip_config":          ipConfig,
			"lte_apn":            v.LteApn,
			"lte_auth":           v.LteAuth,
			"lte_backup":         v.LteBackup,
			"lte_password":       v.LtePassword,
			"lte_username":       v.LteUsername,
			"mtu":                v.Mtu,
			"name":               v.Name,
			"networks":           networksVal,
			"outer_vlan_id":      v.OuterVlanId,
			"poe_disabled":       v.PoeDisabled,
			"port_network":       v.PortNetwork,
			"preserve_dscp":      v.PreserveDscp,
			"redundant":          v.Redundant,
			"reth_idx":           v.RethIdx,
			"reth_node":          v.RethNode,
			"reth_nodes":         rethNodesVal,
			"speed":              v.Speed,
			"ssr_no_virtual_mac": v.SsrNoVirtualMac,
			"svr_port_range":     v.SvrPortRange,
			"traffic_shaping":    trafficShaping,
			"usage":              v.Usage,
			"vlan_id":            v.VlanId,
			"vpn_paths":          vpnPaths,
			"wan_arp_policer":    v.WanArpPolicer,
			"wan_ext_ip":         v.WanExtIp,
			"wan_source_nat":     wanSourceNat,
			"wan_type":           v.WanType,
		})

	return objVal, diags
}

func (v PortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.DslType.Equal(other.DslType) {
		return false
	}

	if !v.DslVci.Equal(other.DslVci) {
		return false
	}

	if !v.DslVpi.Equal(other.DslVpi) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.IpConfig.Equal(other.IpConfig) {
		return false
	}

	if !v.LteApn.Equal(other.LteApn) {
		return false
	}

	if !v.LteAuth.Equal(other.LteAuth) {
		return false
	}

	if !v.LteBackup.Equal(other.LteBackup) {
		return false
	}

	if !v.LtePassword.Equal(other.LtePassword) {
		return false
	}

	if !v.LteUsername.Equal(other.LteUsername) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.OuterVlanId.Equal(other.OuterVlanId) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PortNetwork.Equal(other.PortNetwork) {
		return false
	}

	if !v.PreserveDscp.Equal(other.PreserveDscp) {
		return false
	}

	if !v.Redundant.Equal(other.Redundant) {
		return false
	}

	if !v.RethIdx.Equal(other.RethIdx) {
		return false
	}

	if !v.RethNode.Equal(other.RethNode) {
		return false
	}

	if !v.RethNodes.Equal(other.RethNodes) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.SsrNoVirtualMac.Equal(other.SsrNoVirtualMac) {
		return false
	}

	if !v.SvrPortRange.Equal(other.SvrPortRange) {
		return false
	}

	if !v.TrafficShaping.Equal(other.TrafficShaping) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VpnPaths.Equal(other.VpnPaths) {
		return false
	}

	if !v.WanArpPolicer.Equal(other.WanArpPolicer) {
		return false
	}

	if !v.WanExtIp.Equal(other.WanExtIp) {
		return false
	}

	if !v.WanSourceNat.Equal(other.WanSourceNat) {
		return false
	}

	if !v.WanType.Equal(other.WanType) {
		return false
	}

	return true
}

func (v PortConfigValue) Type(ctx context.Context) attr.Type {
	return PortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":     basetypes.StringType{},
		"disable_autoneg": basetypes.BoolType{},
		"disabled":        basetypes.BoolType{},
		"dsl_type":        basetypes.StringType{},
		"dsl_vci":         basetypes.Int64Type{},
		"dsl_vpi":         basetypes.Int64Type{},
		"duplex":          basetypes.StringType{},
		"ip_config": basetypes.ObjectType{
			AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
		},
		"lte_apn":      basetypes.StringType{},
		"lte_auth":     basetypes.StringType{},
		"lte_backup":   basetypes.BoolType{},
		"lte_password": basetypes.StringType{},
		"lte_username": basetypes.StringType{},
		"mtu":          basetypes.Int64Type{},
		"name":         basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"outer_vlan_id": basetypes.Int64Type{},
		"poe_disabled":  basetypes.BoolType{},
		"port_network":  basetypes.StringType{},
		"preserve_dscp": basetypes.BoolType{},
		"redundant":     basetypes.BoolType{},
		"reth_idx":      basetypes.Int64Type{},
		"reth_node":     basetypes.StringType{},
		"reth_nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"speed":              basetypes.StringType{},
		"ssr_no_virtual_mac": basetypes.BoolType{},
		"svr_port_range":     basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
		"usage":   basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
		"vpn_paths": basetypes.MapType{
			ElemType: VpnPathsValue{}.Type(ctx),
		},
		"wan_arp_policer": basetypes.StringType{},
		"wan_ext_ip":      basetypes.StringType{},
		"wan_source_nat": basetypes.ObjectType{
			AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
		},
		"wan_type": basetypes.StringType{},
	}
}


type IpConfigType struct {
	basetypes.ObjectType
}

func (t IpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(IpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpConfigType) String() string {
	return "IpConfigType"
}

func (t IpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	poserPasswordAttribute, ok := attributes["poser_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poser_password is missing from object`)

		return nil, diags
	}

	poserPasswordVal, ok := poserPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poser_password expected to be basetypes.StringValue, was: %T`, poserPasswordAttribute))
	}

	pppoeAuthAttribute, ok := attributes["pppoe_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_auth is missing from object`)

		return nil, diags
	}

	pppoeAuthVal, ok := pppoeAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_auth expected to be basetypes.StringValue, was: %T`, pppoeAuthAttribute))
	}

	pppoeUsernameAttribute, ok := attributes["pppoe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_username is missing from object`)

		return nil, diags
	}

	pppoeUsernameVal, ok := pppoeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_username expected to be basetypes.StringValue, was: %T`, pppoeUsernameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpConfigValue{
		Dns:           dnsVal,
		DnsSuffix:     dnsSuffixVal,
		Gateway:       gatewayVal,
		Ip:            ipVal,
		Netmask:       netmaskVal,
		Network:       networkVal,
		PoserPassword: poserPasswordVal,
		PppoeAuth:     pppoeAuthVal,
		PppoeUsername: pppoeUsernameVal,
		IpConfigType:  typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueNull() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewIpConfigValueUnknown() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, a missing attribute value was detected. "+
					"A IpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpConfigValue Attribute Type",
				"While creating a IpConfigValue value, an invalid attribute value was detected. "+
					"A IpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, an extra attribute value was detected. "+
					"A IpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	poserPasswordAttribute, ok := attributes["poser_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poser_password is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	poserPasswordVal, ok := poserPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poser_password expected to be basetypes.StringValue, was: %T`, poserPasswordAttribute))
	}

	pppoeAuthAttribute, ok := attributes["pppoe_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_auth is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	pppoeAuthVal, ok := pppoeAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_auth expected to be basetypes.StringValue, was: %T`, pppoeAuthAttribute))
	}

	pppoeUsernameAttribute, ok := attributes["pppoe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_username is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	pppoeUsernameVal, ok := pppoeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_username expected to be basetypes.StringValue, was: %T`, pppoeUsernameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	return IpConfigValue{
		Dns:           dnsVal,
		DnsSuffix:     dnsSuffixVal,
		Gateway:       gatewayVal,
		Ip:            ipVal,
		Netmask:       netmaskVal,
		Network:       networkVal,
		PoserPassword: poserPasswordVal,
		PppoeAuth:     pppoeAuthVal,
		PppoeUsername: pppoeUsernameVal,
		IpConfigType:  typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpConfigValue {
	object, diags := NewIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpConfigValueMust(IpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpConfigType) ValueType(ctx context.Context) attr.Value {
	return IpConfigValue{}
}


type IpConfigValue struct {
	Dns           basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix     basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway       basetypes.StringValue `tfsdk:"gateway"`
	Ip            basetypes.StringValue `tfsdk:"ip"`
	Netmask       basetypes.StringValue `tfsdk:"netmask"`
	Network       basetypes.StringValue `tfsdk:"network"`
	PoserPassword basetypes.StringValue `tfsdk:"poser_password"`
	PppoeAuth     basetypes.StringValue `tfsdk:"pppoe_auth"`
	PppoeUsername basetypes.StringValue `tfsdk:"pppoe_username"`
	IpConfigType  basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v IpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["poser_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pppoe_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pppoe_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.PoserPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poser_password"] = val

		val, err = v.PppoeAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pppoe_auth"] = val

		val, err = v.PppoeUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pppoe_username"] = val

		val, err = v.IpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpConfigValue) String() string {
	return "IpConfigValue"
}

func (v IpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":        basetypes.StringType{},
			"ip":             basetypes.StringType{},
			"netmask":        basetypes.StringType{},
			"network":        basetypes.StringType{},
			"poser_password": basetypes.StringType{},
			"pppoe_auth":     basetypes.StringType{},
			"pppoe_username": basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":        basetypes.StringType{},
			"ip":             basetypes.StringType{},
			"netmask":        basetypes.StringType{},
			"network":        basetypes.StringType{},
			"poser_password": basetypes.StringType{},
			"pppoe_auth":     basetypes.StringType{},
			"pppoe_username": basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":        basetypes.StringType{},
		"ip":             basetypes.StringType{},
		"netmask":        basetypes.StringType{},
		"network":        basetypes.StringType{},
		"poser_password": basetypes.StringType{},
		"pppoe_auth":     basetypes.StringType{},
		"pppoe_username": basetypes.StringType{},
		"type":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns":            dnsVal,
			"dns_suffix":     dnsSuffixVal,
			"gateway":        v.Gateway,
			"ip":             v.Ip,
			"netmask":        v.Netmask,
			"network":        v.Network,
			"poser_password": v.PoserPassword,
			"pppoe_auth":     v.PppoeAuth,
			"pppoe_username": v.PppoeUsername,
			"type":           v.IpConfigType,
		})

	return objVal, diags
}

func (v IpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(IpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.PoserPassword.Equal(other.PoserPassword) {
		return false
	}

	if !v.PppoeAuth.Equal(other.PppoeAuth) {
		return false
	}

	if !v.PppoeUsername.Equal(other.PppoeUsername) {
		return false
	}

	if !v.IpConfigType.Equal(other.IpConfigType) {
		return false
	}

	return true
}

func (v IpConfigValue) Type(ctx context.Context) attr.Type {
	return IpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":        basetypes.StringType{},
		"ip":             basetypes.StringType{},
		"netmask":        basetypes.StringType{},
		"network":        basetypes.StringType{},
		"poser_password": basetypes.StringType{},
		"pppoe_auth":     basetypes.StringType{},
		"pppoe_username": basetypes.StringType{},
		"type":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TrafficShapingType{}

type TrafficShapingType struct {
	basetypes.ObjectType
}

func (t TrafficShapingType) Equal(o attr.Type) bool {
	other, ok := o.(TrafficShapingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrafficShapingType) String() string {
	return "TrafficShapingType"
}

func (t TrafficShapingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	classPercentagesAttribute, ok := attributes["class_percentages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class_percentages is missing from object`)

		return nil, diags
	}

	classPercentagesVal, ok := classPercentagesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class_percentages expected to be basetypes.ListValue, was: %T`, classPercentagesAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrafficShapingValue{
		ClassPercentages: classPercentagesVal,
		Enabled:          enabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTrafficShapingValueNull() TrafficShapingValue {
	return TrafficShapingValue{
		state: attr.ValueStateNull,
	}
}

func NewTrafficShapingValueUnknown() TrafficShapingValue {
	return TrafficShapingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrafficShapingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrafficShapingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrafficShapingValue Attribute Value",
				"While creating a TrafficShapingValue value, a missing attribute value was detected. "+
					"A TrafficShapingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficShapingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrafficShapingValue Attribute Type",
				"While creating a TrafficShapingValue value, an invalid attribute value was detected. "+
					"A TrafficShapingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficShapingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrafficShapingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrafficShapingValue Attribute Value",
				"While creating a TrafficShapingValue value, an extra attribute value was detected. "+
					"A TrafficShapingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrafficShapingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrafficShapingValueUnknown(), diags
	}

	classPercentagesAttribute, ok := attributes["class_percentages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class_percentages is missing from object`)

		return NewTrafficShapingValueUnknown(), diags
	}

	classPercentagesVal, ok := classPercentagesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class_percentages expected to be basetypes.ListValue, was: %T`, classPercentagesAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewTrafficShapingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewTrafficShapingValueUnknown(), diags
	}

	return TrafficShapingValue{
		ClassPercentages: classPercentagesVal,
		Enabled:          enabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTrafficShapingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrafficShapingValue {
	object, diags := NewTrafficShapingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrafficShapingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrafficShapingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrafficShapingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrafficShapingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrafficShapingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrafficShapingValueMust(TrafficShapingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrafficShapingType) ValueType(ctx context.Context) attr.Value {
	return TrafficShapingValue{}
}

var _ basetypes.ObjectValuable = TrafficShapingValue{}

type TrafficShapingValue struct {
	ClassPercentages basetypes.ListValue `tfsdk:"class_percentages"`
	Enabled          basetypes.BoolValue `tfsdk:"enabled"`
	state            attr.ValueState
}

func (v TrafficShapingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["class_percentages"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ClassPercentages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["class_percentages"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrafficShapingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrafficShapingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrafficShapingValue) String() string {
	return "TrafficShapingValue"
}

func (v TrafficShapingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	classPercentagesVal, d := types.ListValue(types.Int64Type, v.ClassPercentages.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"class_percentages": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"class_percentages": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"class_percentages": classPercentagesVal,
			"enabled":           v.Enabled,
		})

	return objVal, diags
}

func (v TrafficShapingValue) Equal(o attr.Value) bool {
	other, ok := o.(TrafficShapingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClassPercentages.Equal(other.ClassPercentages) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v TrafficShapingValue) Type(ctx context.Context) attr.Type {
	return TrafficShapingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrafficShapingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"class_percentages": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VpnPathsType{}

type VpnPathsType struct {
	basetypes.ObjectType
}

func (t VpnPathsType) Equal(o attr.Type) bool {
	other, ok := o.(VpnPathsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnPathsType) String() string {
	return "VpnPathsType"
}

func (t VpnPathsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfdProfileAttribute, ok := attributes["bfd_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_profile is missing from object`)

		return nil, diags
	}

	bfdProfileVal, ok := bfdProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_profile expected to be basetypes.StringValue, was: %T`, bfdProfileAttribute))
	}

	bfdUseTunnelModeAttribute, ok := attributes["bfd_use_tunnel_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_use_tunnel_mode is missing from object`)

		return nil, diags
	}

	bfdUseTunnelModeVal, ok := bfdUseTunnelModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_use_tunnel_mode expected to be basetypes.BoolValue, was: %T`, bfdUseTunnelModeAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return nil, diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnPathsValue{
		BfdProfile:       bfdProfileVal,
		BfdUseTunnelMode: bfdUseTunnelModeVal,
		Preference:       preferenceVal,
		Role:             roleVal,
		TrafficShaping:   trafficShapingVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVpnPathsValueNull() VpnPathsValue {
	return VpnPathsValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnPathsValueUnknown() VpnPathsValue {
	return VpnPathsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnPathsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnPathsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnPathsValue Attribute Value",
				"While creating a VpnPathsValue value, a missing attribute value was detected. "+
					"A VpnPathsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnPathsValue Attribute Type",
				"While creating a VpnPathsValue value, an invalid attribute value was detected. "+
					"A VpnPathsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnPathsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnPathsValue Attribute Value",
				"While creating a VpnPathsValue value, an extra attribute value was detected. "+
					"A VpnPathsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnPathsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnPathsValueUnknown(), diags
	}

	bfdProfileAttribute, ok := attributes["bfd_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_profile is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	bfdProfileVal, ok := bfdProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_profile expected to be basetypes.StringValue, was: %T`, bfdProfileAttribute))
	}

	bfdUseTunnelModeAttribute, ok := attributes["bfd_use_tunnel_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_use_tunnel_mode is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	bfdUseTunnelModeVal, ok := bfdUseTunnelModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_use_tunnel_mode expected to be basetypes.BoolValue, was: %T`, bfdUseTunnelModeAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	if diags.HasError() {
		return NewVpnPathsValueUnknown(), diags
	}

	return VpnPathsValue{
		BfdProfile:       bfdProfileVal,
		BfdUseTunnelMode: bfdUseTunnelModeVal,
		Preference:       preferenceVal,
		Role:             roleVal,
		TrafficShaping:   trafficShapingVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVpnPathsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnPathsValue {
	object, diags := NewVpnPathsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnPathsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnPathsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnPathsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnPathsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnPathsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnPathsValueMust(VpnPathsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnPathsType) ValueType(ctx context.Context) attr.Value {
	return VpnPathsValue{}
}

var _ basetypes.ObjectValuable = VpnPathsValue{}

type VpnPathsValue struct {
	BfdProfile       basetypes.StringValue `tfsdk:"bfd_profile"`
	BfdUseTunnelMode basetypes.BoolValue   `tfsdk:"bfd_use_tunnel_mode"`
	Preference       basetypes.Int64Value  `tfsdk:"preference"`
	Role             basetypes.StringValue `tfsdk:"role"`
	TrafficShaping   basetypes.ObjectValue `tfsdk:"traffic_shaping"`
	state            attr.ValueState
}

func (v VpnPathsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bfd_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bfd_use_tunnel_mode"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["traffic_shaping"] = basetypes.ObjectType{
		AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BfdProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_profile"] = val

		val, err = v.BfdUseTunnelMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_use_tunnel_mode"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.TrafficShaping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["traffic_shaping"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnPathsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnPathsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnPathsValue) String() string {
	return "VpnPathsValue"
}

func (v VpnPathsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var trafficShaping basetypes.ObjectValue

	if v.TrafficShaping.IsNull() {
		trafficShaping = types.ObjectNull(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectUnknown(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.TrafficShaping.IsNull() && !v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectValueMust(
			TrafficShapingValue{}.AttributeTypes(ctx),
			v.TrafficShaping.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd_profile":         basetypes.StringType{},
		"bfd_use_tunnel_mode": basetypes.BoolType{},
		"preference":          basetypes.Int64Type{},
		"role":                basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd_profile":         v.BfdProfile,
			"bfd_use_tunnel_mode": v.BfdUseTunnelMode,
			"preference":          v.Preference,
			"role":                v.Role,
			"traffic_shaping":     trafficShaping,
		})

	return objVal, diags
}

func (v VpnPathsValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnPathsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BfdProfile.Equal(other.BfdProfile) {
		return false
	}

	if !v.BfdUseTunnelMode.Equal(other.BfdUseTunnelMode) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.TrafficShaping.Equal(other.TrafficShaping) {
		return false
	}

	return true
}

func (v VpnPathsValue) Type(ctx context.Context) attr.Type {
	return VpnPathsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnPathsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd_profile":         basetypes.StringType{},
		"bfd_use_tunnel_mode": basetypes.BoolType{},
		"preference":          basetypes.Int64Type{},
		"role":                basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
	}
}






















var _ basetypes.ObjectTypable = WanSourceNatType{}

type WanSourceNatType struct {
	basetypes.ObjectType
}

func (t WanSourceNatType) Equal(o attr.Type) bool {
	other, ok := o.(WanSourceNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WanSourceNatType) String() string {
	return "WanSourceNatType"
}

func (t WanSourceNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return nil, diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WanSourceNatValue{
		Disabled: disabledVal,
		NatPool:  natPoolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewWanSourceNatValueNull() WanSourceNatValue {
	return WanSourceNatValue{
		state: attr.ValueStateNull,
	}
}

func NewWanSourceNatValueUnknown() WanSourceNatValue {
	return WanSourceNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWanSourceNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WanSourceNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WanSourceNatValue Attribute Value",
				"While creating a WanSourceNatValue value, a missing attribute value was detected. "+
					"A WanSourceNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSourceNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WanSourceNatValue Attribute Type",
				"While creating a WanSourceNatValue value, an invalid attribute value was detected. "+
					"A WanSourceNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSourceNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WanSourceNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WanSourceNatValue Attribute Value",
				"While creating a WanSourceNatValue value, an extra attribute value was detected. "+
					"A WanSourceNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WanSourceNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWanSourceNatValueUnknown(), diags
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewWanSourceNatValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return NewWanSourceNatValueUnknown(), diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	if diags.HasError() {
		return NewWanSourceNatValueUnknown(), diags
	}

	return WanSourceNatValue{
		Disabled: disabledVal,
		NatPool:  natPoolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewWanSourceNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WanSourceNatValue {
	object, diags := NewWanSourceNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWanSourceNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WanSourceNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWanSourceNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWanSourceNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWanSourceNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWanSourceNatValueMust(WanSourceNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WanSourceNatType) ValueType(ctx context.Context) attr.Value {
	return WanSourceNatValue{}
}

var _ basetypes.ObjectValuable = WanSourceNatValue{}

type WanSourceNatValue struct {
	Disabled basetypes.BoolValue   `tfsdk:"disabled"`
	NatPool  basetypes.StringValue `tfsdk:"nat_pool"`
	state    attr.ValueState
}

func (v WanSourceNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nat_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.NatPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WanSourceNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WanSourceNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WanSourceNatValue) String() string {
	return "WanSourceNatValue"
}

func (v WanSourceNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"nat_pool": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disabled": v.Disabled,
			"nat_pool": v.NatPool,
		})

	return objVal, diags
}

func (v WanSourceNatValue) Equal(o attr.Value) bool {
	other, ok := o.(WanSourceNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.NatPool.Equal(other.NatPool) {
		return false
	}

	return true
}

func (v WanSourceNatValue) Type(ctx context.Context) attr.Type {
	return WanSourceNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WanSourceNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"nat_pool": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortMirroringType{}

type PortMirroringType struct {
	basetypes.ObjectType
}

func (t PortMirroringType) Equal(o attr.Type) bool {
	other, ok := o.(PortMirroringType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMirroringType) String() string {
	return "PortMirroringType"
}

func (t PortMirroringType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portMirrorAttribute, ok := attributes["port_mirror"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirror is missing from object`)

		return nil, diags
	}

	portMirrorVal, ok := portMirrorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirror expected to be basetypes.ObjectValue, was: %T`, portMirrorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortMirroringValue{
		PortMirror: portMirrorVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueNull() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMirroringValueUnknown() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMirroringValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMirroringValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, a missing attribute value was detected. "+
					"A PortMirroringValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMirroringValue Attribute Type",
				"While creating a PortMirroringValue value, an invalid attribute value was detected. "+
					"A PortMirroringValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, an extra attribute value was detected. "+
					"A PortMirroringValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMirroringValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	portMirrorAttribute, ok := attributes["port_mirror"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirror is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	portMirrorVal, ok := portMirrorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirror expected to be basetypes.ObjectValue, was: %T`, portMirrorAttribute))
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	return PortMirroringValue{
		PortMirror: portMirrorVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMirroringValue {
	object, diags := NewPortMirroringValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMirroringValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMirroringType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMirroringValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMirroringValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMirroringValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMirroringValueMust(PortMirroringValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMirroringType) ValueType(ctx context.Context) attr.Value {
	return PortMirroringValue{}
}

var _ basetypes.ObjectValuable = PortMirroringValue{}

type PortMirroringValue struct {
	PortMirror basetypes.ObjectValue `tfsdk:"port_mirror"`
	state      attr.ValueState
}

func (v PortMirroringValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["port_mirror"] = basetypes.ObjectType{
		AttrTypes: PortMirrorValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.PortMirror.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mirror"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMirroringValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMirroringValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMirroringValue) String() string {
	return "PortMirroringValue"
}

func (v PortMirroringValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var portMirror basetypes.ObjectValue

	if v.PortMirror.IsNull() {
		portMirror = types.ObjectNull(
			PortMirrorValue{}.AttributeTypes(ctx),
		)
	}

	if v.PortMirror.IsUnknown() {
		portMirror = types.ObjectUnknown(
			PortMirrorValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PortMirror.IsNull() && !v.PortMirror.IsUnknown() {
		portMirror = types.ObjectValueMust(
			PortMirrorValue{}.AttributeTypes(ctx),
			v.PortMirror.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"port_mirror": basetypes.ObjectType{
			AttrTypes: PortMirrorValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_mirror": portMirror,
		})

	return objVal, diags
}

func (v PortMirroringValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMirroringValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortMirror.Equal(other.PortMirror) {
		return false
	}

	return true
}

func (v PortMirroringValue) Type(ctx context.Context) attr.Type {
	return PortMirroringType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMirroringValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_mirror": basetypes.ObjectType{
			AttrTypes: PortMirrorValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PortMirrorType{}

type PortMirrorType struct {
	basetypes.ObjectType
}

func (t PortMirrorType) Equal(o attr.Type) bool {
	other, ok := o.(PortMirrorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMirrorType) String() string {
	return "PortMirrorType"
}

func (t PortMirrorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	familyTypeAttribute, ok := attributes["family_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family_type is missing from object`)

		return nil, diags
	}

	familyTypeVal, ok := familyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family_type expected to be basetypes.StringValue, was: %T`, familyTypeAttribute))
	}

	ingressPortIdsAttribute, ok := attributes["ingress_port_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_port_ids is missing from object`)

		return nil, diags
	}

	ingressPortIdsVal, ok := ingressPortIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_port_ids expected to be basetypes.ListValue, was: %T`, ingressPortIdsAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return nil, diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.Int64Value, was: %T`, rateAttribute))
	}

	runLengthAttribute, ok := attributes["run_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`run_length is missing from object`)

		return nil, diags
	}

	runLengthVal, ok := runLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`run_length expected to be basetypes.Int64Value, was: %T`, runLengthAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortMirrorValue{
		FamilyType:     familyTypeVal,
		IngressPortIds: ingressPortIdsVal,
		OutputPortId:   outputPortIdVal,
		Rate:           rateVal,
		RunLength:      runLengthVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPortMirrorValueNull() PortMirrorValue {
	return PortMirrorValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMirrorValueUnknown() PortMirrorValue {
	return PortMirrorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMirrorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMirrorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMirrorValue Attribute Value",
				"While creating a PortMirrorValue value, a missing attribute value was detected. "+
					"A PortMirrorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirrorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMirrorValue Attribute Type",
				"While creating a PortMirrorValue value, an invalid attribute value was detected. "+
					"A PortMirrorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirrorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMirrorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMirrorValue Attribute Value",
				"While creating a PortMirrorValue value, an extra attribute value was detected. "+
					"A PortMirrorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMirrorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMirrorValueUnknown(), diags
	}

	familyTypeAttribute, ok := attributes["family_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family_type is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	familyTypeVal, ok := familyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family_type expected to be basetypes.StringValue, was: %T`, familyTypeAttribute))
	}

	ingressPortIdsAttribute, ok := attributes["ingress_port_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_port_ids is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	ingressPortIdsVal, ok := ingressPortIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_port_ids expected to be basetypes.ListValue, was: %T`, ingressPortIdsAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.Int64Value, was: %T`, rateAttribute))
	}

	runLengthAttribute, ok := attributes["run_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`run_length is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	runLengthVal, ok := runLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`run_length expected to be basetypes.Int64Value, was: %T`, runLengthAttribute))
	}

	if diags.HasError() {
		return NewPortMirrorValueUnknown(), diags
	}

	return PortMirrorValue{
		FamilyType:     familyTypeVal,
		IngressPortIds: ingressPortIdsVal,
		OutputPortId:   outputPortIdVal,
		Rate:           rateVal,
		RunLength:      runLengthVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPortMirrorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMirrorValue {
	object, diags := NewPortMirrorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMirrorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMirrorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMirrorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMirrorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMirrorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMirrorValueMust(PortMirrorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMirrorType) ValueType(ctx context.Context) attr.Value {
	return PortMirrorValue{}
}

var _ basetypes.ObjectValuable = PortMirrorValue{}

type PortMirrorValue struct {
	FamilyType     basetypes.StringValue `tfsdk:"family_type"`
	IngressPortIds basetypes.ListValue   `tfsdk:"ingress_port_ids"`
	OutputPortId   basetypes.StringValue `tfsdk:"output_port_id"`
	Rate           basetypes.Int64Value  `tfsdk:"rate"`
	RunLength      basetypes.Int64Value  `tfsdk:"run_length"`
	state          attr.ValueState
}

func (v PortMirrorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["family_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ingress_port_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["output_port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["run_length"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.FamilyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["family_type"] = val

		val, err = v.IngressPortIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress_port_ids"] = val

		val, err = v.OutputPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_port_id"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.RunLength.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["run_length"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMirrorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMirrorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMirrorValue) String() string {
	return "PortMirrorValue"
}

func (v PortMirrorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	ingressPortIdsVal, d := types.ListValue(types.StringType, v.IngressPortIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"family_type": basetypes.StringType{},
			"ingress_port_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_port_id": basetypes.StringType{},
			"rate":           basetypes.Int64Type{},
			"run_length":     basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"family_type": basetypes.StringType{},
		"ingress_port_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_port_id": basetypes.StringType{},
		"rate":           basetypes.Int64Type{},
		"run_length":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"family_type":      v.FamilyType,
			"ingress_port_ids": ingressPortIdsVal,
			"output_port_id":   v.OutputPortId,
			"rate":             v.Rate,
			"run_length":       v.RunLength,
		})

	return objVal, diags
}

func (v PortMirrorValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMirrorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FamilyType.Equal(other.FamilyType) {
		return false
	}

	if !v.IngressPortIds.Equal(other.IngressPortIds) {
		return false
	}

	if !v.OutputPortId.Equal(other.OutputPortId) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.RunLength.Equal(other.RunLength) {
		return false
	}

	return true
}

func (v PortMirrorValue) Type(ctx context.Context) attr.Type {
	return PortMirrorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMirrorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"family_type": basetypes.StringType{},
		"ingress_port_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_port_id": basetypes.StringType{},
		"rate":           basetypes.Int64Type{},
		"run_length":     basetypes.Int64Type{},
	}
}
