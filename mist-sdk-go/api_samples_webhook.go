/*
Mist API

> Version: **2406.1.10** > > Date: **June 29, 2024**  ---  ### Additional Documentation * [Mist Automation Guide](https://www.juniper.net/documentation/us/en/software/mist/automation-integration/index.html) * [Mist Location SDK](https://www.juniper.net/documentation/us/en/software/mist/location_services/topics/concept/mist-how-get-mist-sdk.html) * [Mist Product Updates](https://www.mist.com/documentation/category/product-updates/)  ---  ### Helpful Resources * [API Sandbox and Exercises](https://api-class.mist.com/) * [Postman Collection, Runners and Webhook Samples](https://www.postman.com/juniper-mist/workspace/mist-systems-s-public-workspace) * [API Demo Apps](https://apps.mist-lab.fr/) * [Juniper Blog](https://blogs.juniper.net/)  --- 

API version: 2406.1.10
Contact: tmunzer@juniper.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mistsdkgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type SamplesWebhookAPI interface {

	/*
	Alarms alarms

	Webhook sample for `alarm` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlarmsRequest
	*/
	Alarms(ctx context.Context) ApiAlarmsRequest

	// AlarmsExecute executes the request
	AlarmsExecute(r ApiAlarmsRequest) (*http.Response, error)

	/*
	AssetRaw assetRaw

	Webhook sample for `asset_raw` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

**will be deprecated after 06/30/2024**

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAssetRawRequest
	*/
	AssetRaw(ctx context.Context) ApiAssetRawRequest

	// AssetRawExecute executes the request
	AssetRawExecute(r ApiAssetRawRequest) (*http.Response, error)

	/*
	Audits audits

	Webhook sample for `audit` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditsRequest
	*/
	Audits(ctx context.Context) ApiAuditsRequest

	// AuditsExecute executes the request
	AuditsExecute(r ApiAuditsRequest) (*http.Response, error)

	/*
	ClientInfo clientJoin

	Webhook sample for `client_info` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiClientInfoRequest
	*/
	ClientInfo(ctx context.Context) ApiClientInfoRequest

	// ClientInfoExecute executes the request
	ClientInfoExecute(r ApiClientInfoRequest) (*http.Response, error)

	/*
	ClientJoin clientJoin

	Webhook sample for `client_join` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiClientJoinRequest
	*/
	ClientJoin(ctx context.Context) ApiClientJoinRequest

	// ClientJoinExecute executes the request
	ClientJoinExecute(r ApiClientJoinRequest) (*http.Response, error)

	/*
	ClientLatency alarms

	Webhook sample for `client-latency` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiClientLatencyRequest
	*/
	ClientLatency(ctx context.Context) ApiClientLatencyRequest

	// ClientLatencyExecute executes the request
	ClientLatencyExecute(r ApiClientLatencyRequest) (*http.Response, error)

	/*
	ClientSessions clientSessions

	Webhook sample for `client_sessions` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiClientSessionsRequest
	*/
	ClientSessions(ctx context.Context) ApiClientSessionsRequest

	// ClientSessionsExecute executes the request
	ClientSessionsExecute(r ApiClientSessionsRequest) (*http.Response, error)

	/*
	DeviceEvents deviceEvents

	Webhook sample for `device_events` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeviceEventsRequest
	*/
	DeviceEvents(ctx context.Context) ApiDeviceEventsRequest

	// DeviceEventsExecute executes the request
	DeviceEventsExecute(r ApiDeviceEventsRequest) (*http.Response, error)

	/*
	DeviceUpDown deviceUpDown

	Webhook sample for `device_updowns` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeviceUpDownRequest
	*/
	DeviceUpDown(ctx context.Context) ApiDeviceUpDownRequest

	// DeviceUpDownExecute executes the request
	DeviceUpDownExecute(r ApiDeviceUpDownRequest) (*http.Response, error)

	/*
	DiscoveredRawRssi discovered-raw-rssi

	Webhook sample for `discovered-raw-rssi` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDiscoveredRawRssiRequest
	*/
	DiscoveredRawRssi(ctx context.Context) ApiDiscoveredRawRssiRequest

	// DiscoveredRawRssiExecute executes the request
	DiscoveredRawRssiExecute(r ApiDiscoveredRawRssiRequest) (*http.Response, error)

	/*
	Location location

	Webhook sample for `location` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocationRequest
	*/
	Location(ctx context.Context) ApiLocationRequest

	// LocationExecute executes the request
	LocationExecute(r ApiLocationRequest) (*http.Response, error)

	/*
	LocationAsset location

	Webhook sample for `location_asset` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocationAssetRequest
	*/
	LocationAsset(ctx context.Context) ApiLocationAssetRequest

	// LocationAssetExecute executes the request
	LocationAssetExecute(r ApiLocationAssetRequest) (*http.Response, error)

	/*
	LocationCentrak alarms

	Webhook sample for `location_centrak` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocationCentrakRequest
	*/
	LocationCentrak(ctx context.Context) ApiLocationCentrakRequest

	// LocationCentrakExecute executes the request
	LocationCentrakExecute(r ApiLocationCentrakRequest) (*http.Response, error)

	/*
	LocationClient location

	Webhook sample for `location_client` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocationClientRequest
	*/
	LocationClient(ctx context.Context) ApiLocationClientRequest

	// LocationClientExecute executes the request
	LocationClientExecute(r ApiLocationClientRequest) (*http.Response, error)

	/*
	LocationSdk location

	Webhook sample for `location_sdk` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocationSdkRequest
	*/
	LocationSdk(ctx context.Context) ApiLocationSdkRequest

	// LocationSdkExecute executes the request
	LocationSdkExecute(r ApiLocationSdkRequest) (*http.Response, error)

	/*
	LocationUnclient location

	Webhook sample for `location_unclient` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLocationUnclientRequest
	*/
	LocationUnclient(ctx context.Context) ApiLocationUnclientRequest

	// LocationUnclientExecute executes the request
	LocationUnclientExecute(r ApiLocationUnclientRequest) (*http.Response, error)

	/*
	NacAccounting nacAccounting

	Webhook sample for `nac-accounting` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiNacAccountingRequest
	*/
	NacAccounting(ctx context.Context) ApiNacAccountingRequest

	// NacAccountingExecute executes the request
	NacAccountingExecute(r ApiNacAccountingRequest) (*http.Response, error)

	/*
	NacEvents nac_events

	Example Delivery of nac_events

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiNacEventsRequest
	*/
	NacEvents(ctx context.Context) ApiNacEventsRequest

	// NacEventsExecute executes the request
	NacEventsExecute(r ApiNacEventsRequest) (*http.Response, error)

	/*
	OccupancyAlerts occupancyAlerts

	Webhook sample for `occupancy_alerts` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOccupancyAlertsRequest
	*/
	OccupancyAlerts(ctx context.Context) ApiOccupancyAlertsRequest

	// OccupancyAlertsExecute executes the request
	OccupancyAlertsExecute(r ApiOccupancyAlertsRequest) (*http.Response, error)

	/*
	Ping ping

	Webhook sample for `ping` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPingRequest
	*/
	Ping(ctx context.Context) ApiPingRequest

	// PingExecute executes the request
	PingExecute(r ApiPingRequest) (*http.Response, error)

	/*
	SdkclientScanData sdkclientScanData

	Webhook sample for `sdkclient_scan_data` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSdkclientScanDataRequest
	*/
	SdkclientScanData(ctx context.Context) ApiSdkclientScanDataRequest

	// SdkclientScanDataExecute executes the request
	SdkclientScanDataExecute(r ApiSdkclientScanDataRequest) (*http.Response, error)

	/*
	SiteSle site_sle

	Webhook sample for `site_sle` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSiteSleRequest
	*/
	SiteSle(ctx context.Context) ApiSiteSleRequest

	// SiteSleExecute executes the request
	SiteSleExecute(r ApiSiteSleRequest) (*http.Response, error)

	/*
	Zone zone

	Webhook sample for `zone` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiZoneRequest
	*/
	Zone(ctx context.Context) ApiZoneRequest

	// ZoneExecute executes the request
	ZoneExecute(r ApiZoneRequest) (*http.Response, error)
}

// SamplesWebhookAPIService SamplesWebhookAPI service
type SamplesWebhookAPIService service

type ApiAlarmsRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookAlarms *WebhookAlarms
}

// **N.B.**: Fields like &#x60;aps&#x60;, &#x60;bssids&#x60;, &#x60;ssids&#x60; are event specific. They are relevant to this event type ( rogue-ap-detected). For a different event type, different fields may be sent. These don’t contain all affected entities and are representative samples of entities (capped at 10). For marvis action related events, we expose &#x60;details&#x60; to include more event specific details.  Events specific fields for other alarm event type can be found with API https://api.mist.com/api/v1/const/alarm_defs, under “fields” array of /alarm_defs response object.
func (r ApiAlarmsRequest) WebhookAlarms(webhookAlarms WebhookAlarms) ApiAlarmsRequest {
	r.webhookAlarms = &webhookAlarms
	return r
}

func (r ApiAlarmsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AlarmsExecute(r)
}

/*
Alarms alarms

Webhook sample for `alarm` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlarmsRequest
*/
func (a *SamplesWebhookAPIService) Alarms(ctx context.Context) ApiAlarmsRequest {
	return ApiAlarmsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) AlarmsExecute(r ApiAlarmsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.Alarms")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_alarm_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookAlarms
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssetRawRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookAssetRaw *WebhookAssetRaw
}

func (r ApiAssetRawRequest) WebhookAssetRaw(webhookAssetRaw WebhookAssetRaw) ApiAssetRawRequest {
	r.webhookAssetRaw = &webhookAssetRaw
	return r
}

func (r ApiAssetRawRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssetRawExecute(r)
}

/*
AssetRaw assetRaw

Webhook sample for `asset_raw` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

**will be deprecated after 06/30/2024**

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAssetRawRequest
*/
func (a *SamplesWebhookAPIService) AssetRaw(ctx context.Context) ApiAssetRawRequest {
	return ApiAssetRawRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) AssetRawExecute(r ApiAssetRawRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.AssetRaw")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_asset_raw_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookAssetRaw
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuditsRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookAudits *WebhookAudits
}

// 
func (r ApiAuditsRequest) WebhookAudits(webhookAudits WebhookAudits) ApiAuditsRequest {
	r.webhookAudits = &webhookAudits
	return r
}

func (r ApiAuditsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AuditsExecute(r)
}

/*
Audits audits

Webhook sample for `audit` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuditsRequest
*/
func (a *SamplesWebhookAPIService) Audits(ctx context.Context) ApiAuditsRequest {
	return ApiAuditsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) AuditsExecute(r ApiAuditsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.Audits")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_audit_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookAudits
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientInfoRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookClientInfo *WebhookClientInfo
}

func (r ApiClientInfoRequest) WebhookClientInfo(webhookClientInfo WebhookClientInfo) ApiClientInfoRequest {
	r.webhookClientInfo = &webhookClientInfo
	return r
}

func (r ApiClientInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClientInfoExecute(r)
}

/*
ClientInfo clientJoin

Webhook sample for `client_info` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClientInfoRequest
*/
func (a *SamplesWebhookAPIService) ClientInfo(ctx context.Context) ApiClientInfoRequest {
	return ApiClientInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) ClientInfoExecute(r ApiClientInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.ClientInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_client_info_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookClientInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientJoinRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookClientJoin *WebhookClientJoin
}

func (r ApiClientJoinRequest) WebhookClientJoin(webhookClientJoin WebhookClientJoin) ApiClientJoinRequest {
	r.webhookClientJoin = &webhookClientJoin
	return r
}

func (r ApiClientJoinRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClientJoinExecute(r)
}

/*
ClientJoin clientJoin

Webhook sample for `client_join` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClientJoinRequest
*/
func (a *SamplesWebhookAPIService) ClientJoin(ctx context.Context) ApiClientJoinRequest {
	return ApiClientJoinRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) ClientJoinExecute(r ApiClientJoinRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.ClientJoin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_client_join_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookClientJoin
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientLatencyRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookClientLatency *WebhookClientLatency
}

// 
func (r ApiClientLatencyRequest) WebhookClientLatency(webhookClientLatency WebhookClientLatency) ApiClientLatencyRequest {
	r.webhookClientLatency = &webhookClientLatency
	return r
}

func (r ApiClientLatencyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClientLatencyExecute(r)
}

/*
ClientLatency alarms

Webhook sample for `client-latency` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClientLatencyRequest
*/
func (a *SamplesWebhookAPIService) ClientLatency(ctx context.Context) ApiClientLatencyRequest {
	return ApiClientLatencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) ClientLatencyExecute(r ApiClientLatencyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.ClientLatency")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_client_latency_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookClientLatency
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiClientSessionsRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookClientSessions *WebhookClientSessions
}

func (r ApiClientSessionsRequest) WebhookClientSessions(webhookClientSessions WebhookClientSessions) ApiClientSessionsRequest {
	r.webhookClientSessions = &webhookClientSessions
	return r
}

func (r ApiClientSessionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClientSessionsExecute(r)
}

/*
ClientSessions clientSessions

Webhook sample for `client_sessions` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClientSessionsRequest
*/
func (a *SamplesWebhookAPIService) ClientSessions(ctx context.Context) ApiClientSessionsRequest {
	return ApiClientSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) ClientSessionsExecute(r ApiClientSessionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.ClientSessions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_client_sessions_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookClientSessions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceEventsRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookDeviceEvents *WebhookDeviceEvents
}

func (r ApiDeviceEventsRequest) WebhookDeviceEvents(webhookDeviceEvents WebhookDeviceEvents) ApiDeviceEventsRequest {
	r.webhookDeviceEvents = &webhookDeviceEvents
	return r
}

func (r ApiDeviceEventsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeviceEventsExecute(r)
}

/*
DeviceEvents deviceEvents

Webhook sample for `device_events` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceEventsRequest
*/
func (a *SamplesWebhookAPIService) DeviceEvents(ctx context.Context) ApiDeviceEventsRequest {
	return ApiDeviceEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) DeviceEventsExecute(r ApiDeviceEventsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.DeviceEvents")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_device_events_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookDeviceEvents
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceUpDownRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookDeviceUpdowns *WebhookDeviceUpdowns
}

func (r ApiDeviceUpDownRequest) WebhookDeviceUpdowns(webhookDeviceUpdowns WebhookDeviceUpdowns) ApiDeviceUpDownRequest {
	r.webhookDeviceUpdowns = &webhookDeviceUpdowns
	return r
}

func (r ApiDeviceUpDownRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeviceUpDownExecute(r)
}

/*
DeviceUpDown deviceUpDown

Webhook sample for `device_updowns` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceUpDownRequest
*/
func (a *SamplesWebhookAPIService) DeviceUpDown(ctx context.Context) ApiDeviceUpDownRequest {
	return ApiDeviceUpDownRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) DeviceUpDownExecute(r ApiDeviceUpDownRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.DeviceUpDown")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_device_updowns_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookDeviceUpdowns
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDiscoveredRawRssiRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookDiscoveredRawRssi *WebhookDiscoveredRawRssi
}

func (r ApiDiscoveredRawRssiRequest) WebhookDiscoveredRawRssi(webhookDiscoveredRawRssi WebhookDiscoveredRawRssi) ApiDiscoveredRawRssiRequest {
	r.webhookDiscoveredRawRssi = &webhookDiscoveredRawRssi
	return r
}

func (r ApiDiscoveredRawRssiRequest) Execute() (*http.Response, error) {
	return r.ApiService.DiscoveredRawRssiExecute(r)
}

/*
DiscoveredRawRssi discovered-raw-rssi

Webhook sample for `discovered-raw-rssi` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDiscoveredRawRssiRequest
*/
func (a *SamplesWebhookAPIService) DiscoveredRawRssi(ctx context.Context) ApiDiscoveredRawRssiRequest {
	return ApiDiscoveredRawRssiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) DiscoveredRawRssiExecute(r ApiDiscoveredRawRssiRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.DiscoveredRawRssi")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_discovered_raw_rssi_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookDiscoveredRawRssi
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLocationRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookLocation *WebhookLocation
}

func (r ApiLocationRequest) WebhookLocation(webhookLocation WebhookLocation) ApiLocationRequest {
	r.webhookLocation = &webhookLocation
	return r
}

func (r ApiLocationRequest) Execute() (*http.Response, error) {
	return r.ApiService.LocationExecute(r)
}

/*
Location location

Webhook sample for `location` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLocationRequest
*/
func (a *SamplesWebhookAPIService) Location(ctx context.Context) ApiLocationRequest {
	return ApiLocationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) LocationExecute(r ApiLocationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.Location")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_location_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookLocation
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLocationAssetRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookLocationAsset *WebhookLocationAsset
}

func (r ApiLocationAssetRequest) WebhookLocationAsset(webhookLocationAsset WebhookLocationAsset) ApiLocationAssetRequest {
	r.webhookLocationAsset = &webhookLocationAsset
	return r
}

func (r ApiLocationAssetRequest) Execute() (*http.Response, error) {
	return r.ApiService.LocationAssetExecute(r)
}

/*
LocationAsset location

Webhook sample for `location_asset` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLocationAssetRequest
*/
func (a *SamplesWebhookAPIService) LocationAsset(ctx context.Context) ApiLocationAssetRequest {
	return ApiLocationAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) LocationAssetExecute(r ApiLocationAssetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.LocationAsset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_location_asset_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookLocationAsset
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLocationCentrakRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookLocationCentrak *WebhookLocationCentrak
}

// **N.B.**: Fields like &#x60;aps&#x60;, &#x60;bssids&#x60;, &#x60;ssids&#x60; are event specific. They are relevant to this event type ( rogue-ap-detected). For a different event type, different fields may be sent. These don’t contain all affected entities and are representative samples of entities (capped at 10). For marvis action related events, we expose &#x60;details&#x60; to include more event specific details.  Events specific fields for other alarm event type can be found with API https://api.mist.com/api/v1/const/alarm_defs, under “fields” array of /alarm_defs response object.
func (r ApiLocationCentrakRequest) WebhookLocationCentrak(webhookLocationCentrak WebhookLocationCentrak) ApiLocationCentrakRequest {
	r.webhookLocationCentrak = &webhookLocationCentrak
	return r
}

func (r ApiLocationCentrakRequest) Execute() (*http.Response, error) {
	return r.ApiService.LocationCentrakExecute(r)
}

/*
LocationCentrak alarms

Webhook sample for `location_centrak` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLocationCentrakRequest
*/
func (a *SamplesWebhookAPIService) LocationCentrak(ctx context.Context) ApiLocationCentrakRequest {
	return ApiLocationCentrakRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) LocationCentrakExecute(r ApiLocationCentrakRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.LocationCentrak")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_location_centrak_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookLocationCentrak
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLocationClientRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookLocationClient *WebhookLocationClient
}

func (r ApiLocationClientRequest) WebhookLocationClient(webhookLocationClient WebhookLocationClient) ApiLocationClientRequest {
	r.webhookLocationClient = &webhookLocationClient
	return r
}

func (r ApiLocationClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.LocationClientExecute(r)
}

/*
LocationClient location

Webhook sample for `location_client` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLocationClientRequest
*/
func (a *SamplesWebhookAPIService) LocationClient(ctx context.Context) ApiLocationClientRequest {
	return ApiLocationClientRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) LocationClientExecute(r ApiLocationClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.LocationClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_location_client_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookLocationClient
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLocationSdkRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookLocationSdk *WebhookLocationSdk
}

func (r ApiLocationSdkRequest) WebhookLocationSdk(webhookLocationSdk WebhookLocationSdk) ApiLocationSdkRequest {
	r.webhookLocationSdk = &webhookLocationSdk
	return r
}

func (r ApiLocationSdkRequest) Execute() (*http.Response, error) {
	return r.ApiService.LocationSdkExecute(r)
}

/*
LocationSdk location

Webhook sample for `location_sdk` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLocationSdkRequest
*/
func (a *SamplesWebhookAPIService) LocationSdk(ctx context.Context) ApiLocationSdkRequest {
	return ApiLocationSdkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) LocationSdkExecute(r ApiLocationSdkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.LocationSdk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_location_sdk_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookLocationSdk
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLocationUnclientRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookLocationUnclient *WebhookLocationUnclient
}

func (r ApiLocationUnclientRequest) WebhookLocationUnclient(webhookLocationUnclient WebhookLocationUnclient) ApiLocationUnclientRequest {
	r.webhookLocationUnclient = &webhookLocationUnclient
	return r
}

func (r ApiLocationUnclientRequest) Execute() (*http.Response, error) {
	return r.ApiService.LocationUnclientExecute(r)
}

/*
LocationUnclient location

Webhook sample for `location_unclient` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLocationUnclientRequest
*/
func (a *SamplesWebhookAPIService) LocationUnclient(ctx context.Context) ApiLocationUnclientRequest {
	return ApiLocationUnclientRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) LocationUnclientExecute(r ApiLocationUnclientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.LocationUnclient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_location_unclient_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookLocationUnclient
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNacAccountingRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookNacAccounting *WebhookNacAccounting
}

func (r ApiNacAccountingRequest) WebhookNacAccounting(webhookNacAccounting WebhookNacAccounting) ApiNacAccountingRequest {
	r.webhookNacAccounting = &webhookNacAccounting
	return r
}

func (r ApiNacAccountingRequest) Execute() (*http.Response, error) {
	return r.ApiService.NacAccountingExecute(r)
}

/*
NacAccounting nacAccounting

Webhook sample for `nac-accounting` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNacAccountingRequest
*/
func (a *SamplesWebhookAPIService) NacAccounting(ctx context.Context) ApiNacAccountingRequest {
	return ApiNacAccountingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) NacAccountingExecute(r ApiNacAccountingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.NacAccounting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_nac_accounting_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookNacAccounting
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNacEventsRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookNacEvents *WebhookNacEvents
}

func (r ApiNacEventsRequest) WebhookNacEvents(webhookNacEvents WebhookNacEvents) ApiNacEventsRequest {
	r.webhookNacEvents = &webhookNacEvents
	return r
}

func (r ApiNacEventsRequest) Execute() (*http.Response, error) {
	return r.ApiService.NacEventsExecute(r)
}

/*
NacEvents nac_events

Example Delivery of nac_events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNacEventsRequest
*/
func (a *SamplesWebhookAPIService) NacEvents(ctx context.Context) ApiNacEventsRequest {
	return ApiNacEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) NacEventsExecute(r ApiNacEventsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.NacEvents")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_nac_events_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookNacEvents
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOccupancyAlertsRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookOccupancyAlerts *WebhookOccupancyAlerts
}

func (r ApiOccupancyAlertsRequest) WebhookOccupancyAlerts(webhookOccupancyAlerts WebhookOccupancyAlerts) ApiOccupancyAlertsRequest {
	r.webhookOccupancyAlerts = &webhookOccupancyAlerts
	return r
}

func (r ApiOccupancyAlertsRequest) Execute() (*http.Response, error) {
	return r.ApiService.OccupancyAlertsExecute(r)
}

/*
OccupancyAlerts occupancyAlerts

Webhook sample for `occupancy_alerts` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOccupancyAlertsRequest
*/
func (a *SamplesWebhookAPIService) OccupancyAlerts(ctx context.Context) ApiOccupancyAlertsRequest {
	return ApiOccupancyAlertsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) OccupancyAlertsExecute(r ApiOccupancyAlertsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.OccupancyAlerts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_occupancy_alerts_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookOccupancyAlerts
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPingRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookPing *WebhookPing
}

func (r ApiPingRequest) WebhookPing(webhookPing WebhookPing) ApiPingRequest {
	r.webhookPing = &webhookPing
	return r
}

func (r ApiPingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PingExecute(r)
}

/*
Ping ping

Webhook sample for `ping` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingRequest
*/
func (a *SamplesWebhookAPIService) Ping(ctx context.Context) ApiPingRequest {
	return ApiPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) PingExecute(r ApiPingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.Ping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_ping_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookPing
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSdkclientScanDataRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookSdkclientScanData *WebhookSdkclientScanData
}

func (r ApiSdkclientScanDataRequest) WebhookSdkclientScanData(webhookSdkclientScanData WebhookSdkclientScanData) ApiSdkclientScanDataRequest {
	r.webhookSdkclientScanData = &webhookSdkclientScanData
	return r
}

func (r ApiSdkclientScanDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.SdkclientScanDataExecute(r)
}

/*
SdkclientScanData sdkclientScanData

Webhook sample for `sdkclient_scan_data` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSdkclientScanDataRequest
*/
func (a *SamplesWebhookAPIService) SdkclientScanData(ctx context.Context) ApiSdkclientScanDataRequest {
	return ApiSdkclientScanDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) SdkclientScanDataExecute(r ApiSdkclientScanDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.SdkclientScanData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_sdkclient_scan_data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookSdkclientScanData
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSiteSleRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookSiteSle *WebhookSiteSle
}

// 
func (r ApiSiteSleRequest) WebhookSiteSle(webhookSiteSle WebhookSiteSle) ApiSiteSleRequest {
	r.webhookSiteSle = &webhookSiteSle
	return r
}

func (r ApiSiteSleRequest) Execute() (*http.Response, error) {
	return r.ApiService.SiteSleExecute(r)
}

/*
SiteSle site_sle

Webhook sample for `site_sle` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSiteSleRequest
*/
func (a *SamplesWebhookAPIService) SiteSle(ctx context.Context) ApiSiteSleRequest {
	return ApiSiteSleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) SiteSleExecute(r ApiSiteSleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.SiteSle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_site_sle_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookSiteSle
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiZoneRequest struct {
	ctx context.Context
	ApiService SamplesWebhookAPI
	webhookZone *WebhookZone
}

func (r ApiZoneRequest) WebhookZone(webhookZone WebhookZone) ApiZoneRequest {
	r.webhookZone = &webhookZone
	return r
}

func (r ApiZoneRequest) Execute() (*http.Response, error) {
	return r.ApiService.ZoneExecute(r)
}

/*
Zone zone

Webhook sample for `zone` topic

**Note**: The server host will be your own server FQDN where the Mist Cloud is sending the webhook messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoneRequest
*/
func (a *SamplesWebhookAPIService) Zone(ctx context.Context) ApiZoneRequest {
	return ApiZoneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SamplesWebhookAPIService) ZoneExecute(r ApiZoneRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SamplesWebhookAPIService.Zone")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhook_example/_zone_"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookZone
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
